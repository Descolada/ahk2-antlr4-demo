{"mappings":"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C,CACA,OAAO,eAAiB,CACtB,EACA,EACA,EACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,IACA,EACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACD,AAAC,AACF,QAAO,KAAM,AACb,YAAW,MAAO,CAIhB,OAHI,AAAC,EAAY,KAAK,EACpB,CAAA,EAAY,KAAK,CAAG,IAAI,KAAkB,WAAW,CAAC,EAAY,cAAc,CAAA,EAE3E,EAAY,KAAK,AAC1B,CACA,OAAO,WAAa,IAAI,EAAW,EAAY,YAAY,CAAE,EAAY,aAAa,CAAE,EAAE,C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EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAC/D,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAC/D,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAC/D,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAC9D,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAC/D,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,EAC9D,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAC/D,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAC/D,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EA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AG,EAAE,EAC9D,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9D,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAC/D,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9D,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAC9D,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAC/D,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAC/D,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAC/D,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAC/D,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAC/D,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAC7D,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAC9D,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAC7D,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAC9D,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAC9D,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAC/D,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAC9D,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,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","sources":["<anon>","src/index.ts","node_modules/antlr4ng/dist/index.mjs","src/parser/MainGrammarLexer.ts","src/parser/MainGrammarParser.ts"],"sourcesContent":["var $c1efbdb2cbf46748$var$__defProp = Object.defineProperty;\nvar $c1efbdb2cbf46748$var$__name = (target, value)=>$c1efbdb2cbf46748$var$__defProp(target, \"name\", {\n        value: value,\n        configurable: true\n    });\n// src/IntStream.ts\nvar $c1efbdb2cbf46748$export$194a8984a055b1cc;\n((IntStream2)=>{\n    IntStream2.EOF = -1;\n    IntStream2.UNKNOWN_SOURCE_NAME = \"<unknown>\";\n})($c1efbdb2cbf46748$export$194a8984a055b1cc || ($c1efbdb2cbf46748$export$194a8984a055b1cc = {}));\n// src/Token.ts\nvar $c1efbdb2cbf46748$export$50792b0e93539fde;\n((Token2)=>{\n    Token2.INVALID_TYPE = 0;\n    Token2.EPSILON = -2;\n    Token2.MIN_USER_TOKEN_TYPE = 1;\n    Token2.EOF = $c1efbdb2cbf46748$export$194a8984a055b1cc.EOF;\n    Token2.DEFAULT_CHANNEL = 0;\n    Token2.HIDDEN_CHANNEL = 1;\n    Token2.MIN_USER_CHANNEL_VALUE = 2;\n})($c1efbdb2cbf46748$export$50792b0e93539fde || ($c1efbdb2cbf46748$export$50792b0e93539fde = {}));\nvar $c1efbdb2cbf46748$export$7c699a821ea811bc = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((candidate)=>{\n    const token = candidate;\n    return token.tokenSource !== void 0 && token.channel !== void 0;\n}, \"isToken\");\n// src/misc/BitSet.ts\nvar $c1efbdb2cbf46748$export$33dc8f3f7b9e35df = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BitSet\");\n    }\n    data;\n    /**\n   * Creates a new bit set. All bits are initially `false`.\n   *\n   * @param data Optional initial data.\n   */ constructor(data){\n        if (data) this.data = new Uint32Array(data.map((value)=>{\n            return value >>> 0;\n        }));\n        else this.data = new Uint32Array(1);\n    }\n    /**\n   * @returns an iterator over all set bits.\n   */ [Symbol.iterator]() {\n        const length = this.data.length;\n        let currentIndex = 0;\n        let currentWord = this.data[currentIndex];\n        const words = this.data;\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next: /* @__PURE__ */ $c1efbdb2cbf46748$var$__name(()=>{\n                while(currentIndex < length)if (currentWord !== 0) {\n                    const t = currentWord & -currentWord;\n                    const value = (currentIndex << 5) + this.bitCount(t - 1);\n                    currentWord ^= t;\n                    return {\n                        done: false,\n                        value: value\n                    };\n                } else {\n                    currentIndex++;\n                    if (currentIndex < length) currentWord = words[currentIndex];\n                }\n                return {\n                    done: true,\n                    value: void 0\n                };\n            }, \"next\")\n        };\n    }\n    /**\n   * Sets a single bit or all of the bits in this `BitSet` to `false`.\n   *\n   * @param index the index of the bit to be cleared, or undefined to clear all bits.\n   */ clear(index) {\n        if (index === void 0) this.data = new Uint32Array();\n        else {\n            this.resize(index);\n            this.data[index >>> 5] &= ~(1 << index);\n        }\n    }\n    /**\n   * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it\n   * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit\n   * set argument has the value `true`.\n   *\n   * @param set the bit set to be ORed with.\n   */ or(set) {\n        const minCount = Math.min(this.data.length, set.data.length);\n        for(let k = 0; k < minCount; ++k)this.data[k] |= set.data[k];\n        if (this.data.length < set.data.length) {\n            this.resize((set.data.length << 5) - 1);\n            const c = set.data.length;\n            for(let k = minCount; k < c; ++k)this.data[k] = set.data[k];\n        }\n    }\n    /**\n   * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`\n   * is currently set in this `BitSet`; otherwise, the result is `false`.\n   *\n   * @param index the bit index\n   *\n   * @returns the value of the bit with the specified index.\n   */ get(index) {\n        if (index < 0) throw new RangeError(\"index cannot be negative\");\n        const slot = index >>> 5;\n        if (slot >= this.data.length) return false;\n        return (this.data[slot] & 1 << index % 32) !== 0;\n    }\n    /**\n   * @returns the number of set bits.\n   */ get length() {\n        let result = 0;\n        const c = this.data.length;\n        const w = this.data;\n        for(let i = 0; i < c; i++)result += this.bitCount(w[i]);\n        return result;\n    }\n    /**\n   * @returns an array with indices of set bits.\n   */ values() {\n        const result = new Array(this.length);\n        let pos = 0;\n        const length = this.data.length;\n        for(let k = 0; k < length; ++k){\n            let w = this.data[k];\n            while(w !== 0){\n                const t = w & -w;\n                result[pos++] = (k << 5) + this.bitCount(t - 1);\n                w ^= t;\n            }\n        }\n        return result;\n    }\n    /**\n   * @returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.\n   * If no such bit exists then undefined is returned.\n   *\n   * @param fromIndex the index to start checking from (inclusive)\n   */ nextSetBit(fromIndex) {\n        if (fromIndex < 0) throw new RangeError(\"index cannot be negative\");\n        for (const index of this){\n            if (index >= fromIndex) return index;\n        }\n        return void 0;\n    }\n    /**\n   * Sets the bit at the specified index to `true`.\n   *\n   * @param index a bit index\n   */ set(index) {\n        if (index < 0) throw new RangeError(\"index cannot be negative\");\n        this.resize(index);\n        this.data[index >>> 5] |= 1 << index % 32;\n    }\n    /**\n   * @returns a string representation of this bit set.\n   */ toString() {\n        return \"{\" + this.values().join(\", \") + \"}\";\n    }\n    resize(index) {\n        const count = index + 32 >>> 5;\n        if (count <= this.data.length) return;\n        const data = new Uint32Array(count);\n        data.set(this.data);\n        data.fill(0, this.data.length);\n        this.data = data;\n    }\n    bitCount(v) {\n        v = v - (v >> 1 & 1431655765);\n        v = (v & 858993459) + (v >> 2 & 858993459);\n        v = v + (v >> 4) & 252645135;\n        v = v + (v >> 8);\n        v = v + (v >> 16);\n        return v & 63;\n    }\n};\n// src/utils/MurmurHash.ts\nvar $c1efbdb2cbf46748$var$c1 = 3432918353;\nvar $c1efbdb2cbf46748$var$c2 = 461845907;\nvar $c1efbdb2cbf46748$var$r1 = 15;\nvar $c1efbdb2cbf46748$var$r2 = 13;\nvar $c1efbdb2cbf46748$var$m = 5;\nvar $c1efbdb2cbf46748$var$n = 3864292196;\nvar $c1efbdb2cbf46748$export$27c628f6789aefe9 = class _MurmurHash {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"MurmurHash\");\n    }\n    static defaultSeed = 701;\n    constructor(){}\n    /**\n   * Initialize the hash using the specified {@code seed}.\n   *\n   * @param seed the seed\n   *\n   * @returns the intermediate hash value\n   */ static initialize(seed = _MurmurHash.defaultSeed) {\n        return seed;\n    }\n    static updateFromComparable(hash, value) {\n        return this.update(hash, value?.hashCode() ?? 0);\n    }\n    /**\n   * Update the intermediate hash value for the next input {@code value}.\n   *\n   * @param hash The intermediate hash value.\n   * @param value the value to add to the current hash.\n   *\n   * @returns the updated intermediate hash value\n   */ static update(hash, value) {\n        value = Math.imul(value, $c1efbdb2cbf46748$var$c1);\n        value = value << $c1efbdb2cbf46748$var$r1 | value >>> 32 - $c1efbdb2cbf46748$var$r1;\n        value = Math.imul(value, $c1efbdb2cbf46748$var$c2);\n        hash = hash ^ value;\n        hash = hash << $c1efbdb2cbf46748$var$r2 | hash >>> 32 - $c1efbdb2cbf46748$var$r2;\n        hash = Math.imul(hash, $c1efbdb2cbf46748$var$m) + $c1efbdb2cbf46748$var$n;\n        return hash;\n    }\n    /**\n   * Apply the final computation steps to the intermediate value {@code hash}\n   * to form the final result of the MurmurHash 3 hash function.\n   *\n   * @param hash The intermediate hash value.\n   * @param entryCount The number of values added to the hash.\n   *\n   * @returns the final hash result\n   */ static finish(hash, entryCount) {\n        hash ^= entryCount * 4;\n        hash ^= hash >>> 16;\n        hash = Math.imul(hash, 2246822507);\n        hash ^= hash >>> 13;\n        hash = Math.imul(hash, 3266489909);\n        hash ^= hash >>> 16;\n        return hash;\n    }\n    /**\n   * An all-in-one convenience method to compute a hash for a single value.\n   *\n   * @param value The value to hash.\n   * @param seed The seed for the hash value.\n   *\n   * @returns The computed hash.\n   */ static hashCode(value, seed) {\n        return _MurmurHash.finish(_MurmurHash.update(seed ?? _MurmurHash.defaultSeed, value), 1);\n    }\n};\n// src/misc/ObjectEqualityComparator.ts\nvar $c1efbdb2cbf46748$var$ObjectEqualityComparator = class _ObjectEqualityComparator {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ObjectEqualityComparator\");\n    }\n    static instance = new _ObjectEqualityComparator();\n    hashCode(obj) {\n        if (obj == null) return 0;\n        return obj.hashCode();\n    }\n    equals(a, b) {\n        if (a == null) return b == null;\n        return a.equals(b);\n    }\n};\n// src/misc/DefaultEqualityComparator.ts\nvar $c1efbdb2cbf46748$var$DefaultEqualityComparator = class _DefaultEqualityComparator {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DefaultEqualityComparator\");\n    }\n    static instance = new _DefaultEqualityComparator();\n    hashCode(obj) {\n        if (obj == null) return 0;\n        return $c1efbdb2cbf46748$var$ObjectEqualityComparator.instance.hashCode(obj);\n    }\n    equals(a, b) {\n        if (a == null) return b == null;\n        if (typeof a === \"string\" || typeof a === \"number\") return a === b;\n        return $c1efbdb2cbf46748$var$ObjectEqualityComparator.instance.equals(a, b);\n    }\n};\n// src/misc/HashSet.ts\nvar $c1efbdb2cbf46748$export$9d0bf21c11057332 = class _HashSet {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"HashSet\");\n    }\n    static defaultLoadFactor = 0.75;\n    static initialCapacity = 16;\n    // must be power of 2\n    comparator;\n    buckets;\n    threshold;\n    /** How many elements in set */ itemCount = 0;\n    constructor(comparatorOrSet, initialCapacity = _HashSet.initialCapacity){\n        if (comparatorOrSet instanceof _HashSet) {\n            this.comparator = comparatorOrSet.comparator;\n            this.buckets = comparatorOrSet.buckets.slice(0);\n            for(let i = 0; i < this.buckets.length; i++){\n                const bucket = this.buckets[i];\n                if (bucket) this.buckets[i] = bucket.slice(0);\n            }\n            this.itemCount = comparatorOrSet.itemCount;\n            this.threshold = comparatorOrSet.threshold;\n        } else {\n            this.comparator = comparatorOrSet ?? $c1efbdb2cbf46748$var$DefaultEqualityComparator.instance;\n            this.buckets = this.createBuckets(initialCapacity);\n            this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);\n        }\n    }\n    /**\n   * Add `o` to set if not there; return existing value if already\n   * there. This method performs the same operation as {@link #add} aside from\n   * the return value.\n   *\n   * @param o the object to add to the set.\n   *\n   * @returns An existing element that equals to `o` if already in set, otherwise `o`.\n   */ getOrAdd(o) {\n        if (this.itemCount > this.threshold) this.expand();\n        const b = this.getBucket(o);\n        let bucket = this.buckets[b];\n        if (!bucket) {\n            bucket = [\n                o\n            ];\n            this.buckets[b] = bucket;\n            ++this.itemCount;\n            return o;\n        }\n        for (const existing of bucket){\n            if (this.comparator.equals(existing, o)) return existing;\n        }\n        bucket.push(o);\n        ++this.itemCount;\n        return o;\n    }\n    get(o) {\n        if (o == null) return o;\n        const b = this.getBucket(o);\n        const bucket = this.buckets[b];\n        if (!bucket) return void 0;\n        for (const e of bucket){\n            if (this.comparator.equals(e, o)) return e;\n        }\n        return void 0;\n    }\n    /**\n   * Removes the specified element from this set if it is present.\n   *\n   * @param o object to be removed from this set, if present.\n   *\n   * @returns `true` if the set contained the specified element.\n   */ remove(o) {\n        if (o == null) return false;\n        const b = this.getBucket(o);\n        const bucket = this.buckets[b];\n        if (!bucket) return false;\n        for(let i = 0; i < bucket.length; i++){\n            const existing = bucket[i];\n            if (this.comparator.equals(existing, o)) {\n                bucket.splice(i, 1);\n                --this.itemCount;\n                return true;\n            }\n        }\n        return false;\n    }\n    hashCode() {\n        let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n        for (const bucket of this.buckets){\n            if (bucket == null) continue;\n            for (const o of bucket){\n                if (o == null) break;\n                hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.comparator.hashCode(o));\n            }\n        }\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, this.size);\n        return hash;\n    }\n    equals(o) {\n        if (o === this) return true;\n        if (!(o instanceof _HashSet)) return false;\n        if (o.size !== this.size) return false;\n        return this.containsAll(o);\n    }\n    add(t) {\n        const existing = this.getOrAdd(t);\n        return existing === t;\n    }\n    contains(o) {\n        return this.containsFast(o);\n    }\n    containsFast(obj) {\n        if (obj == null) return false;\n        return this.get(obj) !== void 0;\n    }\n    *[Symbol.iterator]() {\n        yield* this.toArray();\n    }\n    toArray() {\n        const a = new Array(this.size);\n        let i = 0;\n        for (const bucket of this.buckets){\n            if (bucket == null) continue;\n            for (const o of bucket){\n                if (o == null) break;\n                a[i++] = o;\n            }\n        }\n        return a;\n    }\n    containsAll(collection) {\n        if (collection instanceof _HashSet) for (const bucket of collection.buckets){\n            if (bucket == null) continue;\n            for (const o of bucket){\n                if (o == null) break;\n                if (!this.containsFast(o)) return false;\n            }\n        }\n        else for (const o of collection){\n            if (!this.containsFast(o)) return false;\n        }\n        return true;\n    }\n    addAll(c) {\n        let changed = false;\n        for (const o of c){\n            const existing = this.getOrAdd(o);\n            if (existing !== o) changed = true;\n        }\n        return changed;\n    }\n    clear() {\n        this.buckets = this.createBuckets(_HashSet.initialCapacity);\n        this.itemCount = 0;\n        this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);\n    }\n    toString() {\n        if (this.size === 0) return \"{}\";\n        let buf = \"{\";\n        let first = true;\n        for (const bucket of this.buckets){\n            if (bucket == null) continue;\n            for (const o of bucket){\n                if (o == null) break;\n                if (first) first = false;\n                else buf += \", \";\n                buf += o.toString();\n            }\n        }\n        buf += \"}\";\n        return buf;\n    }\n    toTableString() {\n        let buf = \"\";\n        for (const bucket of this.buckets){\n            if (bucket == null) {\n                buf += \"null\\n\";\n                continue;\n            }\n            buf += \"[\";\n            let first = true;\n            for (const o of bucket){\n                if (first) first = false;\n                else buf += \" \";\n                if (o == null) buf += \"_\";\n                else buf += o.toString();\n            }\n            buf += \"]\\n\";\n        }\n        return buf;\n    }\n    getBucket(o) {\n        const hash = this.comparator.hashCode(o);\n        const b = hash & this.buckets.length - 1;\n        return b;\n    }\n    expand() {\n        const old = this.buckets;\n        const newCapacity = this.buckets.length * 2;\n        const newTable = this.createBuckets(newCapacity);\n        this.buckets = newTable;\n        this.threshold = Math.floor(newCapacity * _HashSet.defaultLoadFactor);\n        for (const bucket of old){\n            if (!bucket) continue;\n            for (const o of bucket){\n                const b = this.getBucket(o);\n                let newBucket = this.buckets[b];\n                if (!newBucket) {\n                    newBucket = [];\n                    this.buckets[b] = newBucket;\n                }\n                newBucket.push(o);\n            }\n        }\n    }\n    get size() {\n        return this.itemCount;\n    }\n    get isEmpty() {\n        return this.itemCount === 0;\n    }\n    /**\n   * Return an array of `T[]` with length `capacity`.\n   *\n   * @param capacity the length of the array to return\n   * @returns the newly constructed array\n   */ createBuckets(capacity) {\n        return new Array(capacity);\n    }\n};\n// src/misc/Interval.ts\nvar $c1efbdb2cbf46748$export$e659c2681d58d45b = class _Interval {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Interval\");\n    }\n    static INVALID_INTERVAL = new _Interval(-1, -2);\n    static INTERVAL_POOL_MAX_VALUE = 1e3;\n    static cache = [];\n    start;\n    stop;\n    cachedHashCode;\n    constructor(start, stop){\n        this.start = start;\n        this.stop = stop;\n        this.cachedHashCode = Math.imul(651 + start, 31) + stop;\n    }\n    /**\n   * Creates a new interval from the given values.\n   *\n   * Interval objects are used readonly so share all with the\n   * same single value a==b up to some max size. Use an array as a perfect hash.\n   * Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new\n   * Interval object with a..a in it.  On Java.g4, 218623 IntervalSets\n   * have a..a (set with 1 element).\n   *\n   * @param a The start of the interval.\n   * @param b The end of the interval (inclusive).\n   *\n   * @returns A cached or new interval.\n   */ static of(a, b) {\n        if (a !== b || a < 0 || a > _Interval.INTERVAL_POOL_MAX_VALUE) return new _Interval(a, b);\n        if (!_Interval.cache[a]) _Interval.cache[a] = new _Interval(a, a);\n        return _Interval.cache[a];\n    }\n    equals(o) {\n        return this.start === o.start && this.stop === o.stop;\n    }\n    hashCode() {\n        return this.cachedHashCode;\n    }\n    /** Does this start completely before other? Disjoint */ startsBeforeDisjoint(other) {\n        return this.start < other.start && this.stop < other.start;\n    }\n    /** Does this start at or before other? Nondisjoint */ startsBeforeNonDisjoint(other) {\n        return this.start <= other.start && this.stop >= other.start;\n    }\n    /** Does this.start start after other.stop? May or may not be disjoint */ startsAfter(other) {\n        return this.start > other.start;\n    }\n    /** Does this start completely after other? Disjoint */ startsAfterDisjoint(other) {\n        return this.start > other.stop;\n    }\n    /** Does this start after other? NonDisjoint */ startsAfterNonDisjoint(other) {\n        return this.start > other.start && this.start <= other.stop;\n    }\n    /** Are both ranges disjoint? I.e., no overlap? */ disjoint(other) {\n        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\n    }\n    /** Are two intervals adjacent such as 0..41 and 42..42? */ adjacent(other) {\n        return this.start === other.stop + 1 || this.stop === other.start - 1;\n    }\n    properlyContains(other) {\n        return other.start >= this.start && other.stop <= this.stop;\n    }\n    /** Return the interval computed from combining this and other */ union(other) {\n        return _Interval.of(Math.min(this.start, other.start), Math.max(this.stop, other.stop));\n    }\n    /** Return the interval in common between this and o */ intersection(other) {\n        return _Interval.of(Math.max(this.start, other.start), Math.min(this.stop, other.stop));\n    }\n    /**\n   * Return the interval with elements from this not in other;\n   *  other must not be totally enclosed (properly contained)\n   *  within this, which would result in two disjoint intervals\n   *  instead of the single one returned by this method.\n   */ differenceNotProperlyContained(other) {\n        let diff = null;\n        if (other.startsBeforeNonDisjoint(this)) diff = _Interval.of(Math.max(this.start, other.stop + 1), this.stop);\n        else if (other.startsAfterNonDisjoint(this)) diff = _Interval.of(this.start, other.start - 1);\n        return diff;\n    }\n    toString() {\n        return `${this.start}..${this.stop}`;\n    }\n    get length() {\n        if (this.stop < this.start) return 0;\n        return this.stop - this.start + 1;\n    }\n};\n// src/Vocabulary.ts\nvar $c1efbdb2cbf46748$export$6fe78fc0b86aec88 = class _Vocabulary {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Vocabulary\");\n    }\n    static EMPTY_NAMES = [];\n    /**\n   * Gets an empty {@link Vocabulary} instance.\n   *\n   *\n   * No literal or symbol names are assigned to token types, so\n   * {@link #getDisplayName(int)} returns the numeric value for all tokens\n   * except {@link Token#EOF}.\n   */ static EMPTY_VOCABULARY = new _Vocabulary(_Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES);\n    maxTokenType;\n    literalNames;\n    symbolicNames;\n    displayNames;\n    /**\n   * Constructs a new instance of {@link Vocabulary} from the specified\n   * literal, symbolic, and display token names.\n   *\n   * @param literalNames The literal names assigned to tokens, or `null`\n   * if no literal names are assigned.\n   * @param symbolicNames The symbolic names assigned to tokens, or\n   * `null` if no symbolic names are assigned.\n   * @param displayNames The display names assigned to tokens, or `null`\n   * to use the values in `literalNames` and `symbolicNames` as\n   * the source of display names, as described in\n   * {@link #getDisplayName(int)}.\n   */ constructor(literalNames, symbolicNames, displayNames){\n        this.literalNames = literalNames ?? _Vocabulary.EMPTY_NAMES;\n        this.symbolicNames = symbolicNames ?? _Vocabulary.EMPTY_NAMES;\n        this.displayNames = displayNames ?? _Vocabulary.EMPTY_NAMES;\n        this.maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;\n    }\n    /**\n   * Returns a {@link Vocabulary} instance from the specified set of token\n   * names. This method acts as a compatibility layer for the single\n   * `tokenNames` array generated by previous releases of ANTLR.\n   *\n   * The resulting vocabulary instance returns `null` for\n   * {@link getLiteralName getLiteralName(int)} and {@link getSymbolicName getSymbolicName(int)}, and the\n   * value from `tokenNames` for the display names.\n   *\n   * @param tokenNames The token names, or `null` if no token names are\n   * available.\n   * @returns A {@link Vocabulary} instance which uses `tokenNames` for\n   * the display names of tokens.\n   */ static fromTokenNames(tokenNames) {\n        if (tokenNames == null || tokenNames.length === 0) return _Vocabulary.EMPTY_VOCABULARY;\n        const literalNames = [\n            ...tokenNames\n        ];\n        const symbolicNames = [\n            ...tokenNames\n        ];\n        for(let i = 0; i < tokenNames.length; i++){\n            const tokenName = tokenNames[i];\n            if (tokenName == null) continue;\n            if (tokenName.length > 0) {\n                const firstChar = tokenName.codePointAt(0);\n                if (firstChar === 39) {\n                    symbolicNames[i] = null;\n                    continue;\n                } else if (firstChar >= 65 && firstChar <= 90) {\n                    literalNames[i] = null;\n                    continue;\n                }\n            }\n            literalNames[i] = null;\n            symbolicNames[i] = null;\n        }\n        return new _Vocabulary(literalNames, symbolicNames, tokenNames);\n    }\n    getMaxTokenType() {\n        return this.maxTokenType;\n    }\n    getLiteralName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.literalNames.length) return this.literalNames[tokenType];\n        return null;\n    }\n    getSymbolicName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.symbolicNames.length) return this.symbolicNames[tokenType];\n        if (tokenType === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"EOF\";\n        return null;\n    }\n    getDisplayName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.displayNames.length) {\n            const displayName = this.displayNames[tokenType];\n            if (displayName != null) return displayName;\n        }\n        const literalName = this.getLiteralName(tokenType);\n        if (literalName != null) return literalName;\n        const symbolicName = this.getSymbolicName(tokenType);\n        if (symbolicName != null) return symbolicName;\n        return `${tokenType}`;\n    }\n    getLiteralNames() {\n        return this.literalNames;\n    }\n    getSymbolicNames() {\n        return this.symbolicNames;\n    }\n    getDisplayNames() {\n        return this.displayNames;\n    }\n};\n// src/misc/IntervalSet.ts\nvar $c1efbdb2cbf46748$export$9aa814bfdfb30f8f = class _IntervalSet {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"IntervalSet\");\n    }\n    /** The list of sorted, disjoint intervals. */ intervals = [];\n    cachedHashCode;\n    constructor(set){\n        if (set) {\n            if (Array.isArray(set)) for (const el of set)this.addOne(el);\n            else this.addSet(set);\n        }\n    }\n    /** Create a set with all ints within range [a..b] (inclusive) */ static of(a, b) {\n        const s = new _IntervalSet();\n        s.addRange(a, b);\n        return s;\n    }\n    /** Combine all sets in the array and return the union of them */ static or(sets) {\n        const result = new _IntervalSet();\n        for (const set of sets)result.addSet(set);\n        return result;\n    }\n    [Symbol.iterator]() {\n        return this.intervals[Symbol.iterator]();\n    }\n    get(index) {\n        return this.intervals[index];\n    }\n    /**\n   * Returns the minimum value contained in the set if not isNil().\n   *\n   * @returns the minimum value contained in the set.\n   */ get minElement() {\n        if (this.intervals.length === 0) return $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n        return this.intervals[0].start;\n    }\n    /**\n   * Returns the maximum value contained in the set if not isNil().\n   *\n   * @returns the maximum value contained in the set.\n   */ get maxElement() {\n        if (this.intervals.length === 0) return $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n        return this.intervals[this.intervals.length - 1].stop;\n    }\n    clear() {\n        this.cachedHashCode = void 0;\n        this.intervals = [];\n    }\n    /**\n   * Add a single element to the set.  An isolated element is stored\n   *  as a range el..el.\n   */ addOne(v) {\n        this.addInterval(new $c1efbdb2cbf46748$export$e659c2681d58d45b(v, v));\n    }\n    /**\n   * Add interval; i.e., add all integers from a to b to set.\n   *  If b < a, do nothing.\n   *  Keep list in sorted order (by left range value).\n   *  If overlap, combine ranges. For example,\n   *  If this is {1..5, 10..20}, adding 6..7 yields\n   *  {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}.\n   */ addRange(l, h) {\n        this.addInterval(new $c1efbdb2cbf46748$export$e659c2681d58d45b(l, h));\n    }\n    addInterval(addition) {\n        this.cachedHashCode = void 0;\n        if (this.intervals.length === 0) this.intervals.push(addition);\n        else {\n            for(let pos = 0; pos < this.intervals.length; pos++){\n                const existing = this.intervals[pos];\n                if (addition.equals(existing)) return;\n                if (addition.adjacent(existing) || !addition.disjoint(existing)) {\n                    const bigger = addition.union(existing);\n                    this.intervals[pos] = bigger;\n                    for(let sub = pos + 1; sub < this.intervals.length;){\n                        const next = this.intervals[sub];\n                        if (!bigger.adjacent(next) && bigger.disjoint(next)) break;\n                        this.intervals.splice(sub, 1);\n                        this.intervals[pos] = bigger.union(next);\n                    }\n                    return;\n                }\n                if (addition.startsBeforeDisjoint(existing)) {\n                    this.intervals.splice(pos, 0, addition);\n                    return;\n                }\n            }\n            this.intervals.push(addition);\n        }\n    }\n    addSet(other) {\n        other.intervals.forEach((toAdd)=>{\n            return this.addInterval(toAdd);\n        }, this);\n        return this;\n    }\n    complementWithVocabulary(vocabulary) {\n        const result = new _IntervalSet();\n        if (!vocabulary) return result;\n        if (vocabulary.length === 0) return result;\n        result.addSet(vocabulary);\n        return result.subtract(this);\n    }\n    complement(minElement, maxElement) {\n        const result = new _IntervalSet();\n        result.addInterval(new $c1efbdb2cbf46748$export$e659c2681d58d45b(minElement, maxElement));\n        return result.subtract(this);\n    }\n    /** combine all sets in the array returned the or'd value */ or(sets) {\n        const result = new _IntervalSet();\n        result.addSet(this);\n        sets.forEach((set)=>{\n            return result.addSet(set);\n        });\n        return result;\n    }\n    and(other) {\n        if (other.length === 0) return new _IntervalSet();\n        const myIntervals = this.intervals;\n        const theirIntervals = other.intervals;\n        let intersection;\n        const mySize = myIntervals.length;\n        const theirSize = theirIntervals.length;\n        let i = 0;\n        let j = 0;\n        while(i < mySize && j < theirSize){\n            const mine = myIntervals[i];\n            const theirs = theirIntervals[j];\n            if (mine.startsBeforeDisjoint(theirs)) i++;\n            else if (theirs.startsBeforeDisjoint(mine)) j++;\n            else if (mine.properlyContains(theirs)) {\n                if (!intersection) intersection = new _IntervalSet();\n                intersection.addInterval(mine.intersection(theirs));\n                j++;\n            } else if (theirs.properlyContains(mine)) {\n                if (!intersection) intersection = new _IntervalSet();\n                intersection.addInterval(mine.intersection(theirs));\n                i++;\n            } else if (!mine.disjoint(theirs)) {\n                if (!intersection) intersection = new _IntervalSet();\n                intersection.addInterval(mine.intersection(theirs));\n                if (mine.startsAfterNonDisjoint(theirs)) j++;\n                else if (theirs.startsAfterNonDisjoint(mine)) i++;\n            }\n        }\n        if (!intersection) return new _IntervalSet();\n        return intersection;\n    }\n    /**\n   * Compute the set difference between two interval sets. The specific\n   * operation is `left - right`. If either of the input sets is\n   * `null`, it is treated as though it was an empty set.\n   */ subtract(other) {\n        if (this.length === 0) return new _IntervalSet();\n        const result = new _IntervalSet(this);\n        if (other.length === 0) return result;\n        let resultI = 0;\n        let rightI = 0;\n        while(resultI < result.intervals.length && rightI < other.intervals.length){\n            const resultInterval = result.intervals[resultI];\n            const rightInterval = other.intervals[rightI];\n            if (rightInterval.stop < resultInterval.start) {\n                rightI++;\n                continue;\n            }\n            if (rightInterval.start > resultInterval.stop) {\n                resultI++;\n                continue;\n            }\n            let beforeCurrent;\n            let afterCurrent;\n            if (rightInterval.start > resultInterval.start) beforeCurrent = new $c1efbdb2cbf46748$export$e659c2681d58d45b(resultInterval.start, rightInterval.start - 1);\n            if (rightInterval.stop < resultInterval.stop) afterCurrent = new $c1efbdb2cbf46748$export$e659c2681d58d45b(rightInterval.stop + 1, resultInterval.stop);\n            if (beforeCurrent) {\n                if (afterCurrent) {\n                    result.intervals[resultI] = beforeCurrent;\n                    result.intervals.splice(resultI + 1, 0, afterCurrent);\n                    resultI++;\n                    rightI++;\n                } else {\n                    result.intervals[resultI] = beforeCurrent;\n                    resultI++;\n                }\n            } else if (afterCurrent) {\n                result.intervals[resultI] = afterCurrent;\n                rightI++;\n            } else result.intervals.splice(resultI, 1);\n        }\n        return result;\n    }\n    contains(el) {\n        const n2 = this.intervals.length;\n        let l = 0;\n        let r = n2 - 1;\n        while(l <= r){\n            const m2 = Math.floor((l + r) / 2);\n            const interval = this.intervals[m2];\n            if (interval.stop < el) l = m2 + 1;\n            else if (interval.start > el) r = m2 - 1;\n            else return true;\n        }\n        return false;\n    }\n    removeRange(toRemove) {\n        this.cachedHashCode = void 0;\n        if (toRemove.start === toRemove.stop) this.removeOne(toRemove.start);\n        else if (this.intervals !== null) {\n            let pos = 0;\n            for (const existing of this.intervals){\n                if (toRemove.stop <= existing.start) return;\n                else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {\n                    this.intervals[pos] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(existing.start, toRemove.start);\n                    const x = new $c1efbdb2cbf46748$export$e659c2681d58d45b(toRemove.stop, existing.stop);\n                    this.intervals.splice(pos, 0, x);\n                    return;\n                } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {\n                    this.intervals.splice(pos, 1);\n                    pos = pos - 1;\n                } else if (toRemove.start < existing.stop) this.intervals[pos] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(existing.start, toRemove.start);\n                else if (toRemove.stop < existing.stop) this.intervals[pos] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(toRemove.stop, existing.stop);\n                pos += 1;\n            }\n        }\n    }\n    removeOne(value) {\n        this.cachedHashCode = void 0;\n        for(let i = 0; i < this.intervals.length; i++){\n            const existing = this.intervals[i];\n            if (value < existing.start) return;\n            else if (value === existing.start && value === existing.stop) {\n                this.intervals.splice(i, 1);\n                return;\n            } else if (value === existing.start) {\n                this.intervals[i] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(existing.start + 1, existing.stop);\n                return;\n            } else if (value === existing.stop) {\n                this.intervals[i] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(existing.start, existing.stop - 1);\n                return;\n            } else if (value < existing.stop) {\n                const replace = new $c1efbdb2cbf46748$export$e659c2681d58d45b(existing.start, value - 1);\n                this.intervals[i] = new $c1efbdb2cbf46748$export$e659c2681d58d45b(value + 1, existing.stop);\n                this.intervals.splice(i, 0, replace);\n                return;\n            }\n        }\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            for (const interval of this.intervals){\n                hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, interval.start);\n                hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, interval.stop);\n            }\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, this.intervals.length * 2);\n        }\n        return this.cachedHashCode;\n    }\n    /**\n   * Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over\n   * both lists to make sure they are the same. Interval.equals() is used by the List.equals() method to check\n   * the ranges.\n   */ equals(other) {\n        if (this === other) return true;\n        if (this.intervals.length !== other.intervals.length) return false;\n        for(let i = 0; i < this.intervals.length; i++){\n            if (!this.intervals[i].equals(other.intervals[i])) return false;\n        }\n        return true;\n    }\n    toString(elementsAreChar) {\n        if (this.intervals.length === 0) return \"{}\";\n        let result = \"\";\n        if (this.length > 1) result += \"{\";\n        for(let i = 0; i < this.intervals.length; ++i){\n            const interval = this.intervals[i];\n            const start = interval.start;\n            const stop = interval.stop;\n            if (start === stop) {\n                if (start === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) result += \"<EOF>\";\n                else if (elementsAreChar) result += \"'\" + String.fromCodePoint(start) + \"'\";\n                else result += start;\n            } else if (elementsAreChar) result += \"'\" + String.fromCodePoint(start) + \"'..'\" + String.fromCodePoint(stop) + \"'\";\n            else result += start + \"..\" + stop;\n            if (i < this.intervals.length - 1) result += \", \";\n        }\n        if (this.length > 1) result += \"}\";\n        return result;\n    }\n    toStringWithVocabulary(vocabulary) {\n        if (this.intervals.length === 0) return \"{}\";\n        let result = \"\";\n        if (this.length > 1) result += \"{\";\n        for(let i = 0; i < this.intervals.length; ++i){\n            const interval = this.intervals[i];\n            const start = interval.start;\n            const stop = interval.stop;\n            if (start === stop) {\n                if (start === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) result += \"<EOF>\";\n                else result += this.elementName(vocabulary, start);\n            } else for(let i2 = start; i2 <= stop; ++i2){\n                if (i2 > start) result += \", \";\n                result += this.elementName(vocabulary, i2);\n            }\n            if (i < this.intervals.length - 1) result += \", \";\n        }\n        if (this.length > 1) result += \"}\";\n        return result;\n    }\n    toStringWithRuleNames(ruleNames) {\n        if (this.intervals.length === 0) return \"{}\";\n        let result = \"\";\n        if (this.length > 1) result += \"{\";\n        const vocabulary = $c1efbdb2cbf46748$export$6fe78fc0b86aec88.fromTokenNames(ruleNames);\n        for(let i = 0; i < this.intervals.length; ++i){\n            const interval = this.intervals[i];\n            const start = interval.start;\n            const stop = interval.stop;\n            if (start === stop) {\n                if (start === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) result += \"<EOF>\";\n                else result += this.elementName(vocabulary, start);\n            } else for(let i2 = start; i2 <= stop; ++i2){\n                if (i2 > start) result += \", \";\n                result += this.elementName(vocabulary, i2);\n            }\n            if (i < this.intervals.length - 1) result += \", \";\n        }\n        if (this.length > 1) result += \"}\";\n        return result;\n    }\n    toArray() {\n        const data = [];\n        for (const interval of this.intervals)for(let j = interval.start; j <= interval.stop; j++)data.push(j);\n        return data;\n    }\n    /** @returns the number of elements in this set. */ get length() {\n        let result = 0;\n        for (const interval of this.intervals)result += interval.length;\n        return result;\n    }\n    elementName(vocabulary, token) {\n        if (token === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"<EOF>\";\n        if (token === $c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON) return \"<EPSILON>\";\n        return vocabulary.getDisplayName(token);\n    }\n};\n// src/utils/helpers.ts\nvar $c1efbdb2cbf46748$export$a8eb308fbdcb0e9c = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((candidate)=>{\n    return typeof candidate.equals === \"function\";\n}, \"isComparable\");\nvar $c1efbdb2cbf46748$var$valueToString = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((v)=>{\n    return v === null ? \"null\" : v;\n}, \"valueToString\");\nvar $c1efbdb2cbf46748$export$4323cc4280d5be7 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((value)=>{\n    return Array.isArray(value) ? \"[\" + value.map($c1efbdb2cbf46748$var$valueToString).join(\", \") + \"]\" : \"null\";\n}, \"arrayToString\");\nvar $c1efbdb2cbf46748$export$dc63f52ecf814bf8 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b)=>{\n    if (a === b) return true;\n    if (a.length !== b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        const left = a[i];\n        const right = b[i];\n        if (left === right) continue;\n        if (!left || !left.equals(right)) return false;\n    }\n    return true;\n}, \"equalArrays\");\nvar $c1efbdb2cbf46748$export$edfd5757e80058f3 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b)=>{\n    if (a === b) return true;\n    if (a.length !== b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}, \"equalNumberArrays\");\nvar $c1efbdb2cbf46748$export$221fb4e78e2caf9d = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((s, escapeSpaces = false)=>{\n    s = s.replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) s = s.replace(/ /g, \"\\xB7\");\n    return s;\n}, \"escapeWhitespace\");\n// src/atn/SemanticContext.ts\nvar $c1efbdb2cbf46748$export$946e3ad1112f0fcb = class _SemanticContext {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"SemanticContext\");\n    }\n    cachedHashCode;\n    static andContext(a, b) {\n        if (a === null || a === _SemanticContext.NONE) return b;\n        if (b === null || b === _SemanticContext.NONE) return a;\n        const result = new $c1efbdb2cbf46748$var$AND(a, b);\n        if (result.operands.length === 1) return result.operands[0];\n        return result;\n    }\n    static orContext(a, b) {\n        if (a === null) return b;\n        if (b === null) return a;\n        if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) return _SemanticContext.NONE;\n        const result = new $c1efbdb2cbf46748$var$OR(a, b);\n        if (result.operands.length === 1) return result.operands[0];\n        else return result;\n    }\n    static filterPrecedencePredicates(set) {\n        const result = [];\n        for (const context of set)if (context instanceof _SemanticContext.PrecedencePredicate) result.push(context);\n        return result;\n    }\n    /**\n   * Evaluate the precedence predicates for the context and reduce the result.\n   *\n   * @param _parser The parser instance.\n   * @param _parserCallStack The current parser context object.\n   * @returns The simplified semantic context after precedence predicates are\n   * evaluated, which will be one of the following values.\n   * - {@link NONE}: if the predicate simplifies to `true` after\n   * precedence predicates are evaluated.\n   * - `null`: if the predicate simplifies to `false` after\n   * precedence predicates are evaluated.\n   * - `this`: if the semantic context is not changed as a result of\n   * precedence predicate evaluation.\n   * - A non-`null` {@link SemanticContext}: the new simplified\n   * semantic context after precedence predicates are evaluated.\n   */ evalPrecedence(_parser, _parserCallStack) {\n        return this;\n    }\n};\nvar $c1efbdb2cbf46748$var$AND = class _AND extends $c1efbdb2cbf46748$export$946e3ad1112f0fcb {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"AND\");\n    }\n    operands;\n    /**\n   * A semantic context which is true whenever none of the contained contexts\n   * is false\n   */ constructor(a, b){\n        super();\n        const operands = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n        if (a instanceof _AND) a.operands.forEach((o)=>{\n            operands.add(o);\n        });\n        else operands.add(a);\n        if (b instanceof _AND) b.operands.forEach((o)=>{\n            operands.add(o);\n        });\n        else operands.add(b);\n        const precedencePredicates = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.filterPrecedencePredicates(operands);\n        if (precedencePredicates.length > 0) {\n            let reduced = null;\n            precedencePredicates.forEach((p)=>{\n                if (reduced === null || p.precedence < reduced.precedence) reduced = p;\n            });\n            if (reduced) operands.add(reduced);\n        }\n        this.operands = operands.toArray();\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _AND)) return false;\n        return $c1efbdb2cbf46748$export$dc63f52ecf814bf8(this.operands, other.operands);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            for (const operand of this.operands)hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hash, operand);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, 3813686060);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, this.operands.length + 1);\n        }\n        return this.cachedHashCode;\n    }\n    /**\n   * {@inheritDoc}\n   *\n   *\n   * The evaluation of predicates by this context is short-circuiting, but\n   * unordered.\n   */ evaluate(parser, parserCallStack) {\n        for (const operand of this.operands){\n            if (!operand.evaluate(parser, parserCallStack)) return false;\n        }\n        return true;\n    }\n    evalPrecedence(parser, parserCallStack) {\n        let differs = false;\n        const operands = [];\n        for (const context of this.operands){\n            const evaluated = context.evalPrecedence(parser, parserCallStack);\n            differs ||= evaluated !== context;\n            if (evaluated === null) return null;\n            else if (evaluated !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) operands.push(evaluated);\n        }\n        if (!differs) return this;\n        if (operands.length === 0) return $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE;\n        let result = null;\n        operands.forEach((o)=>{\n            result = result === null ? o : $c1efbdb2cbf46748$export$946e3ad1112f0fcb.andContext(result, o);\n        });\n        return result;\n    }\n    toString() {\n        const s = this.operands.map((o)=>{\n            return o.toString();\n        });\n        return (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n    }\n};\nvar $c1efbdb2cbf46748$var$OR = class _OR extends $c1efbdb2cbf46748$export$946e3ad1112f0fcb {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"OR\");\n    }\n    operands;\n    /**\n   * A semantic context which is true whenever at least one of the contained\n   * contexts is true\n   */ constructor(a, b){\n        super();\n        const operands = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n        if (a instanceof _OR) a.operands.forEach((o)=>{\n            operands.add(o);\n        });\n        else operands.add(a);\n        if (b instanceof _OR) b.operands.forEach((o)=>{\n            operands.add(o);\n        });\n        else operands.add(b);\n        const precedencePredicates = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.filterPrecedencePredicates(operands);\n        if (precedencePredicates.length > 0) {\n            const s = precedencePredicates.sort((a2, b2)=>{\n                return a2.compareTo(b2);\n            });\n            const reduced = s[s.length - 1];\n            operands.add(reduced);\n        }\n        this.operands = operands.toArray();\n    }\n    equals(other) {\n        if (this === other) return true;\n        else if (!(other instanceof _OR)) return false;\n        else return $c1efbdb2cbf46748$export$dc63f52ecf814bf8(this.operands, other.operands);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            for (const operand of this.operands)hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hash, operand);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, 3383313031);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, this.operands.length + 1);\n        }\n        return this.cachedHashCode;\n    }\n    /**\n   * The evaluation of predicates by this context is short-circuiting, but unordered.\n   */ evaluate(parser, parserCallStack) {\n        for (const operand of this.operands){\n            if (operand.evaluate(parser, parserCallStack)) return true;\n        }\n        return false;\n    }\n    evalPrecedence(parser, parserCallStack) {\n        let differs = false;\n        const operands = [];\n        for (const context of this.operands){\n            const evaluated = context.evalPrecedence(parser, parserCallStack);\n            differs ||= evaluated !== context;\n            if (evaluated === $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) return $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE;\n            else if (evaluated !== null) operands.push(evaluated);\n        }\n        if (!differs) return this;\n        if (operands.length === 0) return null;\n        let result = null;\n        operands.forEach((o)=>{\n            result = result === null ? o : $c1efbdb2cbf46748$export$946e3ad1112f0fcb.orContext(result, o);\n        });\n        return result;\n    }\n    toString() {\n        const s = this.operands.map((o)=>{\n            return o.toString();\n        });\n        return (s.length > 3 ? s.slice(3) : s).join(\"||\");\n    }\n};\n((SemanticContext2)=>{\n    class Predicate extends SemanticContext2 {\n        static{\n            $c1efbdb2cbf46748$var$__name(this, \"Predicate\");\n        }\n        ruleIndex;\n        predIndex;\n        isCtxDependent;\n        // e.g., $i ref in pred\n        constructor(ruleIndex, predIndex, isCtxDependent){\n            super();\n            this.ruleIndex = ruleIndex ?? -1;\n            this.predIndex = predIndex ?? -1;\n            this.isCtxDependent = isCtxDependent ?? false;\n        }\n        evaluate(parser, outerContext) {\n            const localctx = this.isCtxDependent ? outerContext : null;\n            return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n        }\n        hashCode() {\n            if (this.cachedHashCode === void 0) {\n                let hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n                hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.ruleIndex);\n                hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.predIndex);\n                hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.isCtxDependent ? 1 : 0);\n                hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hashCode, 3);\n                this.cachedHashCode = hashCode;\n            }\n            return this.cachedHashCode;\n        }\n        equals(other) {\n            if (this === other) return true;\n            return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;\n        }\n        toString() {\n            return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n        }\n    }\n    SemanticContext2.Predicate = Predicate;\n    class PrecedencePredicate extends SemanticContext2 {\n        static{\n            $c1efbdb2cbf46748$var$__name(this, \"PrecedencePredicate\");\n        }\n        precedence;\n        constructor(precedence){\n            super();\n            this.precedence = precedence ?? 0;\n        }\n        evaluate(parser, outerContext) {\n            return parser.precpred(outerContext, this.precedence);\n        }\n        evalPrecedence(parser, outerContext) {\n            if (parser.precpred(outerContext ?? null, this.precedence)) return SemanticContext2.NONE;\n            return null;\n        }\n        compareTo(other) {\n            return this.precedence - other.precedence;\n        }\n        hashCode() {\n            return 31 + this.precedence;\n        }\n        equals(other) {\n            if (this === other) return true;\n            return this.precedence === other.precedence;\n        }\n        toString() {\n            return \"{\" + this.precedence + \">=prec}?\";\n        }\n    }\n    SemanticContext2.PrecedencePredicate = PrecedencePredicate;\n    SemanticContext2.NONE = new Predicate();\n})($c1efbdb2cbf46748$export$946e3ad1112f0fcb || ($c1efbdb2cbf46748$export$946e3ad1112f0fcb = {}));\n// src/atn/ATNConfig.ts\nvar $c1efbdb2cbf46748$export$b371505ec63d1c9b = class _ATNConfig {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNConfig\");\n    }\n    /** The ATN state associated with this configuration */ state;\n    /** What alt (or lexer rule) is predicted by this configuration */ alt;\n    /**\n   * We cannot execute predicates dependent upon local context unless\n   * we know for sure we are in the correct context. Because there is\n   * no way to do this efficiently, we simply cannot evaluate\n   * dependent predicates unless we are in the rule that initially\n   * invokes the ATN simulator.\n   *\n   * closure() tracks the depth of how far we dip into the outer context:\n   * depth > 0.\n   */ reachesIntoOuterContext = false;\n    // Not used in hash code.\n    precedenceFilterSuppressed = false;\n    // Not used in hash code.\n    get semanticContext() {\n        return this.#semanticContext;\n    }\n    cachedHashCode;\n    // Shared with LexerATNConfig.\n    /**\n   * The syntactic context is a graph-structured stack node whose\n   * path(s) to the root is the rule invocation(s)\n   * chain used to arrive at the state.  The semantic context is\n   * the tree of semantic predicates encountered before reaching\n   * an ATN state\n   */ #context = null;\n    #semanticContext;\n    /** Never create config classes directly. Use the factory methods below. */ constructor(c, state, context, semanticContext){\n        this.state = state;\n        this.alt = c.alt;\n        this.context = context;\n        this.#semanticContext = semanticContext ?? $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE;\n        this.reachesIntoOuterContext = c.reachesIntoOuterContext;\n        if (c.precedenceFilterSuppressed !== void 0) this.precedenceFilterSuppressed = c.precedenceFilterSuppressed;\n    }\n    static duplicate(old, semanticContext) {\n        return new _ATNConfig(old, old.state, old.context, semanticContext ?? old.semanticContext);\n    }\n    static createWithContext(state, alt, context, semanticContext) {\n        return new _ATNConfig({\n            alt: alt\n        }, state, context, semanticContext);\n    }\n    static createWithConfig(state, config, context) {\n        return new _ATNConfig(config, state, context ?? config.context, config.semanticContext);\n    }\n    static createWithSemanticContext(state, c, semanticContext) {\n        return new _ATNConfig(c, state ?? c.state, c.context, semanticContext);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(7);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.state.stateNumber);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.alt);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, this.#context);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, this.semanticContext);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hashCode, 4);\n            this.cachedHashCode = hashCode;\n        }\n        return this.cachedHashCode;\n    }\n    /**\n   * The stack of invoking states leading to the rule/states associated\n   * with this config.  We track only those contexts pushed during\n   * execution of the ATN simulator.\n   */ get context() {\n        return this.#context;\n    }\n    set context(context) {\n        this.#context = context;\n        this.cachedHashCode = void 0;\n    }\n    /**\n   * An ATN configuration is equal to another if both have\n   * the same state, they predict the same alternative, and\n   * syntactic/semantic contexts are the same.\n   */ equals(other) {\n        if (this === other) return true;\n        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;\n    }\n    toString(_recog, showAlt = true) {\n        let alt = \"\";\n        if (showAlt) alt = \",\" + this.alt;\n        return \"(\" + this.state + alt + (this.context !== null ? \",[\" + this.context.toString() + \"]\" : \"\") + (this.semanticContext !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE ? \",\" + this.semanticContext.toString() : \"\") + (this.reachesIntoOuterContext ? \",up=\" + this.reachesIntoOuterContext : \"\") + \")\";\n    }\n};\n// src/atn/ATNState.ts\nvar $c1efbdb2cbf46748$export$21a6260de0fddd55 = class _ATNState {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNState\");\n    }\n    static INVALID_STATE_NUMBER = -1;\n    static INVALID_TYPE = 0;\n    static BASIC = 1;\n    static RULE_START = 2;\n    static BLOCK_START = 3;\n    static PLUS_BLOCK_START = 4;\n    static STAR_BLOCK_START = 5;\n    static TOKEN_START = 6;\n    static RULE_STOP = 7;\n    static BLOCK_END = 8;\n    static STAR_LOOP_BACK = 9;\n    static STAR_LOOP_ENTRY = 10;\n    static PLUS_LOOP_BACK = 11;\n    static LOOP_END = 12;\n    static stateType = _ATNState.INVALID_STATE_NUMBER;\n    stateNumber = 0;\n    ruleIndex = 0;\n    // at runtime, we don't have Rule objects\n    epsilonOnlyTransitions = false;\n    /** Used to cache lookahead during parsing, not used during construction */ nextTokenWithinRule;\n    /** Track the transitions emanating from this ATN state. */ transitions = [];\n    hashCode() {\n        return this.stateNumber;\n    }\n    equals(other) {\n        return this.stateNumber === other.stateNumber;\n    }\n    toString() {\n        return `${this.stateNumber}`;\n    }\n    addTransitionAtIndex(index, transition) {\n        if (this.transitions.length === 0) this.epsilonOnlyTransitions = transition.isEpsilon;\n        else if (this.epsilonOnlyTransitions !== transition.isEpsilon) this.epsilonOnlyTransitions = false;\n        this.transitions.splice(index, 0, transition);\n    }\n    addTransition(transition) {\n        if (this.transitions.length === 0) this.epsilonOnlyTransitions = transition.isEpsilon;\n        else if (this.epsilonOnlyTransitions !== transition.isEpsilon) this.epsilonOnlyTransitions = false;\n        this.transitions.push(transition);\n    }\n    setTransition(i, e) {\n        this.transitions.splice(i, 1, e);\n    }\n    removeTransition(index) {\n        const t = this.transitions.splice(index, 1);\n        return t[0];\n    }\n};\n// src/atn/PredictionContext.ts\nvar $c1efbdb2cbf46748$export$95ea21db2ed34266 = class _PredictionContext {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PredictionContext\");\n    }\n    /**\n   * Represents `$` in an array in full context mode, when `$`\n   * doesn't mean wildcard: `$ + x = [$,x]`. Here,\n   * `$` = {@link EMPTY_RETURN_STATE}.\n   */ static EMPTY_RETURN_STATE = 2147483647;\n    static traceATNSimulator = false;\n    cachedHashCode;\n    constructor(cachedHashCode){\n        this.cachedHashCode = cachedHashCode;\n    }\n    static calculateEmptyHashCode() {\n        let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(31);\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 0);\n        return hash;\n    }\n    static calculateHashCodeSingle(parent, returnState) {\n        let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(31);\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hash, parent);\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, returnState);\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        return hash;\n    }\n    static calculateHashCodeList(parents, returnStates) {\n        let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(31);\n        for (const parent of parents)hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hash, parent);\n        for (const returnState of returnStates)hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, returnState);\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2 * parents.length);\n        return hash;\n    }\n    isEmpty() {\n        return false;\n    }\n    hasEmptyPath() {\n        return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;\n    }\n    hashCode() {\n        return this.cachedHashCode;\n    }\n    toString(_recog) {\n        return \"\";\n    }\n};\n// src/atn/SingletonPredictionContext.ts\nvar $c1efbdb2cbf46748$export$d50bfe6c4685d25b = class _SingletonPredictionContext extends $c1efbdb2cbf46748$export$95ea21db2ed34266 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"SingletonPredictionContext\");\n    }\n    parent;\n    returnState;\n    constructor(parent, returnState){\n        super(parent ? $c1efbdb2cbf46748$export$95ea21db2ed34266.calculateHashCodeSingle(parent, returnState) : $c1efbdb2cbf46748$export$95ea21db2ed34266.calculateEmptyHashCode());\n        this.parent = parent ?? null;\n        this.returnState = returnState;\n    }\n    getParent(_index) {\n        return this.parent;\n    }\n    getReturnState(_index) {\n        return this.returnState;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _SingletonPredictionContext)) return false;\n        if (this.hashCode() !== other.hashCode()) return false;\n        if (this.returnState !== other.returnState) return false;\n        if (this.parent == null) return other.parent == null;\n        return this.parent.equals(other.parent);\n    }\n    toString() {\n        const up = this.parent === null ? \"\" : this.parent.toString();\n        if (up.length === 0) {\n            if (this.returnState === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE) return \"$\";\n            return \"\" + this.returnState;\n        } else return \"\" + this.returnState + \" \" + up;\n    }\n    get length() {\n        return 1;\n    }\n};\n// src/atn/EmptyPredictionContext.ts\nvar $c1efbdb2cbf46748$export$179fd11580abda9d = class _EmptyPredictionContext extends $c1efbdb2cbf46748$export$d50bfe6c4685d25b {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"EmptyPredictionContext\");\n    }\n    /**\n   * Represents `$` in local context prediction, which means wildcard.\n   * `*+x = *`.\n   */ static instance = new _EmptyPredictionContext();\n    constructor(){\n        super(void 0, $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE);\n    }\n    isEmpty() {\n        return true;\n    }\n    getParent() {\n        return null;\n    }\n    getReturnState() {\n        return this.returnState;\n    }\n    equals(other) {\n        return this === other;\n    }\n    toString() {\n        return \"$\";\n    }\n};\n// src/atn/Transition.ts\nvar $c1efbdb2cbf46748$export$be58926105124dd4 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Transition\");\n    }\n    static INVALID = 0;\n    static EPSILON = 1;\n    static RANGE = 2;\n    static RULE = 3;\n    static PREDICATE = 4;\n    // e.g., {isType(input.LT(1))}\n    static ATOM = 5;\n    static ACTION = 6;\n    static SET = 7;\n    // ~(A|B) or ~atom, wildcard, which convert to next\n    static NOT_SET = 8;\n    static WILDCARD = 9;\n    static PRECEDENCE = 10;\n    /** The target of this transition. */ target;\n    constructor(target){\n        this.target = target;\n    }\n    /**\n   * Determines if the transition is an \"epsilon\" transition.\n   *\n   * The default implementation returns `false`.\n   *\n   * @returns `true` if traversing this transition in the ATN does not\n   * consume an input symbol; otherwise, `false` if traversing this\n   * transition consumes (matches) an input symbol.\n   */ get isEpsilon() {\n        return false;\n    }\n    get label() {\n        return null;\n    }\n    toString() {\n        return \"\";\n    }\n};\n// src/atn/SetTransition.ts\nvar $c1efbdb2cbf46748$export$10de5c396f79e800 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"SetTransition\");\n    }\n    set;\n    constructor(target, set){\n        super(target);\n        if (set) this.set = set;\n        else this.set = $c1efbdb2cbf46748$export$9aa814bfdfb30f8f.of($c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE, $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE);\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.SET;\n    }\n    get label() {\n        return this.set;\n    }\n    matches(symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return this.set.contains(symbol);\n    }\n    toString() {\n        return this.set.toString();\n    }\n};\n// src/atn/NotSetTransition.ts\nvar $c1efbdb2cbf46748$export$a0e4d5a57a08628e = class extends $c1efbdb2cbf46748$export$10de5c396f79e800 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"NotSetTransition\");\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.NOT_SET;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n    toString() {\n        return \"~\" + super.toString();\n    }\n};\n// src/misc/MapKeyEqualityOperator.ts\nvar $c1efbdb2cbf46748$var$MapKeyEqualityComparator = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"MapKeyEqualityComparator\");\n    }\n    keyComparator;\n    constructor(keyComparator){\n        this.keyComparator = keyComparator;\n    }\n    hashCode(obj) {\n        return this.keyComparator.hashCode(obj.key);\n    }\n    equals(a, b) {\n        return this.keyComparator.equals(a.key, b.key);\n    }\n};\n// src/misc/HashMap.ts\nvar $c1efbdb2cbf46748$export$60ef0b43d585640a = class _HashMap {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"HashMap\");\n    }\n    backingStore;\n    constructor(keyComparer){\n        if (keyComparer instanceof _HashMap) this.backingStore = new $c1efbdb2cbf46748$export$9d0bf21c11057332(keyComparer.backingStore);\n        else {\n            keyComparer = keyComparer ?? $c1efbdb2cbf46748$var$DefaultEqualityComparator.instance;\n            this.backingStore = new $c1efbdb2cbf46748$export$9d0bf21c11057332(new $c1efbdb2cbf46748$var$MapKeyEqualityComparator(keyComparer));\n        }\n    }\n    clear() {\n        this.backingStore.clear();\n    }\n    containsKey(key) {\n        return this.backingStore.contains({\n            key: key\n        });\n    }\n    get(key) {\n        const bucket = this.backingStore.get({\n            key: key\n        });\n        if (!bucket) return void 0;\n        return bucket.value;\n    }\n    get isEmpty() {\n        return this.backingStore.isEmpty;\n    }\n    /**\n   * Sets the value for a key in the map. If the key is not present in the map, it is added.\n   * If the key is present, the value is updated and the old value is returned.\n   *\n   * @param key The key to set.\n   * @param value The value to set.\n   *\n   * @returns The old value for the key, if present.\n   */ set(key, value) {\n        const element = this.backingStore.get({\n            key: key,\n            value: value\n        });\n        let result;\n        if (!element) this.backingStore.add({\n            key: key,\n            value: value\n        });\n        else {\n            result = element.value;\n            element.value = value;\n        }\n        return result;\n    }\n    /**\n   * Sets the value for a key in the map if the key is not already present. Otherwise the value is not changed and\n   * the old value is returned.\n   *\n   * @param key The key to set.\n   * @param value The value to set.\n   *\n   * @returns The current value for the key, if present.\n   */ setIfAbsent(key, value) {\n        const element = this.backingStore.get({\n            key: key,\n            value: value\n        });\n        let result;\n        if (!element) this.backingStore.add({\n            key: key,\n            value: value\n        });\n        else result = element.value;\n        return result;\n    }\n    keys() {\n        return this.backingStore.toArray().map((bucket)=>{\n            return bucket.key;\n        });\n    }\n    values() {\n        return this.backingStore.toArray().map((bucket)=>{\n            return bucket.value;\n        });\n    }\n    get size() {\n        return this.backingStore.size;\n    }\n    hashCode() {\n        return this.backingStore.hashCode();\n    }\n    equals(o) {\n        return this.backingStore.equals(o.backingStore);\n    }\n};\n// src/tree/TerminalNode.ts\nvar $c1efbdb2cbf46748$export$f6a002739fa43001 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TerminalNode\");\n    }\n    parent = null;\n    symbol;\n    constructor(symbol){\n        this.symbol = symbol;\n    }\n    getChild(_i) {\n        return null;\n    }\n    getSymbol() {\n        return this.symbol;\n    }\n    getPayload() {\n        return this.symbol;\n    }\n    getSourceInterval() {\n        if (this.symbol === null) return $c1efbdb2cbf46748$export$e659c2681d58d45b.INVALID_INTERVAL;\n        const tokenIndex = this.symbol.tokenIndex;\n        return new $c1efbdb2cbf46748$export$e659c2681d58d45b(tokenIndex, tokenIndex);\n    }\n    getChildCount() {\n        return 0;\n    }\n    accept(visitor) {\n        return visitor.visitTerminal(this);\n    }\n    getText() {\n        return this.symbol?.text ?? \"\";\n    }\n    toString() {\n        if (this.symbol?.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"<EOF>\";\n        else return this.symbol?.text ?? \"\";\n    }\n    toStringTree() {\n        return this.toString();\n    }\n};\n// src/tree/ErrorNode.ts\nvar $c1efbdb2cbf46748$export$d3ee467d32253151 = class extends $c1efbdb2cbf46748$export$f6a002739fa43001 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ErrorNode\");\n    }\n    accept(visitor) {\n        return visitor.visitErrorNode(this);\n    }\n};\n// src/CommonToken.ts\nvar $c1efbdb2cbf46748$export$c9b1d0b06becfda3 = class _CommonToken {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CommonToken\");\n    }\n    /**\n   * An empty tuple which is used as the default value of\n   * {@link source} for tokens that do not have a source.\n   */ // eslint-disable-next-line @typescript-eslint/naming-convention\n    static EMPTY_SOURCE = [\n        null,\n        null\n    ];\n    /**\n   * These properties share a field to reduce the memory footprint of\n   * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from\n   * the same source and input stream share a reference to the same\n   * {@link Pair} containing these values.\n   */ source;\n    tokenIndex;\n    start;\n    stop;\n    /**\n   * This is the backing field for {@link #getType} and {@link #setType}.\n   */ type;\n    /**\n   * The (one-based) line number on which the 1st character of this token was.\n   */ line;\n    /**\n   * The zero-based index of the first character position in its line.\n   */ column;\n    /**\n   * The token's channel.\n   */ channel;\n    /**\n   * This is the backing field for {@link getText} when the token text is\n   * explicitly set in the constructor or via {@link setText}.\n   */ #text;\n    constructor(details){\n        this.type = details.type;\n        this.source = details.source;\n        this.tokenIndex = details.tokenIndex ?? -1;\n        this.line = details.line ?? 0;\n        this.column = details.column ?? -1;\n        this.channel = details.channel ?? $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n        this.start = details.start ?? 0;\n        this.stop = details.stop ?? 0;\n        this.#text = details.text;\n        if (details.line === void 0 && details.source[0] !== null) this.line = details.source[0].line;\n        if (details.column === void 0 && details.source[0] !== null) this.column = details.source[0].column;\n    }\n    /**\n   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n   *\n   * If `token` is also a {@link CommonToken} instance, the newly\n   * constructed token will share a reference to the {@link #text} field and\n   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will\n   * be assigned the result of calling {@link getText}, and {@link source}\n   * will be constructed from the result of {@link Token.getTokenSource} and\n   * {@link Token#getInputStream}.\n   *\n   * @param token The token to copy.\n   */ static fromToken(token) {\n        const source = [\n            token.tokenSource,\n            token.inputStream\n        ];\n        return new _CommonToken({\n            type: token.type,\n            line: token.line,\n            tokenIndex: token.tokenIndex,\n            column: token.column,\n            channel: token.channel,\n            start: token.start,\n            stop: token.stop,\n            text: token.text,\n            source: source\n        });\n    }\n    /**\n   * Constructs a new {@link CommonToken} with the specified token type and text.\n   *\n   * @param type The token type.\n   * @param text The text of the token.\n   */ static fromType(type, text) {\n        return new _CommonToken({\n            type: type,\n            text: text,\n            source: _CommonToken.EMPTY_SOURCE\n        });\n    }\n    static fromSource(source, type, channel, start, stop) {\n        return new _CommonToken({\n            type: type,\n            channel: channel,\n            start: start,\n            stop: stop,\n            source: source\n        });\n    }\n    get tokenSource() {\n        return this.source[0];\n    }\n    get inputStream() {\n        return this.source[1];\n    }\n    set inputStream(input) {\n        this.source[1] = input;\n    }\n    /**\n   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n   *\n   * If `oldToken` is also a {@link CommonToken} instance, the newly\n   * constructed token will share a reference to the {@link text} field and\n   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will\n   * be assigned the result of calling {@link getText}, and {@link source}\n   * will be constructed from the result of {@link Token.getTokenSource} and\n   * {@link Token.getInputStream}.\n   */ clone() {\n        const t = new _CommonToken({\n            source: this.source,\n            type: this.type,\n            channel: this.channel,\n            start: this.start,\n            stop: this.stop,\n            tokenIndex: this.tokenIndex,\n            line: this.line,\n            column: this.column,\n            text: this.#text\n        });\n        return t;\n    }\n    toString(recognizer) {\n        let channelStr = \"\";\n        if (this.channel > 0) channelStr = \",channel=\" + this.channel;\n        let text = this.text;\n        if (text) {\n            text = text.replace(/\\n/g, \"\\\\n\");\n            text = text.replace(/\\r/g, \"\\\\r\");\n            text = text.replace(/\\t/g, \"\\\\t\");\n        } else text = \"<no text>\";\n        let typeString = String(this.type);\n        if (recognizer) typeString = recognizer.vocabulary.getDisplayName(this.type) ?? \"<unknown>\";\n        return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + text + \"',<\" + typeString + \">\" + channelStr + \",\" + this.line + \":\" + this.column + \"]\";\n    }\n    get text() {\n        if (this.#text !== void 0) return this.#text;\n        const input = this.inputStream;\n        if (!input) return void 0;\n        const n2 = input.size;\n        if (this.start < n2 && this.stop < n2) return input.getTextFromRange(this.start, this.stop);\n        return \"<EOF>\";\n    }\n    set text(text) {\n        this.#text = text;\n    }\n    // WritableToken implementation\n    setText(text) {\n        this.#text = text;\n    }\n    setType(ttype) {\n        this.type = ttype;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharPositionInLine(pos) {\n        this.column = pos;\n    }\n    setChannel(channel) {\n        this.channel = channel;\n    }\n    setTokenIndex(index) {\n        this.tokenIndex = index;\n    }\n};\n// src/tree/Trees.ts\nvar $c1efbdb2cbf46748$export$18233453f5804371 = class _Trees {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Trees\");\n    }\n    /**\n   * Print out a whole tree in LISP form. {@link getNodeText} is used on the\n   * node payloads to get the text for the nodes.  Detect\n   * parse trees and extract data appropriately.\n   */ static toStringTree(tree, ruleNames, recog) {\n        ruleNames = ruleNames ?? null;\n        if (recog) ruleNames = recog.ruleNames;\n        let s = _Trees.getNodeText(tree, ruleNames);\n        s = $c1efbdb2cbf46748$export$221fb4e78e2caf9d(s, false);\n        const c = tree.getChildCount();\n        if (c === 0) return s;\n        let res = \"(\" + s + \" \";\n        if (c > 0) {\n            s = _Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i = 1; i < c; i++){\n            s = _Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(\" \" + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    }\n    static getNodeText(t, ruleNames, recog) {\n        ruleNames = ruleNames ?? null;\n        if (recog) ruleNames = recog.ruleNames;\n        if (ruleNames !== null) {\n            if (t instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n                const context = t.ruleContext;\n                const altNumber = context.getAltNumber();\n                if (altNumber !== 0) return ruleNames[t.ruleIndex] + \":\" + altNumber;\n                return ruleNames[t.ruleIndex];\n            } else if (t instanceof $c1efbdb2cbf46748$export$d3ee467d32253151) return t.toString();\n            else if (t instanceof $c1efbdb2cbf46748$export$f6a002739fa43001) return t.symbol.text;\n        }\n        const payload = t.getPayload();\n        if ($c1efbdb2cbf46748$export$7c699a821ea811bc(payload)) return payload.text;\n        return String(t.getPayload());\n    }\n    /**\n   * Return ordered list of all children of this node\n   */ static getChildren(t) {\n        const list = [];\n        for(let i = 0; i < t.getChildCount(); i++)list.push(t.getChild(i));\n        return list;\n    }\n    /**\n   * Return a list of all ancestors of this node.  The first node of\n   * list is the root and the last is the parent of this node.\n   */ static getAncestors(t) {\n        if (t.parent === null) return [];\n        let ancestors = [];\n        let p = t.parent;\n        while(p !== null){\n            ancestors = [\n                p\n            ].concat(ancestors);\n            p = p.parent;\n        }\n        return ancestors;\n    }\n    /**\n   * Return true if t is u's parent or a node on path to root from u.\n   */ static isAncestorOf(t, u) {\n        if (t === null || u === null || t.parent === null) return false;\n        let p = u.parent;\n        while(p !== null){\n            if (t === p) return true;\n            p = p.parent;\n        }\n        return false;\n    }\n    static findAllTokenNodes(t, ttype) {\n        return _Trees.findAllNodes(t, ttype, true);\n    }\n    static findAllRuleNodes(t, ruleIndex) {\n        return _Trees.findAllNodes(t, ruleIndex, false);\n    }\n    static findAllNodes(t, index, findTokens) {\n        const nodes = [];\n        _Trees.doFindAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    }\n    static descendants(t) {\n        let nodes = [\n            t\n        ];\n        for(let i = 0; i < t.getChildCount(); i++)nodes = nodes.concat(_Trees.descendants(t.getChild(i)));\n        return nodes;\n    }\n    /**\n   * Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex\n   * inclusively using post order traversal. Recursive depth-first-search.\n   */ static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {\n        const n2 = t.getChildCount();\n        for(let i = 0; i < n2; i++){\n            const child = t.getChild(i);\n            const r = this.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\n            if (r !== null) return r;\n        }\n        if (t instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n            if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?\n            (t.stop === null || stopTokenIndex <= t.stop.tokenIndex)) return t;\n        }\n        return null;\n    }\n    /**\n   * Replace any subtree siblings of root that are completely to left\n   * or right of lookahead range with a CommonToken(Token.INVALID_TYPE,\"...\")\n   * node. The source interval for t is not altered to suit smaller range!\n   *\n   * WARNING: destructive to t.\n   */ static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {\n        if (t === null) return;\n        for(let i = 0; i < t.getChildCount(); i++){\n            const child = t.getChild(i);\n            const range = child.getSourceInterval();\n            if (t instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253 && (range.stop < startIndex || range.start > stopIndex)) {\n                if (this.isAncestorOf(child, root)) {\n                    const abbrev = $c1efbdb2cbf46748$export$c9b1d0b06becfda3.fromType($c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE, \"...\");\n                    t.children[i] = new $c1efbdb2cbf46748$export$f6a002739fa43001(abbrev);\n                }\n            }\n        }\n    }\n    static doFindAllNodes(t, index, findTokens, nodes) {\n        if (findTokens && t instanceof $c1efbdb2cbf46748$export$f6a002739fa43001) {\n            if (t.symbol?.type === index) nodes.push(t);\n        } else if (!findTokens && t instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n            if (t.ruleIndex === index) nodes.push(t);\n        }\n        for(let i = 0; i < t.getChildCount(); i++)_Trees.doFindAllNodes(t.getChild(i), index, findTokens, nodes);\n    }\n};\n// src/ParserRuleContext.ts\nvar $c1efbdb2cbf46748$export$1198dca6f94b6253 = class _ParserRuleContext {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParserRuleContext\");\n    }\n    static empty = new _ParserRuleContext(null);\n    start = null;\n    stop = null;\n    children = [];\n    /**\n   * What state invoked the rule associated with this context?\n   *  The \"return address\" is the followState of invokingState\n   *  If parent is null, this should be -1 this context object represents\n   *  the start rule.\n   */ invokingState;\n    parent;\n    /**\n   * A rule context is a record of a single rule invocation. It knows\n   * which context invoked it, if any. If there is no parent context, then\n   * naturally the invoking state is not valid.  The parent link\n   * provides a chain upwards from the current rule invocation to the root\n   * of the invocation tree, forming a stack. We actually carry no\n   * information about the rule associated with this context (except\n   * when parsing). We keep only the state number of the invoking state from\n   * the ATN submachine that invoked this. Contrast this with the s\n   * pointer inside ParserRuleContext that tracks the current state\n   * being \"executed\" for the current rule.\n   *\n   * The parent contexts are useful for computing lookahead sets and\n   * getting error information.\n   *\n   * These objects are used during parsing and prediction.\n   * For the special case of parsers, we use the subclass\n   * ParserRuleContext.\n   */ constructor(parent, invokingStateNumber = -1){\n        this.parent = parent;\n        this.invokingState = invokingStateNumber;\n    }\n    /** Copy a context */ copyFrom(ctx) {\n        this.parent = ctx.parent;\n        this.invokingState = ctx.invokingState;\n        this.children.slice(0, this.children.length);\n        this.start = ctx.start;\n        this.stop = ctx.stop;\n        if (ctx.children) ctx.children.forEach((child)=>{\n            if (child instanceof $c1efbdb2cbf46748$export$d3ee467d32253151) {\n                this.children.push(child);\n                child.parent = this;\n            }\n        });\n    }\n    // Double dispatch methods for listeners\n    enterRule(_listener) {}\n    exitRule(_listener) {}\n    addChild(child) {\n        this.children.push(child);\n        return child;\n    }\n    /**\n   * Used by enterOuterAlt to toss out a RuleContext previously added as\n   * we entered a rule. If we have label, we will need to remove\n   * generic ruleContext object.\n   */ removeLastChild() {\n        this.children.pop();\n    }\n    addTokenNode(token) {\n        const node = new $c1efbdb2cbf46748$export$f6a002739fa43001(token);\n        this.children.push(node);\n        node.parent = this;\n        return node;\n    }\n    addErrorNode(errorNode) {\n        errorNode.parent = this;\n        this.children.push(errorNode);\n        return errorNode;\n    }\n    getChild(i, type) {\n        if (i < 0 || i >= this.children.length) return null;\n        if (!type) return this.children[i];\n        for (const child of this.children)if (child instanceof type) {\n            if (i === 0) return child;\n            else i -= 1;\n        }\n        return null;\n    }\n    getToken(ttype, i) {\n        if (i < 0 || i >= this.children.length) return null;\n        for (const child of this.children){\n            if (\"symbol\" in child) {\n                if (child.symbol?.type === ttype) {\n                    if (i === 0) return child;\n                    else i -= 1;\n                }\n            }\n        }\n        return null;\n    }\n    getTokens(ttype) {\n        const tokens = [];\n        for (const child of this.children){\n            if (\"symbol\" in child) {\n                if (child.symbol?.type === ttype) tokens.push(child);\n            }\n        }\n        return tokens;\n    }\n    // XXX: base the child type selection on the rule index, not the class.\n    getRuleContext(index, ctxType) {\n        return this.getChild(index, ctxType);\n    }\n    // XXX: base the child type selection on the rule index, not the class.\n    getRuleContexts(ctxType) {\n        const contexts = [];\n        for (const child of this.children)if (child instanceof ctxType) contexts.push(child);\n        return contexts;\n    }\n    getChildCount() {\n        return this.children.length;\n    }\n    getSourceInterval() {\n        if (this.start === null) return $c1efbdb2cbf46748$export$e659c2681d58d45b.INVALID_INTERVAL;\n        if (this.stop === null || this.stop.tokenIndex < this.start.tokenIndex) return new $c1efbdb2cbf46748$export$e659c2681d58d45b(this.start.tokenIndex, this.start.tokenIndex - 1);\n        return new $c1efbdb2cbf46748$export$e659c2681d58d45b(this.start.tokenIndex, this.stop.tokenIndex);\n    }\n    depth() {\n        let n2 = 0;\n        let p = this;\n        while(p !== null){\n            p = p.parent;\n            n2 += 1;\n        }\n        return n2;\n    }\n    /**\n   * A context is empty if there is no invoking state; meaning nobody call\n   * current context.\n   */ isEmpty() {\n        return this.invokingState === -1;\n    }\n    get ruleContext() {\n        return this;\n    }\n    get ruleIndex() {\n        return -1;\n    }\n    getPayload() {\n        return this;\n    }\n    getText() {\n        if (this.children.length === 0) return \"\";\n        return this.children.map((child)=>{\n            return child.getText();\n        }).join(\"\");\n    }\n    /**\n   * For rule associated with this parse tree internal node, return\n   * the outer alternative number used to match the input. Default\n   * implementation does not compute nor store this alt num. Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   * to set it.\n   */ getAltNumber() {\n        return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n    }\n    /**\n   * Set the outer alternative number for this context node. Default\n   * implementation does nothing to avoid backing field overhead for\n   * trees that don't need it.  Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   */ setAltNumber(_altNumber) {}\n    accept(visitor) {\n        return visitor.visitChildren(this);\n    }\n    toStringTree(...args) {\n        if (args.length < 2) return $c1efbdb2cbf46748$export$18233453f5804371.toStringTree(this, null, args[0]);\n        return $c1efbdb2cbf46748$export$18233453f5804371.toStringTree(this, args[0], args[1]);\n    }\n    toString(ruleNames, stop) {\n        ruleNames = ruleNames ?? null;\n        stop = stop ?? null;\n        let p = this;\n        let s = \"[\";\n        while(p !== null && p !== stop){\n            if (ruleNames === null) {\n                if (!p.isEmpty()) s += p.invokingState;\n            } else {\n                const ri = p.ruleIndex;\n                const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : \"\" + ri;\n                s += ruleName;\n            }\n            if (p.parent !== null && (ruleNames !== null || !p.parent.isEmpty())) s += \" \";\n            p = p.parent;\n        }\n        s += \"]\";\n        return s;\n    }\n};\n// src/atn/ArrayPredictionContext.ts\nvar $c1efbdb2cbf46748$export$642800593f263945 = class _ArrayPredictionContext extends $c1efbdb2cbf46748$export$95ea21db2ed34266 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ArrayPredictionContext\");\n    }\n    parents = [];\n    returnStates = [];\n    constructor(parents, returnStates){\n        super($c1efbdb2cbf46748$export$95ea21db2ed34266.calculateHashCodeList(parents, returnStates));\n        this.parents = parents;\n        this.returnStates = returnStates;\n        return this;\n    }\n    isEmpty() {\n        return this.returnStates[0] === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE;\n    }\n    get length() {\n        return this.returnStates.length;\n    }\n    getParent(index) {\n        return this.parents[index];\n    }\n    getReturnState(index) {\n        return this.returnStates[index];\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _ArrayPredictionContext) || this.hashCode() !== other.hashCode()) return false;\n        return $c1efbdb2cbf46748$export$edfd5757e80058f3(this.returnStates, other.returnStates) && $c1efbdb2cbf46748$export$dc63f52ecf814bf8(this.parents, other.parents);\n    }\n    toString() {\n        if (this.isEmpty()) return \"[]\";\n        const entries = [];\n        for(let i = 0; i < this.returnStates.length; i++){\n            if (this.returnStates[i] === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE) {\n                entries.push(\"$\");\n                continue;\n            }\n            entries.push(this.returnStates[i].toString());\n            if (this.parents[i]) entries.push(this.parents[i].toString());\n            else entries.push(\"null\");\n        }\n        return `[${entries.join(\", \")}]`;\n    }\n};\n// src/atn/helpers.ts\nvar $c1efbdb2cbf46748$export$85d7977d7e5c4cc2 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((parent, returnState)=>{\n    if (returnState === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE && parent === null) return $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n    else return new $c1efbdb2cbf46748$export$d50bfe6c4685d25b(parent, returnState);\n}, \"createSingletonPredictionContext\");\n// src/atn/PredictionContextUtils.ts\nvar $c1efbdb2cbf46748$export$c1f97ac8322a726f = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((atn, outerContext)=>{\n    if (!outerContext) outerContext = $c1efbdb2cbf46748$export$1198dca6f94b6253.empty;\n    if (!outerContext.parent || outerContext === $c1efbdb2cbf46748$export$1198dca6f94b6253.empty) return $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n    const parent = $c1efbdb2cbf46748$export$c1f97ac8322a726f(atn, outerContext.parent);\n    const state = atn.states[outerContext.invokingState];\n    const transition = state.transitions[0];\n    return $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(parent, transition.followState.stateNumber);\n}, \"predictionContextFromRuleContext\");\nvar $c1efbdb2cbf46748$export$8019946e4b88a3a0 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((context, contextCache, visited)=>{\n    if (context.isEmpty()) return context;\n    let existing = visited.get(context);\n    if (existing) return existing;\n    existing = contextCache.get(context);\n    if (existing) {\n        visited.set(context, existing);\n        return existing;\n    }\n    let changed = false;\n    let parents = [];\n    for(let i = 0; i < parents.length; i++){\n        const parent = $c1efbdb2cbf46748$export$8019946e4b88a3a0(context.getParent(i), contextCache, visited);\n        if (changed || parent !== context.getParent(i)) {\n            if (!changed) {\n                parents = [];\n                for(let j = 0; j < context.length; j++)parents[j] = context.getParent(j);\n                changed = true;\n            }\n            parents[i] = parent;\n        }\n    }\n    if (!changed) {\n        contextCache.add(context);\n        visited.set(context, context);\n        return context;\n    }\n    let updated;\n    if (parents.length === 0) updated = $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n    else if (parents.length === 1) updated = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(parents[0] ?? void 0, context.getReturnState(0));\n    else updated = new $c1efbdb2cbf46748$export$642800593f263945(parents, context.returnStates);\n    contextCache.add(updated);\n    visited.set(updated, updated);\n    visited.set(context, updated);\n    return updated;\n}, \"getCachedPredictionContext\");\nvar $c1efbdb2cbf46748$export$4950aa0f605343fb = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b, rootIsWildcard, mergeCache)=>{\n    if (a === b || a.equals(b)) return a;\n    if (a instanceof $c1efbdb2cbf46748$export$d50bfe6c4685d25b && b instanceof $c1efbdb2cbf46748$export$d50bfe6c4685d25b) return $c1efbdb2cbf46748$export$1de9f6442a66a6e2(a, b, rootIsWildcard, mergeCache);\n    if (rootIsWildcard) {\n        if (a instanceof $c1efbdb2cbf46748$export$179fd11580abda9d) return a;\n        if (b instanceof $c1efbdb2cbf46748$export$179fd11580abda9d) return b;\n    }\n    if (a instanceof $c1efbdb2cbf46748$export$d50bfe6c4685d25b) a = new $c1efbdb2cbf46748$export$642800593f263945([\n        a.parent\n    ], [\n        a.returnState\n    ]);\n    if (b instanceof $c1efbdb2cbf46748$export$d50bfe6c4685d25b) b = new $c1efbdb2cbf46748$export$642800593f263945([\n        b.parent\n    ], [\n        b.returnState\n    ]);\n    return $c1efbdb2cbf46748$var$mergeArrays(a, b, rootIsWildcard, mergeCache);\n}, \"merge\");\nvar $c1efbdb2cbf46748$var$mergeArrays = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b, rootIsWildcard, mergeCache)=>{\n    if (mergeCache) {\n        let previous = mergeCache.get(a, b);\n        if (previous) return previous;\n        previous = mergeCache.get(b, a);\n        if (previous) return previous;\n    }\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let mergedReturnStates = new Array(a.returnStates.length + b.returnStates.length).fill(0);\n    let mergedParents = new Array(a.returnStates.length + b.returnStates.length).fill(null);\n    while(i < a.returnStates.length && j < b.returnStates.length){\n        const aParent = a.parents[i];\n        const bParent = b.parents[j];\n        if (a.returnStates[i] === b.returnStates[j]) {\n            const payload = a.returnStates[i];\n            const bothDollars = payload === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE && aParent === null && bParent === null;\n            const axAx = aParent !== null && bParent !== null && aParent === bParent;\n            if (bothDollars || axAx) {\n                mergedParents[k] = aParent;\n                mergedReturnStates[k] = payload;\n            } else {\n                mergedParents[k] = $c1efbdb2cbf46748$export$4950aa0f605343fb(aParent, bParent, rootIsWildcard, mergeCache);\n                mergedReturnStates[k] = payload;\n            }\n            i += 1;\n            j += 1;\n        } else if (a.returnStates[i] < b.returnStates[j]) {\n            mergedParents[k] = aParent;\n            mergedReturnStates[k] = a.returnStates[i];\n            i += 1;\n        } else {\n            mergedParents[k] = bParent;\n            mergedReturnStates[k] = b.returnStates[j];\n            j += 1;\n        }\n        k += 1;\n    }\n    if (i < a.returnStates.length) for(let p = i; p < a.returnStates.length; p++){\n        mergedParents[k] = a.parents[p];\n        mergedReturnStates[k] = a.returnStates[p];\n        k += 1;\n    }\n    else for(let p = j; p < b.returnStates.length; p++){\n        mergedParents[k] = b.parents[p];\n        mergedReturnStates[k] = b.returnStates[p];\n        k += 1;\n    }\n    if (k < mergedParents.length) {\n        if (k === 1) {\n            const aNew = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(mergedParents[0] ?? void 0, mergedReturnStates[0]);\n            if (mergeCache !== null) mergeCache.set(a, b, aNew);\n            return aNew;\n        }\n        mergedParents = mergedParents.slice(0, k);\n        mergedReturnStates = mergedReturnStates.slice(0, k);\n    }\n    const merged = new $c1efbdb2cbf46748$export$642800593f263945(mergedParents, mergedReturnStates);\n    if (merged.equals(a)) {\n        if (mergeCache !== null) mergeCache.set(a, b, a);\n        if ($c1efbdb2cbf46748$export$95ea21db2ed34266.traceATNSimulator) console.log(\"mergeArrays a=\" + a + \",b=\" + b + \" -> a\");\n        return a;\n    }\n    if (merged.equals(b)) {\n        if (mergeCache !== null) mergeCache.set(a, b, b);\n        return b;\n    }\n    $c1efbdb2cbf46748$export$3fb1d9247427cd84(mergedParents);\n    if (mergeCache !== null) mergeCache.set(a, b, merged);\n    if ($c1efbdb2cbf46748$export$95ea21db2ed34266.traceATNSimulator) console.log(\"mergeArrays a=\" + a + \",b=\" + b + \" -> \" + merged);\n    return merged;\n}, \"mergeArrays\");\nvar $c1efbdb2cbf46748$export$3fb1d9247427cd84 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((parents)=>{\n    const uniqueParents = new $c1efbdb2cbf46748$export$60ef0b43d585640a($c1efbdb2cbf46748$var$ObjectEqualityComparator.instance);\n    for (const parent of parents){\n        if (parent) {\n            if (!uniqueParents.containsKey(parent)) uniqueParents.set(parent, parent);\n        }\n    }\n    for(let q = 0; q < parents.length; q++)if (parents[q]) parents[q] = uniqueParents.get(parents[q]) ?? null;\n}, \"combineCommonParents\");\nvar $c1efbdb2cbf46748$export$1de9f6442a66a6e2 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b, rootIsWildcard, mergeCache)=>{\n    if (mergeCache !== null) {\n        let previous = mergeCache.get(a, b);\n        if (previous !== null) return previous;\n        previous = mergeCache.get(b, a);\n        if (previous !== null) return previous;\n    }\n    const rootMerge = $c1efbdb2cbf46748$export$734cb39f208f4435(a, b, rootIsWildcard);\n    if (rootMerge !== null) {\n        if (mergeCache !== null) mergeCache.set(a, b, rootMerge);\n        return rootMerge;\n    }\n    if (a.returnState === b.returnState) {\n        const parent = $c1efbdb2cbf46748$export$4950aa0f605343fb(a.parent, b.parent, rootIsWildcard, mergeCache);\n        if (parent === a.parent) return a;\n        if (parent === b.parent) return b;\n        const spc = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(parent, a.returnState);\n        if (mergeCache !== null) mergeCache.set(a, b, spc);\n        return spc;\n    } else {\n        let singleParent = null;\n        if (a === b || a.parent !== null && a.parent.equals(b.parent)) singleParent = a.parent;\n        if (singleParent !== null) {\n            const payloads2 = [\n                a.returnState,\n                b.returnState\n            ];\n            if (a.returnState > b.returnState) {\n                payloads2[0] = b.returnState;\n                payloads2[1] = a.returnState;\n            }\n            const parents2 = [\n                singleParent,\n                singleParent\n            ];\n            const apc = new $c1efbdb2cbf46748$export$642800593f263945(parents2, payloads2);\n            if (mergeCache !== null) mergeCache.set(a, b, apc);\n            return apc;\n        }\n        const payloads = [\n            a.returnState,\n            b.returnState\n        ];\n        let parents = [\n            a.parent,\n            b.parent\n        ];\n        if (a.returnState > b.returnState) {\n            payloads[0] = b.returnState;\n            payloads[1] = a.returnState;\n            parents = [\n                b.parent,\n                a.parent\n            ];\n        }\n        const aNew = new $c1efbdb2cbf46748$export$642800593f263945(parents, payloads);\n        if (mergeCache !== null) mergeCache.set(a, b, aNew);\n        return aNew;\n    }\n}, \"mergeSingletons\");\nvar $c1efbdb2cbf46748$export$734cb39f208f4435 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((a, b, rootIsWildcard)=>{\n    if (rootIsWildcard) {\n        if (a === $c1efbdb2cbf46748$export$179fd11580abda9d.instance || b === $c1efbdb2cbf46748$export$179fd11580abda9d.instance) return $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n    } else {\n        if (a === $c1efbdb2cbf46748$export$179fd11580abda9d.instance && b === $c1efbdb2cbf46748$export$179fd11580abda9d.instance) return $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n        if (a === $c1efbdb2cbf46748$export$179fd11580abda9d.instance) {\n            const payloads = [\n                b.returnState,\n                $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE\n            ];\n            const parents = [\n                b.parent,\n                null\n            ];\n            return new $c1efbdb2cbf46748$export$642800593f263945(parents, payloads);\n        }\n        if (b === $c1efbdb2cbf46748$export$179fd11580abda9d.instance) {\n            const payloads = [\n                a.returnState,\n                $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE\n            ];\n            const parents = [\n                a.parent,\n                null\n            ];\n            return new $c1efbdb2cbf46748$export$642800593f263945(parents, payloads);\n        }\n    }\n    return null;\n}, \"mergeRoot\");\n// src/atn/LL1Analyzer.ts\nvar $c1efbdb2cbf46748$export$434fb93edf9df743 = class _LL1Analyzer {\n    constructor(atn){\n        this.atn = atn;\n    }\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LL1Analyzer\");\n    }\n    /**\n   * Special value added to the lookahead sets to indicate that we hit\n   * a predicate during analysis if `seeThruPreds==false`.\n   */ static hitPredicate = $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n    /**\n   * Calculates the SLL(1) expected lookahead set for each outgoing transition\n   * of an {@link ATNState}. The returned array has one element for each\n   * outgoing transition in `s`. If the closure from transition\n   * _i_ leads to a semantic predicate before matching a symbol, the\n   * element at index *i* of the result will be `undefined`.\n   *\n   * @param s the ATN state\n   * @returns the expected symbols for each outgoing transition of `s`.\n   */ getDecisionLookahead(s) {\n        const count = s.transitions.length;\n        const look = new Array(count);\n        for(let alt = 0; alt < count; alt++){\n            const set = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n            const lookBusy = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n            this.doLook(s.transitions[alt].target, void 0, $c1efbdb2cbf46748$export$179fd11580abda9d.instance, set, lookBusy, new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df(), false, false);\n            if (set.length > 0 && !set.contains(_LL1Analyzer.hitPredicate)) look[alt] = set;\n        }\n        return look;\n    }\n    /**\n   * Compute set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   *\n   * If `ctx` is `null` and the end of the rule containing\n   * `s` is reached, {@link Token//EPSILON} is added to the result set.\n   * If `ctx` is not `null` and the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.\n   *\n   * @param s the ATN state\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx the complete parser context, or `null` if the context\n   * should be ignored\n   *\n   * @returns The set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   */ look(s, stopState, ctx) {\n        const r = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n        const lookContext = ctx ? $c1efbdb2cbf46748$export$c1f97ac8322a726f(this.atn, ctx) : null;\n        this.doLook(s, stopState, lookContext, r, new $c1efbdb2cbf46748$export$9d0bf21c11057332(), new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df(), true, true);\n        return r;\n    }\n    /**\n   * Compute set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   *\n   * If `ctx` is `null` and `stopState` or the end of the\n   * rule containing `s` is reached, {@link Token//EPSILON} is added to\n   * the result set. If `ctx` is not `null` and `addEOF` is\n   * `true` and `stopState` or the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.\n   *\n   * @param s the ATN state.\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx The outer context, or `null` if the outer context should\n   * not be used.\n   * @param look The result lookahead set.\n   * @param lookBusy A set used for preventing epsilon closures in the ATN\n   * from causing a stack overflow. Outside code should pass\n   * `new CustomizedSet<ATNConfig>` for this argument.\n   * @param calledRuleStack A set used for preventing left recursion in the\n   * ATN from causing a stack overflow. Outside code should pass\n   * `new BitSet()` for this argument.\n   * @param seeThruPreds `true` to true semantic predicates as\n   * implicitly `true` and \"see through them\", otherwise `false`\n   * to treat semantic predicates as opaque and add {@link hitPredicate} to the\n   * result if one is encountered.\n   * @param addEOF Add {@link Token//EOF} to the result if the end of the\n   * outermost context is reached. This parameter has no effect if `ctx`\n   * is `null`.\n   */ doLook(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithContext(s, 0, ctx);\n        if (lookBusy.get(c)) return;\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (!ctx) {\n                look.addOne($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne($c1efbdb2cbf46748$export$50792b0e93539fde.EOF);\n                return;\n            }\n        }\n        if (s.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) {\n            if (!ctx) {\n                look.addOne($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne($c1efbdb2cbf46748$export$50792b0e93539fde.EOF);\n                return;\n            }\n            if (ctx !== $c1efbdb2cbf46748$export$179fd11580abda9d.instance) {\n                const removed = calledRuleStack.get(s.ruleIndex);\n                try {\n                    calledRuleStack.clear(s.ruleIndex);\n                    for(let i = 0; i < ctx.length; i++){\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this.doLook(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                } finally{\n                    if (removed) calledRuleStack.set(s.ruleIndex);\n                }\n                return;\n            }\n        }\n        for (const t of s.transitions)switch(t.transitionType){\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RULE:\n                {\n                    if (calledRuleStack.get(t.target.ruleIndex)) continue;\n                    const newContext = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(ctx ?? void 0, t.followState.stateNumber);\n                    try {\n                        calledRuleStack.set(t.target.ruleIndex);\n                        this.doLook(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    } finally{\n                        calledRuleStack.clear(t.target.ruleIndex);\n                    }\n                    break;\n                }\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE:\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE:\n                if (seeThruPreds) this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                else look.addOne(_LL1Analyzer.hitPredicate);\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.WILDCARD:\n                look.addRange($c1efbdb2cbf46748$export$50792b0e93539fde.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                break;\n            default:\n                if (t.isEpsilon) this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                else {\n                    let set = t.label;\n                    if (set) {\n                        if (t instanceof $c1efbdb2cbf46748$export$a0e4d5a57a08628e) set = set.complement($c1efbdb2cbf46748$export$50792b0e93539fde.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                        look.addSet(set);\n                    }\n                }\n                break;\n        }\n    }\n};\n// src/atn/ATN.ts\nvar $c1efbdb2cbf46748$export$ffe90c5f202db011 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATN\");\n    }\n    static INVALID_ALT_NUMBER = 0;\n    /** Represents the type of recognizer an ATN applies to */ static LEXER = 0;\n    static PARSER = 1;\n    /**\n   * Used for runtime deserialization of ATNs from strings\n   * The type of the ATN.\n   */ grammarType;\n    /** The maximum value for any symbol recognized by a transition in the ATN. */ maxTokenType;\n    states = [];\n    /**\n   * Each subrule/rule is a decision point and we must track them so we\n   * can go back later and build DFA predictors for them.  This includes\n   * all the rules, subrules, optional blocks, ()+, ()* etc...\n   */ decisionToState = [];\n    /** Maps from rule index to starting state number. */ ruleToStartState = [];\n    // Initialized by the ATN deserializer.\n    /** Maps from rule index to stop state number. */ ruleToStopState = [];\n    // Initialized by the ATN deserializer.\n    modeNameToStartState = /* @__PURE__ */ new Map();\n    /**\n   * For lexer ATNs, this maps the rule index to the resulting token type.\n   * For parser ATNs, this maps the rule index to the generated bypass token\n   * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n   * deserialization option was specified; otherwise, this is `null`\n   */ ruleToTokenType = [];\n    // Initialized by the ATN deserializer.\n    /**\n   * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n   * be referenced by action transitions in the ATN\n   */ lexerActions = [];\n    modeToStartState = [];\n    analyzer;\n    constructor(grammarType, maxTokenType){\n        this.grammarType = grammarType;\n        this.maxTokenType = maxTokenType;\n        this.analyzer = new $c1efbdb2cbf46748$export$434fb93edf9df743(this);\n    }\n    /**\n   * Compute the set of valid tokens that can occur starting in state `s`.\n   * If `ctx` is null, the set of tokens will not include what can follow\n   * the rule surrounding `s`. In other words, the set will be\n   * restricted to tokens reachable staying within `s`'s rule.\n   */ nextTokens(atnState, ctx) {\n        if (!ctx && atnState.nextTokenWithinRule) return atnState.nextTokenWithinRule;\n        const next = this.analyzer.look(atnState, void 0, ctx);\n        if (!ctx) atnState.nextTokenWithinRule = next;\n        return next;\n    }\n    addState(state) {\n        if (state) state.stateNumber = this.states.length;\n        this.states.push(state);\n    }\n    removeState(state) {\n        this.states[state.stateNumber] = null;\n    }\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length - 1;\n        return s.decision;\n    }\n    getDecisionState(decision) {\n        if (this.decisionToState.length === 0) return null;\n        else return this.decisionToState[decision];\n    }\n    getNumberOfDecisions() {\n        return this.decisionToState.length;\n    }\n    /**\n   * Computes the set of input symbols which could follow ATN state number\n   * `stateNumber` in the specified full `context`. This method\n   * considers the complete parser context, but does not evaluate semantic\n   * predicates (i.e. all predicates encountered during the calculation are\n   * assumed true). If a path in the ATN exists from the starting state to the\n   * {@link RuleStopState} of the outermost context without matching any\n   * symbols, {@link Token//EOF} is added to the returned set.\n   *\n   * If `context` is `null`, it is treated as\n   * {@link ParserRuleContext//EMPTY}.\n   *\n   * @param stateNumber the ATN state number\n   * @param context the full parse context\n   *\n   * @returns {IntervalSet} The set of potentially valid input symbols which could follow the\n   * specified state in the specified context.\n   *\n   * @throws IllegalArgumentException if the ATN does not contain a state with\n   * number `stateNumber`\n   */ getExpectedTokens(stateNumber, context) {\n        if (stateNumber < 0 || stateNumber >= this.states.length) throw new Error(\"Invalid state number.\");\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)) return following;\n        let ctx = context;\n        const expected = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n        expected.addSet(following);\n        expected.removeOne($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON);\n        while(ctx !== null && ctx.invokingState >= 0 && following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)){\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON);\n            ctx = ctx.parent;\n        }\n        if (following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)) expected.addOne($c1efbdb2cbf46748$export$50792b0e93539fde.EOF);\n        return expected;\n    }\n};\n// src/atn/ATNConfigSet.ts\nvar $c1efbdb2cbf46748$var$KeyTypeEqualityComparer = class _KeyTypeEqualityComparer {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"KeyTypeEqualityComparer\");\n    }\n    static instance = new _KeyTypeEqualityComparer();\n    hashCode(config) {\n        let hashCode = 7;\n        hashCode = 31 * hashCode + config.state.stateNumber;\n        hashCode = 31 * hashCode + config.alt;\n        hashCode = 31 * hashCode + config.semanticContext.hashCode();\n        return hashCode;\n    }\n    equals(a, b) {\n        if (a === b) return true;\n        return a.state.stateNumber === b.state.stateNumber && a.alt === b.alt && a.semanticContext.equals(b.semanticContext);\n    }\n};\nvar $c1efbdb2cbf46748$export$3e159d9d82bfca90 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNConfigSet\");\n    }\n    /**\n   * The reason that we need this is because we don't want the hash map to use\n   * the standard hash code and equals. We need all configurations with the\n   * same\n   * `(s,i,_,semctx)` to be equal. Unfortunately, this key effectively\n   * doubles\n   * the number of objects associated with ATNConfigs. The other solution is\n   * to\n   * use a hash table that lets us specify the equals/hashCode operation.\n   * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n   * when we go readonly as this set becomes a DFA state\n   */ configLookup = new $c1efbdb2cbf46748$export$9d0bf21c11057332($c1efbdb2cbf46748$var$KeyTypeEqualityComparer.instance);\n    // Track the elements as they are added to the set; supports get(i).\n    configs = [];\n    uniqueAlt = 0;\n    /**\n   * Used in parser and lexer. In lexer, it indicates we hit a pred\n   * while computing a closure operation. Don't make a DFA state from this\n   */ hasSemanticContext = false;\n    dipsIntoOuterContext = false;\n    /**\n   * Indicates that this configuration set is part of a full context\n   * LL prediction. It will be used to determine how to merge $. With SLL\n   * it's a wildcard whereas it is not for LL context merge\n   */ fullCtx = false;\n    /**\n   * Indicates that the set of configurations is read-only. Do not\n   * allow any code to manipulate the set; DFA states will point at\n   * the sets and they must not change. This does not protect the other\n   * fields; in particular, conflictingAlts is set after\n   * we've made this readonly\n   */ readOnly = false;\n    conflictingAlts = null;\n    /**\n   * Tracks the first config that has a rule stop state. Avoids frequent linear search for that, when adding\n   * a DFA state in the lexer ATN simulator.\n   */ firstStopState;\n    #cachedHashCode = -1;\n    constructor(fullCtxOrOldSet){\n        if (fullCtxOrOldSet !== void 0) {\n            if (typeof fullCtxOrOldSet === \"boolean\") this.fullCtx = fullCtxOrOldSet ?? true;\n            else {\n                const old = fullCtxOrOldSet;\n                this.addAll(old.configs);\n                this.uniqueAlt = old.uniqueAlt;\n                this.conflictingAlts = old.conflictingAlts;\n                this.hasSemanticContext = old.hasSemanticContext;\n                this.dipsIntoOuterContext = old.dipsIntoOuterContext;\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.configs[Symbol.iterator]();\n    }\n    /**\n   * Adding a new config means merging contexts with existing configs for\n   * `(s, i, pi, _)`, where `s` is the {@link ATNConfig.state}, `i` is the {@link ATNConfig.alt}, and\n   * `pi` is the {@link ATNConfig.semanticContext}. We use `(s,i,pi)` as key.\n   *\n   * This method updates {@link dipsIntoOuterContext} and\n   * {@link hasSemanticContext} when necessary.\n   */ add(config, mergeCache = null) {\n        if (this.readOnly) throw new Error(\"This set is readonly\");\n        if (!this.firstStopState && config.state.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) this.firstStopState = config;\n        this.hasSemanticContext ||= config.semanticContext !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE;\n        this.dipsIntoOuterContext ||= config.reachesIntoOuterContext;\n        const existing = this.configLookup.getOrAdd(config);\n        if (existing === config) {\n            this.#cachedHashCode = -1;\n            this.configs.push(config);\n            return;\n        }\n        const rootIsWildcard = !this.fullCtx;\n        const merged = $c1efbdb2cbf46748$export$4950aa0f605343fb(existing.context, config.context, rootIsWildcard, mergeCache);\n        existing.reachesIntoOuterContext ||= config.reachesIntoOuterContext;\n        existing.precedenceFilterSuppressed ||= config.precedenceFilterSuppressed;\n        existing.context = merged;\n    }\n    /** Return a List holding list of configs */ get elements() {\n        return this.configs;\n    }\n    /**\n   * Gets the complete set of represented alternatives for the configuration set.\n   *\n   * @returns the set of represented alternatives in this configuration set\n   */ getAlts() {\n        const alts = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n        for (const config of this.configs)alts.set(config.alt);\n        return alts;\n    }\n    getPredicates() {\n        const preds = [];\n        for (const config of this.configs)if (config.semanticContext !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) preds.push(config.semanticContext);\n        return preds;\n    }\n    getStates() {\n        const states = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n        for (const config of this.configs)states.add(config.state);\n        return states;\n    }\n    optimizeConfigs(interpreter) {\n        if (this.readOnly) throw new Error(\"This set is readonly\");\n        if (this.configLookup.size === 0) return;\n        for (const config of this.configs)config.context = interpreter.getCachedContext(config.context);\n    }\n    addAll(coll) {\n        for (const config of coll)this.add(config);\n        return false;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext && $c1efbdb2cbf46748$export$dc63f52ecf814bf8(this.configs, other.configs)) return true;\n        return false;\n    }\n    hashCode() {\n        if (this.#cachedHashCode === -1) this.#cachedHashCode = this.computeHashCode();\n        return this.#cachedHashCode;\n    }\n    get length() {\n        return this.configs.length;\n    }\n    isEmpty() {\n        return this.configs.length === 0;\n    }\n    contains(item) {\n        if (this.configLookup === null) throw new Error(\"This method is not implemented for readonly sets.\");\n        return this.configLookup.contains(item);\n    }\n    containsFast(item) {\n        if (this.configLookup === null) throw new Error(\"This method is not implemented for readonly sets.\");\n        return this.configLookup.contains(item);\n    }\n    clear() {\n        if (this.readOnly) throw new Error(\"This set is readonly\");\n        this.configs = [];\n        this.#cachedHashCode = -1;\n        this.configLookup = new $c1efbdb2cbf46748$export$9d0bf21c11057332($c1efbdb2cbf46748$var$KeyTypeEqualityComparer.instance);\n    }\n    setReadonly(readOnly) {\n        this.readOnly = readOnly;\n        if (readOnly) this.configLookup = null;\n    }\n    toString() {\n        return $c1efbdb2cbf46748$export$4323cc4280d5be7(this.configs) + (this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") + (this.uniqueAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") + (this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") + (this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n    }\n    computeHashCode() {\n        let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n        this.configs.forEach((config)=>{\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, config.hashCode());\n        });\n        hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, this.configs.length);\n        return hash;\n    }\n};\n// src/atn/BasicState.ts\nvar $c1efbdb2cbf46748$export$a24717045da89386 = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BasicState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.BASIC;\n};\n// src/atn/DecisionState.ts\nvar $c1efbdb2cbf46748$export$546c00a8fe1b4d1a = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DecisionState\");\n    }\n    decision = -1;\n    nonGreedy = false;\n};\n// src/atn/BlockStartState.ts\nvar $c1efbdb2cbf46748$export$47d3f79353fa3139 = class extends $c1efbdb2cbf46748$export$546c00a8fe1b4d1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BlockStartState\");\n    }\n    endState;\n};\n// src/atn/BlockEndState.ts\nvar $c1efbdb2cbf46748$export$ef7d128af4cd29f = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BlockEndState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_END;\n    startState;\n};\n// src/atn/LoopEndState.ts\nvar $c1efbdb2cbf46748$export$8ff967d5b8bcca40 = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LoopEndState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.LOOP_END;\n    loopBackState;\n};\n// src/atn/RuleStartState.ts\nvar $c1efbdb2cbf46748$export$d69d85a987fddbef = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RuleStartState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_START;\n    stopState;\n    isLeftRecursiveRule = false;\n};\n// src/atn/RuleStopState.ts\nvar $c1efbdb2cbf46748$export$ba787240acf6572c = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RuleStopState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP;\n};\n// src/atn/TokensStartState.ts\nvar $c1efbdb2cbf46748$export$c7815420e454fdf8 = class extends $c1efbdb2cbf46748$export$546c00a8fe1b4d1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TokensStartState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.TOKEN_START;\n};\n// src/atn/PlusLoopbackState.ts\nvar $c1efbdb2cbf46748$export$5f5ea071b7e146fe = class extends $c1efbdb2cbf46748$export$546c00a8fe1b4d1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PlusLoopbackState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_LOOP_BACK;\n};\n// src/atn/StarLoopbackState.ts\nvar $c1efbdb2cbf46748$export$29739011cda0b11b = class extends $c1efbdb2cbf46748$export$21a6260de0fddd55 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"StarLoopbackState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_BACK;\n};\n// src/atn/StarLoopEntryState.ts\nvar $c1efbdb2cbf46748$export$d8a6440f35eed376 = class extends $c1efbdb2cbf46748$export$546c00a8fe1b4d1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"StarLoopEntryState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_ENTRY;\n    // This is always set during ATN deserialization\n    loopBackState;\n    /**\n   * Indicates whether this state can benefit from a precedence DFA during SLL\n   * decision making.\n   *\n   * This is a computed property that is calculated during ATN deserialization\n   * and stored for use in {@link ParserATNSimulator} and\n   * {@link ParserInterpreter}.\n   *\n   * @see `DFA.isPrecedenceDfa`\n   */ precedenceRuleDecision = false;\n};\n// src/atn/PlusBlockStartState.ts\nvar $c1efbdb2cbf46748$export$4b53728d66f9971c = class extends $c1efbdb2cbf46748$export$47d3f79353fa3139 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PlusBlockStartState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_BLOCK_START;\n    loopBackState;\n};\n// src/atn/StarBlockStartState.ts\nvar $c1efbdb2cbf46748$export$9162e345fad804f4 = class extends $c1efbdb2cbf46748$export$47d3f79353fa3139 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"StarBlockStartState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_BLOCK_START;\n};\n// src/atn/BasicBlockStartState.ts\nvar $c1efbdb2cbf46748$export$6c4b09c827e3821 = class extends $c1efbdb2cbf46748$export$47d3f79353fa3139 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BasicBlockStartState\");\n    }\n    static stateType = $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_START;\n};\n// src/atn/AtomTransition.ts\nvar $c1efbdb2cbf46748$export$749c9accb19d603f = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"AtomTransition\");\n    }\n    /** The token type or character value; or, signifies special label. */ labelValue;\n    #label;\n    constructor(target, label){\n        super(target);\n        this.labelValue = label;\n        this.#label = $c1efbdb2cbf46748$export$9aa814bfdfb30f8f.of(label, label);\n    }\n    get label() {\n        return this.#label;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.ATOM;\n    }\n    matches(symbol) {\n        return this.labelValue === symbol;\n    }\n    toString() {\n        return this.labelValue.toString();\n    }\n};\n// src/atn/RuleTransition.ts\nvar $c1efbdb2cbf46748$export$5a1cda5a00fd126 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RuleTransition\");\n    }\n    ruleIndex;\n    precedence;\n    followState;\n    constructor(ruleStart, ruleIndex, precedence, followState){\n        super(ruleStart);\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        this.followState = followState;\n    }\n    get isEpsilon() {\n        return true;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.RULE;\n    }\n    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return false;\n    }\n};\n// src/atn/RangeTransition.ts\nvar $c1efbdb2cbf46748$export$87d1473c8b7b4627 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RangeTransition\");\n    }\n    start;\n    stop;\n    #label = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n    constructor(target, start, stop){\n        super(target);\n        this.start = start;\n        this.stop = stop;\n        this.#label.addRange(start, stop);\n    }\n    get label() {\n        return this.#label;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.RANGE;\n    }\n    matches(symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n};\n// src/atn/ActionTransition.ts\nvar $c1efbdb2cbf46748$export$56d58b5b6c0e2f81 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ActionTransition\");\n    }\n    ruleIndex;\n    actionIndex;\n    isCtxDependent;\n    constructor(target, ruleIndex, actionIndex, isCtxDependent){\n        super(target);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex ?? -1;\n        this.isCtxDependent = isCtxDependent ?? false;\n    }\n    get isEpsilon() {\n        return true;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.ACTION;\n    }\n    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return false;\n    }\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n};\n// src/atn/EpsilonTransition.ts\nvar $c1efbdb2cbf46748$export$a59e0290d2db6277 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"EpsilonTransition\");\n    }\n    #outermostPrecedenceReturn;\n    constructor(target, outermostPrecedenceReturn = -1){\n        super(target);\n        this.#outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n    /**\n   * @returns the rule index of a precedence rule for which this transition is\n   * returning from, where the precedence value is 0; otherwise, -1.\n   *\n   * @see ATNConfig.isPrecedenceFilterSuppressed()\n   * @see ParserATNSimulator.applyPrecedenceFilter(ATNConfigSet)\n   * @since 4.4.1\n   */ get outermostPrecedenceReturn() {\n        return this.#outermostPrecedenceReturn;\n    }\n    get isEpsilon() {\n        return true;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.EPSILON;\n    }\n    matches() {\n        return false;\n    }\n    toString() {\n        return \"epsilon\";\n    }\n};\n// src/atn/WildcardTransition.ts\nvar $c1efbdb2cbf46748$export$6c899f6a62150677 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"WildcardTransition\");\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.WILDCARD;\n    }\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n    toString() {\n        return \".\";\n    }\n};\n// src/atn/AbstractPredicateTransition.ts\nvar $c1efbdb2cbf46748$export$9c060788e1247c64 = class extends $c1efbdb2cbf46748$export$be58926105124dd4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"AbstractPredicateTransition\");\n    }\n    constructor(target){\n        super(target);\n    }\n};\n// src/atn/PredicateTransition.ts\nvar $c1efbdb2cbf46748$export$5cb5e35f9f7e22cb = class extends $c1efbdb2cbf46748$export$9c060788e1247c64 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PredicateTransition\");\n    }\n    ruleIndex;\n    predIndex;\n    isCtxDependent;\n    // e.g., $i ref in pred\n    constructor(target, ruleIndex, predIndex, isCtxDependent){\n        super(target);\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent;\n    }\n    get isEpsilon() {\n        return true;\n    }\n    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return false;\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE;\n    }\n    getPredicate() {\n        return new $c1efbdb2cbf46748$export$946e3ad1112f0fcb.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n};\n// src/atn/PrecedencePredicateTransition.ts\nvar $c1efbdb2cbf46748$export$60837bdbee1d005a = class extends $c1efbdb2cbf46748$export$9c060788e1247c64 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PrecedencePredicateTransition\");\n    }\n    precedence;\n    constructor(target, precedence){\n        super(target);\n        this.precedence = precedence;\n    }\n    get isEpsilon() {\n        return true;\n    }\n    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n        return false;\n    }\n    getPredicate() {\n        return new $c1efbdb2cbf46748$export$946e3ad1112f0fcb.PrecedencePredicate(this.precedence);\n    }\n    get transitionType() {\n        return $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE;\n    }\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n};\n// src/atn/LexerActionType.ts\nvar $c1efbdb2cbf46748$export$bbd0ef59939b8ebe = {\n    /** The type of a {@link LexerChannelAction} action. */ CHANNEL: 0,\n    /** The type of a {@link LexerCustomAction} action */ CUSTOM: 1,\n    /** The type of a {@link LexerModeAction} action. */ MODE: 2,\n    /** The type of a {@link LexerMoreAction} action. */ MORE: 3,\n    /** The type of a {@link LexerPopModeAction} action. */ POP_MODE: 4,\n    /** The type of a {@link LexerPushModeAction} action. */ PUSH_MODE: 5,\n    /** The type of a {@link LexerSkipAction} action. */ SKIP: 6,\n    /** The type of a {@link LexerTypeAction} action. */ TYPE: 7\n};\n// src/atn/LexerSkipAction.ts\nvar $c1efbdb2cbf46748$export$842feb98d9f55ed6 = class _LexerSkipAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerSkipAction\");\n    }\n    /** Provides a singleton instance of this parameter-less lexer action. */ static instance = new _LexerSkipAction();\n    actionType;\n    isPositionDependent = false;\n    constructor(){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.SKIP;\n    }\n    equals(obj) {\n        return obj === this;\n    }\n    hashCode() {\n        return $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.SKIP;\n    }\n    execute(lexer) {\n        lexer.skip();\n    }\n    toString() {\n        return \"skip\";\n    }\n};\n// src/atn/LexerChannelAction.ts\nvar $c1efbdb2cbf46748$export$71cca5a94cb644c7 = class _LexerChannelAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerChannelAction\");\n    }\n    channel;\n    actionType;\n    isPositionDependent = false;\n    cachedHashCode;\n    constructor(channel){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CHANNEL;\n        this.channel = channel;\n    }\n    /**\n   * This action is implemented by calling {@link Lexer.setChannel} with the\n   * value provided by {@link getChannel}.\n   */ execute(lexer) {\n        lexer.channel = this.channel;\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionType);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.channel);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerChannelAction)) return false;\n        return this.channel === other.channel;\n    }\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n};\n// src/atn/LexerCustomAction.ts\nvar $c1efbdb2cbf46748$export$25fe59d2129b8548 = class _LexerCustomAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerCustomAction\");\n    }\n    ruleIndex;\n    actionIndex;\n    actionType;\n    isPositionDependent = true;\n    cachedHashCode;\n    /**\n   * Constructs a custom lexer action with the specified rule and action indexes.\n   *\n   * @param ruleIndex The rule index to use for calls to {@link Recognizer.action}.\n   * @param actionIndex The action index to use for calls to {@link Recognizer.action}.\n   */ constructor(ruleIndex, actionIndex){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CUSTOM;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n    }\n    /**\n   * Custom actions are implemented by calling {@link Lexer.action} with the\n   * appropriate rule and action indexes.\n   */ execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionType);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.ruleIndex);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionIndex);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 3);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerCustomAction)) return false;\n        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n    }\n};\n// src/atn/LexerMoreAction.ts\nvar $c1efbdb2cbf46748$export$c4effa542afc3183 = class _LexerMoreAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerMoreAction\");\n    }\n    static instance = new _LexerMoreAction();\n    actionType;\n    isPositionDependent = false;\n    constructor(){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MORE;\n    }\n    equals(obj) {\n        return obj === this;\n    }\n    hashCode() {\n        return $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MORE;\n    }\n    /**\n   * This action is implemented by calling {@link Lexer.popMode}.\n   */ execute(lexer) {\n        lexer.more();\n    }\n    toString() {\n        return \"more\";\n    }\n};\n// src/atn/LexerTypeAction.ts\nvar $c1efbdb2cbf46748$export$f63d91da13fce1b8 = class _LexerTypeAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerTypeAction\");\n    }\n    type;\n    actionType;\n    isPositionDependent = false;\n    cachedHashCode;\n    constructor(type){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.TYPE;\n        this.type = type;\n    }\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionType);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.type);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerTypeAction)) return false;\n        return this.type === other.type;\n    }\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n};\n// src/atn/LexerPushModeAction.ts\nvar $c1efbdb2cbf46748$export$216fde1331e53997 = class _LexerPushModeAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerPushModeAction\");\n    }\n    mode;\n    actionType;\n    isPositionDependent = false;\n    cachedHashCode;\n    constructor(mode){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.PUSH_MODE;\n        this.mode = mode;\n    }\n    /**\n   * This action is implemented by calling {@link Lexer.pushMode} with the\n   * value provided by {@link getMode}.\n   */ execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionType);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.mode);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerPushModeAction)) return false;\n        return this.mode === other.mode;\n    }\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n};\n// src/atn/LexerPopModeAction.ts\nvar $c1efbdb2cbf46748$export$229e5f08dbd6272f = class _LexerPopModeAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerPopModeAction\");\n    }\n    static instance = new _LexerPopModeAction();\n    actionType;\n    isPositionDependent = false;\n    constructor(){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.POP_MODE;\n    }\n    equals(obj) {\n        return obj === this;\n    }\n    hashCode() {\n        return $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.POP_MODE;\n    }\n    /**\n   * This action is implemented by calling {@link Lexer//popMode}.\n   */ execute(lexer) {\n        lexer.popMode();\n    }\n    toString() {\n        return \"popMode\";\n    }\n};\n// src/atn/LexerModeAction.ts\nvar $c1efbdb2cbf46748$export$cdb18c047c6321c6 = class _LexerModeAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerModeAction\");\n    }\n    mode;\n    actionType;\n    isPositionDependent = false;\n    cachedHashCode;\n    constructor(mode){\n        this.actionType = $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MODE;\n        this.mode = mode;\n    }\n    /**\n   * This action is implemented by calling {@link Lexer.mode} with the\n   * value provided by {@link getMode}.\n   */ execute(lexer) {\n        lexer.mode = this.mode;\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.actionType);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.mode);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerModeAction)) return false;\n        return this.mode === other.mode;\n    }\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n};\n// src/atn/ATNDeserializer.ts\nvar $c1efbdb2cbf46748$export$8d551c119323a3a7 = class _ATNDeserializer {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNDeserializer\");\n    }\n    static SERIALIZED_VERSION = 4;\n    static stateTypeMapper = /* @__PURE__ */ new Map([\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.INVALID_TYPE,\n            void 0\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.BASIC,\n            $c1efbdb2cbf46748$export$a24717045da89386\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_START,\n            $c1efbdb2cbf46748$export$d69d85a987fddbef\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_START,\n            $c1efbdb2cbf46748$export$6c4b09c827e3821\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_BLOCK_START,\n            $c1efbdb2cbf46748$export$4b53728d66f9971c\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_BLOCK_START,\n            $c1efbdb2cbf46748$export$9162e345fad804f4\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.TOKEN_START,\n            $c1efbdb2cbf46748$export$c7815420e454fdf8\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP,\n            $c1efbdb2cbf46748$export$ba787240acf6572c\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_END,\n            $c1efbdb2cbf46748$export$ef7d128af4cd29f\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_BACK,\n            $c1efbdb2cbf46748$export$29739011cda0b11b\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_ENTRY,\n            $c1efbdb2cbf46748$export$d8a6440f35eed376\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_LOOP_BACK,\n            $c1efbdb2cbf46748$export$5f5ea071b7e146fe\n        ],\n        [\n            $c1efbdb2cbf46748$export$21a6260de0fddd55.LOOP_END,\n            $c1efbdb2cbf46748$export$8ff967d5b8bcca40\n        ]\n    ]);\n    static lexerActionFactoryMapper = /* @__PURE__ */ new Map([\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CHANNEL,\n            (data1)=>{\n                return new $c1efbdb2cbf46748$export$71cca5a94cb644c7(data1);\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CUSTOM,\n            (data1, data2)=>{\n                return new $c1efbdb2cbf46748$export$25fe59d2129b8548(data1, data2);\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MODE,\n            (data1)=>{\n                return new $c1efbdb2cbf46748$export$cdb18c047c6321c6(data1);\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MORE,\n            ()=>{\n                return $c1efbdb2cbf46748$export$c4effa542afc3183.instance;\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.POP_MODE,\n            ()=>{\n                return $c1efbdb2cbf46748$export$229e5f08dbd6272f.instance;\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.PUSH_MODE,\n            (data1)=>{\n                return new $c1efbdb2cbf46748$export$216fde1331e53997(data1);\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.SKIP,\n            ()=>{\n                return $c1efbdb2cbf46748$export$842feb98d9f55ed6.instance;\n            }\n        ],\n        [\n            $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.TYPE,\n            (data1)=>{\n                return new $c1efbdb2cbf46748$export$f63d91da13fce1b8(data1);\n            }\n        ]\n    ]);\n    data = [];\n    pos = 0;\n    deserializationOptions;\n    actionFactories;\n    constructor(options){\n        if (!options) options = {\n            readOnly: false,\n            verifyATN: true,\n            generateRuleBypassTransitions: false\n        };\n        this.deserializationOptions = options;\n    }\n    deserialize(data) {\n        this.data = data;\n        this.checkVersion();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        this.readSets(atn, sets);\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.PARSER) {\n            this.generateRuleBypassTransitions(atn);\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n    checkVersion() {\n        const version = this.data[this.pos++];\n        if (version !== _ATNDeserializer.SERIALIZED_VERSION) throw new Error(\"Could not deserialize ATN with version \" + version + \" (expected \" + _ATNDeserializer.SERIALIZED_VERSION + \").\");\n    }\n    readATN() {\n        const grammarType = this.data[this.pos++];\n        const maxTokenType = this.data[this.pos++];\n        return new $c1efbdb2cbf46748$export$ffe90c5f202db011(grammarType, maxTokenType);\n    }\n    readStates(atn) {\n        let j;\n        let stateNumber;\n        const loopBackStateNumbers = [];\n        const endStateNumbers = [];\n        const stateCount = this.data[this.pos++];\n        for(let i = 0; i < stateCount; i++){\n            const stateType = this.data[this.pos++];\n            if (stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            const ruleIndex = this.data[this.pos++];\n            const s = this.stateFactory(stateType, ruleIndex);\n            if (stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.LOOP_END) {\n                const loopBackStateNumber = this.data[this.pos++];\n                loopBackStateNumbers.push([\n                    s,\n                    loopBackStateNumber\n                ]);\n            } else if (s instanceof $c1efbdb2cbf46748$export$47d3f79353fa3139) {\n                const endStateNumber = this.data[this.pos++];\n                endStateNumbers.push([\n                    s,\n                    endStateNumber\n                ]);\n            }\n            atn.addState(s);\n        }\n        for(j = 0; j < loopBackStateNumbers.length; j++){\n            const pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]] ?? void 0;\n        }\n        for(j = 0; j < endStateNumbers.length; j++){\n            const pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n        const numNonGreedyStates = this.data[this.pos++];\n        for(j = 0; j < numNonGreedyStates; j++){\n            stateNumber = this.data[this.pos++];\n            atn.states[stateNumber].nonGreedy = true;\n        }\n        const numPrecedenceStates = this.data[this.pos++];\n        for(j = 0; j < numPrecedenceStates; j++){\n            stateNumber = this.data[this.pos++];\n            atn.states[stateNumber].isLeftRecursiveRule = true;\n        }\n    }\n    readRules(atn) {\n        let i;\n        const ruleCount = this.data[this.pos++];\n        if (atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) {\n            atn.ruleToTokenType = new Array(ruleCount);\n            atn.ruleToTokenType.fill(0);\n        }\n        atn.ruleToStartState = new Array(ruleCount);\n        atn.ruleToStartState.fill(null);\n        for(i = 0; i < ruleCount; i++){\n            const s = this.data[this.pos++];\n            atn.ruleToStartState[i] = atn.states[s];\n            if (atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) {\n                const tokenType = this.data[this.pos++];\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = new Array(ruleCount);\n        atn.ruleToStopState.fill(null);\n        for(i = 0; i < atn.states.length; i++){\n            const state = atn.states[i];\n            if (!(state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c)) continue;\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n    readModes(atn) {\n        const modeCount = this.data[this.pos++];\n        for(let i = 0; i < modeCount; i++){\n            const s = this.data[this.pos++];\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n    readSets(atn, sets) {\n        const m2 = this.data[this.pos++];\n        for(let i = 0; i < m2; i++){\n            const intervalSet = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n            sets.push(intervalSet);\n            const n2 = this.data[this.pos++];\n            const containsEof = this.data[this.pos++];\n            if (containsEof !== 0) intervalSet.addOne(-1);\n            for(let j = 0; j < n2; j++){\n                const i1 = this.data[this.pos++];\n                const i2 = this.data[this.pos++];\n                intervalSet.addRange(i1, i2);\n            }\n        }\n    }\n    readEdges(atn, sets) {\n        let i;\n        let j;\n        let state;\n        let trans;\n        let target;\n        const edgeCount = this.data[this.pos++];\n        for(i = 0; i < edgeCount; i++){\n            const src = this.data[this.pos++];\n            const trg = this.data[this.pos++];\n            const ttype = this.data[this.pos++];\n            const arg1 = this.data[this.pos++];\n            const arg2 = this.data[this.pos++];\n            const arg3 = this.data[this.pos++];\n            trans = this.edgeFactory(atn, ttype, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        for(i = 0; i < atn.states.length; i++){\n            state = atn.states[i];\n            for(j = 0; j < state.transitions.length; j++){\n                const t = state.transitions[j];\n                if (!(t instanceof $c1efbdb2cbf46748$export$5a1cda5a00fd126)) continue;\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isLeftRecursiveRule) {\n                    if (t.precedence === 0) outermostPrecedenceReturn = t.target.ruleIndex;\n                }\n                trans = new $c1efbdb2cbf46748$export$a59e0290d2db6277(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n        for(i = 0; i < atn.states.length; i++){\n            state = atn.states[i];\n            if (state instanceof $c1efbdb2cbf46748$export$47d3f79353fa3139) {\n                if (!state.endState) throw new Error(\"IllegalState\");\n                if (state.endState.startState) throw new Error(\"IllegalState\");\n                state.endState.startState = state;\n            }\n            if (state instanceof $c1efbdb2cbf46748$export$5f5ea071b7e146fe) for(j = 0; j < state.transitions.length; j++){\n                target = state.transitions[j].target;\n                if (target instanceof $c1efbdb2cbf46748$export$4b53728d66f9971c) target.loopBackState = state;\n            }\n            else if (state instanceof $c1efbdb2cbf46748$export$29739011cda0b11b) for(j = 0; j < state.transitions.length; j++){\n                target = state.transitions[j].target;\n                if (target instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376) target.loopBackState = state;\n            }\n        }\n    }\n    readDecisions(atn) {\n        const decisionCount = this.data[this.pos++];\n        for(let i = 0; i < decisionCount; i++){\n            const s = this.data[this.pos++];\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n    readLexerActions(atn) {\n        if (atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) {\n            const count = this.data[this.pos++];\n            atn.lexerActions = [];\n            for(let i = 0; i < count; i++){\n                const actionType = this.data[this.pos++];\n                const data1 = this.data[this.pos++];\n                const data2 = this.data[this.pos++];\n                atn.lexerActions.push(this.lexerActionFactory(actionType, data1, data2));\n            }\n        }\n    }\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i = 0; i < count; i++)atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        for(i = 0; i < count; i++)this.generateRuleBypassTransition(atn, i);\n    }\n    generateRuleBypassTransition(atn, idx) {\n        let i;\n        let state;\n        const bypassStart = new $c1efbdb2cbf46748$export$6c4b09c827e3821();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n        const bypassStop = new $c1efbdb2cbf46748$export$ef7d128af4cd29f();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n        bypassStop.startState = bypassStart;\n        let excludeTransition = null;\n        let endState = null;\n        if (atn.ruleToStartState[idx].isLeftRecursiveRule) {\n            endState = null;\n            for(i = 0; i < atn.states.length; i++){\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) throw new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\n        } else endState = atn.ruleToStopState[idx];\n        for(i = 0; i < atn.states.length; i++){\n            state = atn.states[i];\n            for (const transition of state.transitions){\n                if (transition === excludeTransition) continue;\n                if (transition.target === endState) transition.target = bypassStop;\n            }\n        }\n        const ruleToStartState = atn.ruleToStartState[idx];\n        while(ruleToStartState.transitions.length > 0){\n            const transition = ruleToStartState.removeTransition(ruleToStartState.transitions.length - 1);\n            bypassStart.addTransition(transition);\n        }\n        atn.ruleToStartState[idx].addTransition(new $c1efbdb2cbf46748$export$a59e0290d2db6277(bypassStart));\n        if (endState) bypassStop.addTransition(new $c1efbdb2cbf46748$export$a59e0290d2db6277(endState));\n        const matchState = new $c1efbdb2cbf46748$export$a24717045da89386();\n        atn.addState(matchState);\n        matchState.addTransition(new $c1efbdb2cbf46748$export$749c9accb19d603f(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new $c1efbdb2cbf46748$export$a59e0290d2db6277(matchState));\n    }\n    stateIsEndStateFor(state, idx) {\n        if (state.ruleIndex !== idx) return null;\n        if (!(state instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376)) return null;\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!(maybeLoopEndState instanceof $c1efbdb2cbf46748$export$8ff967d5b8bcca40)) return null;\n        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) return state;\n        else return null;\n    }\n    /**\n   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n   * the {@link StarLoopEntryState} field to the correct value.\n   *\n   * @param atn The ATN.\n   */ markPrecedenceDecisions(atn) {\n        for (const state of atn.states){\n            if (!(state instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376)) continue;\n            if (atn.ruleToStartState[state.ruleIndex].isLeftRecursiveRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof $c1efbdb2cbf46748$export$8ff967d5b8bcca40) {\n                    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) state.precedenceRuleDecision = true;\n                }\n            }\n        }\n    }\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) return;\n        for (const state of atn.states){\n            if (state === null) continue;\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof $c1efbdb2cbf46748$export$4b53728d66f9971c) this.checkCondition(state.loopBackState !== null);\n            else if (state instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof $c1efbdb2cbf46748$export$9162e345fad804f4) {\n                    this.checkCondition(state.transitions[1].target instanceof $c1efbdb2cbf46748$export$8ff967d5b8bcca40);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof $c1efbdb2cbf46748$export$8ff967d5b8bcca40) {\n                    this.checkCondition(state.transitions[1].target instanceof $c1efbdb2cbf46748$export$9162e345fad804f4);\n                    this.checkCondition(state.nonGreedy);\n                } else throw new Error(\"IllegalState\");\n            } else if (state instanceof $c1efbdb2cbf46748$export$29739011cda0b11b) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376);\n            } else if (state instanceof $c1efbdb2cbf46748$export$8ff967d5b8bcca40) this.checkCondition(state.loopBackState !== null);\n            else if (state instanceof $c1efbdb2cbf46748$export$d69d85a987fddbef) this.checkCondition(state.stopState !== null);\n            else if (state instanceof $c1efbdb2cbf46748$export$47d3f79353fa3139) this.checkCondition(state.endState !== null);\n            else if (state instanceof $c1efbdb2cbf46748$export$ef7d128af4cd29f) this.checkCondition(state.startState !== null);\n            else if (state instanceof $c1efbdb2cbf46748$export$546c00a8fe1b4d1a) this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            else this.checkCondition(state.transitions.length <= 1 || state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c);\n        }\n    }\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === void 0 || message === null) message = \"IllegalState\";\n            throw message;\n        }\n    }\n    edgeFactory(atn, type, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type){\n            case $c1efbdb2cbf46748$export$be58926105124dd4.EPSILON:\n                return new $c1efbdb2cbf46748$export$a59e0290d2db6277(target);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RANGE:\n                return arg3 !== 0 ? new $c1efbdb2cbf46748$export$87d1473c8b7b4627(target, $c1efbdb2cbf46748$export$50792b0e93539fde.EOF, arg2) : new $c1efbdb2cbf46748$export$87d1473c8b7b4627(target, arg1, arg2);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RULE:\n                return new $c1efbdb2cbf46748$export$5a1cda5a00fd126(atn.states[arg1], arg2, arg3, target);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE:\n                return new $c1efbdb2cbf46748$export$5cb5e35f9f7e22cb(target, arg1, arg2, arg3 !== 0);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE:\n                return new $c1efbdb2cbf46748$export$60837bdbee1d005a(target, arg1);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ATOM:\n                return arg3 !== 0 ? new $c1efbdb2cbf46748$export$749c9accb19d603f(target, $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) : new $c1efbdb2cbf46748$export$749c9accb19d603f(target, arg1);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ACTION:\n                return new $c1efbdb2cbf46748$export$56d58b5b6c0e2f81(target, arg1, arg2, arg3 !== 0);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.SET:\n                return new $c1efbdb2cbf46748$export$10de5c396f79e800(target, sets[arg1]);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.NOT_SET:\n                return new $c1efbdb2cbf46748$export$a0e4d5a57a08628e(target, sets[arg1]);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.WILDCARD:\n                return new $c1efbdb2cbf46748$export$6c899f6a62150677(target);\n            default:\n                throw new Error(\"The specified transition type: \" + type + \" is not valid.\");\n        }\n    }\n    stateFactory(type, ruleIndex) {\n        const ctor = _ATNDeserializer.stateTypeMapper.get(type);\n        if (!ctor) throw new Error(\"The specified state type \" + type + \" is not valid.\");\n        const s = new ctor();\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n    lexerActionFactory(type, data1, data2) {\n        const factory = _ATNDeserializer.lexerActionFactoryMapper.get(type);\n        if (!factory) throw new Error(\"The specified lexer action type \" + type + \" is not valid.\");\n        return factory(data1, data2);\n    }\n};\n// src/misc/OrderedHashMap.ts\nvar $c1efbdb2cbf46748$export$6fcf45964b87cc59 = class _OrderedHashMap extends $c1efbdb2cbf46748$export$60ef0b43d585640a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"OrderedHashMap\");\n    }\n    #keys = [];\n    clear() {\n        super.clear();\n        this.#keys = [];\n    }\n    get(key) {\n        return super.get(key);\n    }\n    set(key, value) {\n        const result = super.set(key, value);\n        if (result === void 0) this.#keys.push(key);\n        return result;\n    }\n    setIfAbsent(key, value) {\n        const result = super.setIfAbsent(key, value);\n        if (result === void 0) this.#keys.push(key);\n        return result;\n    }\n    /**\n   * @returns an iterable of the values in the map, in the order they were inserted.\n   */ values() {\n        return {\n            [Symbol.iterator]: ()=>{\n                let index = 0;\n                return {\n                    next: /* @__PURE__ */ $c1efbdb2cbf46748$var$__name(()=>{\n                        if (index < this.#keys.length) return {\n                            done: false,\n                            value: super.get(this.#keys[index++])\n                        };\n                        return {\n                            done: true,\n                            value: void 0\n                        };\n                    }, \"next\")\n                };\n            }\n        };\n    }\n    /**\n   * @returns an iterable of the keys in the map, in the order they were inserted.\n   */ keys() {\n        return this.#keys[Symbol.iterator]();\n    }\n    equals(o) {\n        if (!(o instanceof _OrderedHashMap)) return false;\n        return super.equals(o);\n    }\n};\n// src/atn/ATNSerializer.ts\nvar $c1efbdb2cbf46748$export$fc084eb707ff5440 = class _ATNSerializer {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNSerializer\");\n    }\n    atn;\n    data = [];\n    // Note that we use a LinkedHashMap as a set to maintain insertion order while deduplicating entries with the\n    // same key.\n    sets = new $c1efbdb2cbf46748$export$6fcf45964b87cc59($c1efbdb2cbf46748$var$ObjectEqualityComparator.instance);\n    nonGreedyStates = [];\n    precedenceStates = [];\n    constructor(atn){\n        this.atn = atn;\n    }\n    static getSerialized(atn) {\n        return new _ATNSerializer(atn).serialize();\n    }\n    static serializeSets(data, sets) {\n        data.push(sets.length);\n        for (const set of sets){\n            const containsEof = set.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EOF);\n            const intervals = [\n                ...set\n            ];\n            if (containsEof && intervals[0].stop === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) data.push(intervals.length - 1);\n            else data.push(intervals.length);\n            data.push(containsEof ? 1 : 0);\n            for (const interval of intervals){\n                if (interval.start === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                    if (interval.stop === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) continue;\n                    else data.push(0);\n                } else data.push(interval.start);\n                data.push(interval.stop);\n            }\n        }\n    }\n    /**\n   * Serialize state descriptors, edge descriptors, and decision -> state map\n   *  into list of ints.  Likely out of date, but keeping as it could be helpful:\n   *\n   *      SERIALIZED_VERSION\n   *      UUID (2 longs)\n   * \t\tgrammar-type, (ANTLRParser.LEXER, ...)\n   *  \tmax token type,\n   *  \tnum states,\n   *  \tstate-0-type ruleIndex, state-1-type ruleIndex, ... state-i-type ruleIndex optional-arg ...\n   *  \tnum rules,\n   *  \trule-1-start-state rule-1-args, rule-2-start-state  rule-2-args, ...\n   *  \t(args are token type,actionIndex in lexer else 0,0)\n   *      num modes,\n   *      mode-0-start-state, mode-1-start-state, ... (parser has 0 modes)\n   *      num unicode-bmp-sets\n   *      bmp-set-0-interval-count intervals, bmp-set-1-interval-count intervals, ...\n   *      num unicode-smp-sets\n   *      smp-set-0-interval-count intervals, smp-set-1-interval-count intervals, ...\n   *\tnum total edges,\n   *      src, trg, edge-type, edge arg1, optional edge arg2 (present always), ...\n   *      num decisions,\n   *      decision-0-start-state, decision-1-start-state, ...\n   *\n   *  Convenient to pack into unsigned shorts to make as Java string.\n   */ serialize() {\n        this.addPreamble();\n        const edgeCount = this.addEdges();\n        this.addNonGreedyStates();\n        this.addPrecedenceStates();\n        this.addRuleStatesAndLexerTokenTypes();\n        this.addModeStartStates();\n        const setIndices = this.addSets();\n        this.addEdges(edgeCount, setIndices);\n        this.addDecisionStartStates();\n        this.addLexerActions();\n        return this.data;\n    }\n    addPreamble() {\n        this.data.push($c1efbdb2cbf46748$export$8d551c119323a3a7.SERIALIZED_VERSION);\n        this.data.push(this.atn.grammarType);\n        this.data.push(this.atn.maxTokenType);\n    }\n    addLexerActions() {\n        if (this.atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) {\n            this.data.push(this.atn.lexerActions.length);\n            for (const action of this.atn.lexerActions){\n                this.data.push(action.actionType);\n                switch(action.actionType){\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CHANNEL:\n                        {\n                            const channel = action.channel;\n                            this.data.push(channel);\n                            this.data.push(0);\n                            break;\n                        }\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.CUSTOM:\n                        {\n                            const ruleIndex = action.ruleIndex;\n                            const actionIndex = action.actionIndex;\n                            this.data.push(ruleIndex);\n                            this.data.push(actionIndex);\n                            break;\n                        }\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MODE:\n                        {\n                            const mode = action.mode;\n                            this.data.push(mode);\n                            this.data.push(0);\n                            break;\n                        }\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.MORE:\n                        this.data.push(0);\n                        this.data.push(0);\n                        break;\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.POP_MODE:\n                        this.data.push(0);\n                        this.data.push(0);\n                        break;\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.PUSH_MODE:\n                        {\n                            const mode = action.mode;\n                            this.data.push(mode);\n                            this.data.push(0);\n                            break;\n                        }\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.SKIP:\n                        this.data.push(0);\n                        this.data.push(0);\n                        break;\n                    case $c1efbdb2cbf46748$export$bbd0ef59939b8ebe.TYPE:\n                        {\n                            const type = action.type;\n                            this.data.push(type);\n                            this.data.push(0);\n                            break;\n                        }\n                    default:\n                        throw new Error(`The specified lexer action type ${action.actionType} is not valid.`);\n                }\n            }\n        }\n    }\n    addDecisionStartStates() {\n        this.data.push(this.atn.decisionToState.length);\n        for (const decStartState of this.atn.decisionToState)this.data.push(decStartState.stateNumber);\n    }\n    addEdges(...args) {\n        switch(args.length){\n            case 0:\n                {\n                    let edgeCount = 0;\n                    this.data.push(this.atn.states.length);\n                    for (const s of this.atn.states){\n                        if (s === null) {\n                            this.data.push($c1efbdb2cbf46748$export$21a6260de0fddd55.INVALID_TYPE);\n                            continue;\n                        }\n                        const stateType = s.constructor.stateType;\n                        if (s instanceof $c1efbdb2cbf46748$export$546c00a8fe1b4d1a && s.nonGreedy) this.nonGreedyStates.push(s.stateNumber);\n                        if (s instanceof $c1efbdb2cbf46748$export$d69d85a987fddbef && s.isLeftRecursiveRule) this.precedenceStates.push(s.stateNumber);\n                        this.data.push(stateType);\n                        this.data.push(s.ruleIndex);\n                        if (s.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.LOOP_END) this.data.push(s.loopBackState.stateNumber);\n                        else if (s instanceof $c1efbdb2cbf46748$export$47d3f79353fa3139) this.data.push(s.endState.stateNumber);\n                        if (s.constructor.stateType !== $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) edgeCount += s.transitions.length;\n                        for (const t of s.transitions){\n                            const edgeType = t.transitionType;\n                            if (edgeType === $c1efbdb2cbf46748$export$be58926105124dd4.SET || edgeType === $c1efbdb2cbf46748$export$be58926105124dd4.NOT_SET) {\n                                const st = t;\n                                this.sets.set(st.set, true);\n                            }\n                        }\n                    }\n                    return edgeCount;\n                }\n            case 2:\n                {\n                    const [edgeCount, setIndices] = args;\n                    this.data.push(edgeCount);\n                    for (const s of this.atn.states){\n                        if (s === null) continue;\n                        if (s.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) continue;\n                        for (const t of s.transitions){\n                            if (this.atn.states[t.target.stateNumber] === null) throw new Error(\"Cannot serialize a transition to a removed state.\");\n                            const src = s.stateNumber;\n                            let trg = t.target.stateNumber;\n                            const edgeType = t.transitionType;\n                            let arg1 = 0;\n                            let arg2 = 0;\n                            let arg3 = 0;\n                            switch(edgeType){\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.RULE:\n                                    trg = t.followState.stateNumber;\n                                    arg1 = t.target.stateNumber;\n                                    arg2 = t.ruleIndex;\n                                    arg3 = t.precedence;\n                                    break;\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE:\n                                    {\n                                        const ppt = t;\n                                        arg1 = ppt.precedence;\n                                        break;\n                                    }\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE:\n                                    {\n                                        const pt = t;\n                                        arg1 = pt.ruleIndex;\n                                        arg2 = pt.predIndex;\n                                        arg3 = pt.isCtxDependent ? 1 : 0;\n                                        break;\n                                    }\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.RANGE:\n                                    arg1 = t.start;\n                                    arg2 = t.stop;\n                                    if (arg1 === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                                        arg1 = 0;\n                                        arg3 = 1;\n                                    }\n                                    break;\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.ATOM:\n                                    arg1 = t.labelValue;\n                                    if (arg1 === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                                        arg1 = 0;\n                                        arg3 = 1;\n                                    }\n                                    break;\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.ACTION:\n                                    {\n                                        const at = t;\n                                        arg1 = at.ruleIndex;\n                                        arg2 = at.actionIndex;\n                                        arg3 = at.isCtxDependent ? 1 : 0;\n                                        break;\n                                    }\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.SET:\n                                    arg1 = setIndices.get(t.set);\n                                    break;\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.NOT_SET:\n                                    arg1 = setIndices.get(t.set);\n                                    break;\n                                case $c1efbdb2cbf46748$export$be58926105124dd4.WILDCARD:\n                                    break;\n                                default:\n                            }\n                            this.data.push(src);\n                            this.data.push(trg);\n                            this.data.push(edgeType);\n                            this.data.push(arg1);\n                            this.data.push(arg2);\n                            this.data.push(arg3);\n                        }\n                    }\n                    break;\n                }\n            default:\n                throw new Error(\"Invalid number of arguments\");\n        }\n    }\n    addSets() {\n        _ATNSerializer.serializeSets(this.data, [\n            ...this.sets.keys()\n        ]);\n        const setIndices = new $c1efbdb2cbf46748$export$60ef0b43d585640a();\n        let setIndex = 0;\n        for (const s of this.sets.keys())setIndices.set(s, setIndex++);\n        return setIndices;\n    }\n    addModeStartStates() {\n        const modeCount = this.atn.modeToStartState.length;\n        this.data.push(modeCount);\n        if (modeCount > 0) for (const modeStartState of this.atn.modeToStartState)this.data.push(modeStartState.stateNumber);\n    }\n    addRuleStatesAndLexerTokenTypes() {\n        const ruleCount = this.atn.ruleToStartState.length;\n        this.data.push(ruleCount);\n        for(let r = 0; r < ruleCount; r++){\n            const ruleStartState = this.atn.ruleToStartState[r];\n            this.data.push(ruleStartState.stateNumber);\n            if (this.atn.grammarType === $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) this.data.push(this.atn.ruleToTokenType[r]);\n        }\n    }\n    addPrecedenceStates() {\n        this.data.push(this.precedenceStates.length);\n        for (const state of this.precedenceStates)this.data.push(state);\n    }\n    addNonGreedyStates() {\n        this.data.push(this.nonGreedyStates.length);\n        for (const state of this.nonGreedyStates)this.data.push(state);\n    }\n};\n// src/dfa/DFAState.ts\nvar $c1efbdb2cbf46748$export$61470cd35b9c4833 = class _DFAState {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DFAState\");\n    }\n    stateNumber = -1;\n    configs;\n    /**\n   * `edges[symbol]` points to target of symbol. Shift up by 1 so (-1) {@link Token.EOF} maps to `edges[0]`.\n   */ edges = [];\n    isAcceptState = false;\n    /**\n   * If accept state, what ttype do we match or alt do we predict? This is set to {@link ATN.INVALID_ALT_NUMBER}\n   * when {@link predicates} `!= null` or {@link requiresFullContext}.\n   */ prediction = -1;\n    lexerActionExecutor = null;\n    /**\n   * Indicates that this state was created during SLL prediction that discovered a conflict between the configurations\n   * in the state. Future {@link ParserATNSimulator.execATN} invocations immediately jumped doing\n   * full context prediction if this field is true.\n   */ requiresFullContext = false;\n    /**\n   * During SLL parsing, this is a list of predicates associated with the ATN configurations of the DFA state.\n   * When we have predicates, {@link requiresFullContext} is `false` since full context prediction evaluates\n   * predicates on-the-fly. If this is not null, then {@link prediction} is `ATN.INVALID_ALT_NUMBER`.\n   *\n   * We only use these for non-{@link #requiresFullContext} but conflicting states. That\n   * means we know from the context (it's $ or we don't dip into outer\n   * context) that it's an ambiguity not a conflict.\n   *\n   * This list is computed by {@link ParserATNSimulator#predicateDFAState}.\n   */ predicates = null;\n    constructor(configs){\n        if (configs) this.configs = configs;\n    }\n    static fromState(stateNumber) {\n        const result = new _DFAState();\n        result.stateNumber = stateNumber;\n        return result;\n    }\n    static fromConfigs(configs) {\n        return new _DFAState(configs);\n    }\n    static hashCode(state) {\n        return state.configs.hashCode();\n    }\n    /**\n   * Two {@link DFAState} instances are equal if their ATN configuration sets\n   * are the same. This method is used to see if a state already exists.\n   *\n   * Because the number of alternatives and number of ATN configurations are\n   * finite, there is a finite number of DFA states that can be processed.\n   * This is necessary to show that the algorithm terminates.\n   *\n   * Cannot test the DFA state numbers here because in\n   * {@link ParserATNSimulator#addDFAState} we need to know if any other state\n   * exists that has this exact set of ATN configurations. The\n   * {@link #stateNumber} is irrelevant.\n   *\n   * @param a The first {@link DFAState}.\n   * @param b The second {@link DFAState}.\n   *\n   * @returns `true` if the two states are equal, otherwise `false`.\n   */ static equals(a, b) {\n        return a.configs.equals(b.configs);\n    }\n    /**\n   * @returns the set of all alts mentioned by all ATN configurations in this DFA state.\n   */ getAltSet() {\n        const alts = /* @__PURE__ */ new Set();\n        for (const config of this.configs)alts.add(config.alt);\n        if (alts.size === 0) return null;\n        return alts;\n    }\n    toString() {\n        let buf = \"\";\n        buf += this.stateNumber;\n        buf += \":\";\n        buf += this.configs ? this.configs.toString() : \"\";\n        if (this.isAcceptState) {\n            buf += \"=>\";\n            if (this.predicates) buf += $c1efbdb2cbf46748$export$4323cc4280d5be7(this.predicates);\n            else buf += this.prediction;\n        }\n        return buf.toString();\n    }\n};\n// src/atn/ATNSimulator.ts\nvar $c1efbdb2cbf46748$export$b12c0eaae78de602 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ATNSimulator\");\n    }\n    /** Must distinguish between missing edge and edge we know leads nowhere */ static ERROR = $c1efbdb2cbf46748$export$61470cd35b9c4833.fromState(2147483647);\n    atn;\n    /**\n   * The context cache maps all PredictionContext objects that are ==\n   * to a single cached copy. This cache is shared across all contexts\n   * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n   * to use only cached nodes/graphs in addDFAState(). We don't want to\n   * fill this during closure() since there are lots of contexts that\n   * pop up but are not used ever again. It also greatly slows down closure().\n   *\n   * This cache makes a huge difference in memory and a little bit in speed.\n   * For the Java grammar on java.*, it dropped the memory requirements\n   * at the end from 25M to 16M. We don't store any of the full context\n   * graphs in the DFA because they are limited to local context only,\n   * but apparently there's a lot of repetition there as well. We optimize\n   * the config contexts before storing the config set in the DFA states\n   * by literally rebuilding them with cached subgraphs only.\n   *\n   * I tried a cache for use during closure operations, that was\n   * whacked after each adaptivePredict(). It cost a little bit\n   * more time I think and doesn't save on the overall footprint\n   * so it's not worth the complexity.\n   */ sharedContextCache;\n    constructor(atn, sharedContextCache){\n        this.atn = atn;\n        this.sharedContextCache = sharedContextCache;\n        return this;\n    }\n    getCachedContext(context) {\n        if (!this.sharedContextCache) return context;\n        const visited = new $c1efbdb2cbf46748$export$60ef0b43d585640a($c1efbdb2cbf46748$var$ObjectEqualityComparator.instance);\n        return $c1efbdb2cbf46748$export$8019946e4b88a3a0(context, this.sharedContextCache, visited);\n    }\n};\n// src/atn/CodePointTransitions.ts\nvar $c1efbdb2cbf46748$export$33470b4889819774 = class _CodePointTransitions {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CodePointTransitions\");\n    }\n    /** @returns new {@link AtomTransition}     */ static createWithCodePoint(target, codePoint) {\n        return _CodePointTransitions.createWithCodePointRange(target, codePoint, codePoint);\n    }\n    /** @returns new {@link AtomTransition} if range represents one atom else {@link SetTransition}. */ static createWithCodePointRange(target, codePointFrom, codePointTo) {\n        return codePointFrom === codePointTo ? new $c1efbdb2cbf46748$export$749c9accb19d603f(target, codePointFrom) : new $c1efbdb2cbf46748$export$87d1473c8b7b4627(target, codePointFrom, codePointTo);\n    }\n};\n// src/atn/DecisionInfo.ts\nvar $c1efbdb2cbf46748$export$7dca65db55187a88 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DecisionInfo\");\n    }\n    /**\n   * The decision number, which is an index into {@link ATN.decisionToState}.\n   */ decision = 0;\n    /**\n   * The total number of times {@link ParserATNSimulator.adaptivePredict} was\n   * invoked for this decision.\n   */ invocations = 0;\n    /**\n   * The total time spent in {@link ParserATNSimulator.adaptivePredict} for\n   * this decision, in nanoseconds.\n   *\n   * The value of this field contains the sum of differential results obtained\n   * by {@link process.hrtime()}, and is not adjusted to compensate for JIT\n   * and/or garbage collection overhead. For best accuracy, use a modern Node.js\n   * version that provides precise results from {@link process.hrtime()}, and\n   * perform profiling in a separate process which is warmed up by parsing the\n   * input prior to profiling.\n   */ timeInPrediction = 0;\n    /**\n   * The sum of the lookahead required for SLL prediction for this decision.\n   * Note that SLL prediction is used before LL prediction for performance\n   * reasons even when {@link PredictionMode.LL} or\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION} is used.\n   */ sllTotalLook = 0;\n    /**\n   * Gets the minimum lookahead required for any single SLL prediction to\n   * complete for this decision, by reaching a unique prediction, reaching an\n   * SLL conflict state, or encountering a syntax error.\n   */ sllMinLook = 0;\n    /**\n   * Gets the maximum lookahead required for any single SLL prediction to\n   * complete for this decision, by reaching a unique prediction, reaching an\n   * SLL conflict state, or encountering a syntax error.\n   */ sllMaxLook = 0;\n    /**\n   * Gets the {@link LookaheadEventInfo} associated with the event where the\n   * {@link sllMaxLook} value was set.\n   */ sllMaxLookEvent;\n    /**\n   * The sum of the lookahead required for LL prediction for this decision.\n   * Note that LL prediction is only used when SLL prediction reaches a\n   * conflict state.\n   */ llTotalLook = 0;\n    /**\n   * Gets the minimum lookahead required for any single LL prediction to\n   * complete for this decision. An LL prediction completes when the algorithm\n   * reaches a unique prediction, a conflict state (for\n   * {@link PredictionMode.LL}, an ambiguity state (for\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n   */ llMinLook = 0;\n    /**\n   * Gets the maximum lookahead required for any single LL prediction to\n   * complete for this decision. An LL prediction completes when the algorithm\n   * reaches a unique prediction, a conflict state (for\n   * {@link PredictionMode.LL}, an ambiguity state (for\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n   */ llMaxLook = 0;\n    /**\n   * Gets the {@link LookaheadEventInfo} associated with the event where the\n   * {@link llMaxLook} value was set.\n   */ llMaxLookEvent;\n    /**\n   * A collection of {@link ContextSensitivityInfo} instances describing the\n   * context sensitivities encountered during LL prediction for this decision.\n   */ contextSensitivities;\n    /**\n   * A collection of {@link DecisionEventInfo} instances describing the parse errors\n   * identified during calls to {@link ParserATNSimulator.adaptivePredict} for\n   * this decision.\n   */ errors;\n    /**\n   * A collection of {@link AmbiguityInfo} instances describing the\n   * ambiguities encountered during LL prediction for this decision.\n   */ ambiguities;\n    /**\n   * A collection of {@link PredicateEvalInfo} instances describing the\n   * results of evaluating individual predicates during prediction for this\n   * decision.\n   */ predicateEvals;\n    /**\n   * The total number of ATN transitions required during SLL prediction for\n   * this decision. An ATN transition is determined by the number of times the\n   * DFA does not contain an edge that is required for prediction, resulting\n   * in on-the-fly computation of that edge.\n  /**\n   * If DFA caching of SLL transitions is employed by the implementation, ATN\n   * computation may cache the computed edge for efficient lookup during\n   * future parsing of this decision. Otherwise, the SLL parsing algorithm\n   * will use ATN transitions exclusively.\n   *\n   * @see sllDFATransitions\n   * @see ParserATNSimulator.computeTargetState\n   * @see LexerATNSimulator.computeTargetState\n   */ sllATNTransitions = 0;\n    /**\n   * The total number of DFA transitions required during SLL prediction for\n   * this decision.\n   *\n   * If the ATN simulator implementation does not use DFA caching for SLL\n   * transitions, this value will be 0.\n   *\n   * @see ParserATNSimulator.getExistingTargetState\n   * @see LexerATNSimulator.getExistingTargetState\n   */ sllDFATransitions = 0;\n    /**\n   * Gets the total number of times SLL prediction completed in a conflict\n   * state, resulting in fallback to LL prediction.\n   *\n   * Note that this value is not related to whether or not\n   * {@link PredictionMode.SLL} may be used successfully with a particular\n   * grammar. If the ambiguity resolution algorithm applied to the SLL\n   * conflicts for this decision produce the same result as LL prediction for\n   * this decision, {@link PredictionMode.SLL} would produce the same overall\n   * parsing result as {@link PredictionMode.LL}.\n   */ llFallback = 0;\n    /**\n   * The total number of ATN transitions required during LL prediction for\n   * this decision. An ATN transition is determined by the number of times the\n   * DFA does not contain an edge that is required for prediction, resulting\n   * in on-the-fly computation of that edge.\n   *\n   * If DFA caching of LL transitions is employed by the implementation, ATN\n   * computation may cache the computed edge for efficient lookup during\n   * future parsing of this decision. Otherwise, the LL parsing algorithm will\n   * use ATN transitions exclusively.\n   *\n   * @see llDFATransitions\n   * @see ParserATNSimulator.computeTargetState\n   * @see LexerATNSimulator.computeTargetState\n   */ llATNTransitions = 0;\n    /**\n   * The total number of DFA transitions required during LL prediction for\n   * this decision.\n   *\n   * If the ATN simulator implementation does not use DFA caching for LL\n   * transitions, this value will be 0.\n   *\n   * @see ParserATNSimulator.getExistingTargetState\n   * @see LexerATNSimulator.getExistingTargetState\n   */ llDFATransitions = 0;\n    /**\n   * Constructs a new instance of the {@link DecisionInfo} class to contain\n   * statistics for a particular decision.\n   *\n   * @param decision The decision number\n   */ constructor(decision){\n        this.decision = decision;\n        this.contextSensitivities = [];\n        this.errors = [];\n        this.ambiguities = [];\n        this.predicateEvals = [];\n    }\n    toString() {\n        return \"{decision=\" + this.decision + \", contextSensitivities=\" + this.contextSensitivities.length + \", errors=\" + this.errors.length + \", ambiguities=\" + this.ambiguities.length + \", sllLookahead=\" + this.sllTotalLook + \", sllATNTransitions=\" + this.sllATNTransitions + \", sllDFATransitions=\" + this.sllDFATransitions + \", llFallback=\" + this.llFallback + \", llLookahead=\" + this.llTotalLook + \", llATNTransitions=\" + this.llATNTransitions + \"}\";\n    }\n};\n// src/atn/LexerATNConfig.ts\nvar $c1efbdb2cbf46748$export$2c28ca15a370dd3e = class _LexerATNConfig extends $c1efbdb2cbf46748$export$b371505ec63d1c9b {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerATNConfig\");\n    }\n    /**\n   * This is the backing field for {@link #getLexerActionExecutor}.\n   */ lexerActionExecutor;\n    passedThroughNonGreedyDecision;\n    constructor(config, state, context, lexerActionExecutor){\n        super(config, state, context ?? config.context, context ? $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE : config.semanticContext);\n        this.lexerActionExecutor = context ? lexerActionExecutor : config.lexerActionExecutor ?? null;\n        this.passedThroughNonGreedyDecision = _LexerATNConfig.checkNonGreedyDecision(config, this.state);\n        return this;\n    }\n    static createWithExecutor(config, state, lexerActionExecutor) {\n        return new _LexerATNConfig(config, state, config.context, lexerActionExecutor);\n    }\n    static createWithConfig(state, config, context) {\n        return new _LexerATNConfig(config, state, context ?? null, config.lexerActionExecutor);\n    }\n    static createWithContext(state, alt, context) {\n        return new _LexerATNConfig({\n            alt: alt\n        }, state, context, null);\n    }\n    static checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision || \"nonGreedy\" in target && target.nonGreedy;\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(7);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.state.stateNumber);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.alt);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, this.context);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, this.semanticContext);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, this.passedThroughNonGreedyDecision ? 1 : 0);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, this.lexerActionExecutor);\n            hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hashCode, 6);\n            this.cachedHashCode = hashCode;\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        return this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor && other.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);\n    }\n};\n// src/BaseErrorListener.ts\nvar $c1efbdb2cbf46748$export$2746258315f6b7a5 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BaseErrorListener\");\n    }\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {}\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {}\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {}\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {}\n};\n// src/ConsoleErrorListener.ts\nvar $c1efbdb2cbf46748$export$f571db487d32849d = class _ConsoleErrorListener extends $c1efbdb2cbf46748$export$2746258315f6b7a5 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ConsoleErrorListener\");\n    }\n    /**\n   * Provides a default instance of {@link ConsoleErrorListener}.\n   */ static instance = new _ConsoleErrorListener();\n    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {\n        console.error(\"line \" + line + \":\" + charPositionInLine + \" \" + msg);\n    }\n};\n// src/ProxyErrorListener.ts\nvar $c1efbdb2cbf46748$export$ee73ae08947f8850 = class extends $c1efbdb2cbf46748$export$2746258315f6b7a5 {\n    constructor(delegates){\n        super();\n        this.delegates = delegates;\n        return this;\n    }\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ProxyErrorListener\");\n    }\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        this.delegates.forEach((d)=>{\n            d.syntaxError(recognizer, offendingSymbol, line, column, msg, e);\n        });\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        this.delegates.forEach((d)=>{\n            d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        });\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n        this.delegates.forEach((d)=>{\n            d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        });\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n        this.delegates.forEach((d)=>{\n            d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs);\n        });\n    }\n};\n// src/Recognizer.ts\nvar $c1efbdb2cbf46748$export$d051b53981c4a264 = class _Recognizer {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Recognizer\");\n    }\n    static EOF = -1;\n    static tokenTypeMapCache = /* @__PURE__ */ new Map();\n    static ruleIndexMapCache = /* @__PURE__ */ new Map();\n    interpreter;\n    listeners = [\n        $c1efbdb2cbf46748$export$f571db487d32849d.instance\n    ];\n    stateNumber = -1;\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.13.1\";\n        if (runtimeVersion !== toolVersion) console.error(\"ANTLR runtime and generated code versions disagree: \" + runtimeVersion + \"!=\" + toolVersion);\n    }\n    addErrorListener(listener) {\n        this.listeners.push(listener);\n    }\n    removeErrorListeners() {\n        this.listeners = [];\n    }\n    removeErrorListener(listener) {\n        for(let i = 0; i < this.listeners.length; i++)if (this.listeners[i] === listener) {\n            this.listeners.splice(i, 1);\n            return;\n        }\n    }\n    getErrorListeners() {\n        return this.listeners;\n    }\n    getTokenTypeMap() {\n        const vocabulary = this.vocabulary;\n        let result = _Recognizer.tokenTypeMapCache.get(vocabulary);\n        if (!result) {\n            result = /* @__PURE__ */ new Map();\n            for(let i = 0; i <= this.atn.maxTokenType; i++){\n                const literalName = vocabulary.getLiteralName(i);\n                if (literalName) result.set(literalName, i);\n                const symbolicName = vocabulary.getSymbolicName(i);\n                if (symbolicName) result.set(symbolicName, i);\n            }\n            result.set(\"EOF\", $c1efbdb2cbf46748$export$50792b0e93539fde.EOF);\n            _Recognizer.tokenTypeMapCache.set(vocabulary, result);\n        }\n        return result;\n    }\n    /**\n   * Get a map from rule names to rule indexes.\n   * Used for XPath and tree pattern compilation.\n   */ getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        let result = _Recognizer.ruleIndexMapCache.get(ruleNames);\n        if (!result) {\n            result = /* @__PURE__ */ new Map();\n            ruleNames.forEach((ruleName, idx)=>{\n                return result.set(ruleName, idx);\n            });\n            _Recognizer.ruleIndexMapCache.set(ruleNames, result);\n        }\n        return result;\n    }\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap().get(tokenName);\n        if (ttype) return ttype;\n        return $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n    }\n    /** What is the error header, normally line/character position information? */ getErrorHeader(e) {\n        const line = e.offendingToken?.line;\n        const column = e.offendingToken?.column;\n        return \"line \" + line + \":\" + column;\n    }\n    get errorListenerDispatch() {\n        return new $c1efbdb2cbf46748$export$ee73ae08947f8850(this.listeners);\n    }\n    /**\n   * subclass needs to override these if there are semantic predicates or actions\n   * that the ATN interp needs to execute\n   */ sempred(_localctx, _ruleIndex, _actionIndex) {\n        return true;\n    }\n    // TODO: make localCtx an optional parameter, not optional null.\n    precpred(_localctx, _precedence) {\n        return true;\n    }\n    action(_localctx, _ruleIndex, _actionIndex) {}\n    get atn() {\n        return this.interpreter.atn;\n    }\n    get state() {\n        return this.stateNumber;\n    }\n    set state(state) {\n        this.stateNumber = state;\n    }\n    getParseInfo() {\n        return void 0;\n    }\n};\n// src/CommonTokenFactory.ts\nvar $c1efbdb2cbf46748$export$37f5fb6f74ae1f7 = class _CommonTokenFactory {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CommonTokenFactory\");\n    }\n    /**\n   * The default {@link CommonTokenFactory} instance.\n   *\n   *\n   * This token factory does not explicitly copy token text when constructing\n   * tokens.\n   */ static DEFAULT = new _CommonTokenFactory();\n    /**\n   * Indicates whether {@link CommonToken.setText} should be called after\n   * constructing tokens to explicitly set the text. This is useful for cases\n   * where the input stream might not be able to provide arbitrary substrings\n   * of text from the input after the lexer creates a token (e.g. the\n   * implementation of {@link CharStream.getText} in\n   * {@link UnbufferedCharStream} throws an\n   * {@link UnsupportedOperationException}). Explicitly setting the token text\n   * allows {@link Token.getText} to be called at any time regardless of the\n   * input stream implementation.\n   *\n   *\n   * The default value is `false` to avoid the performance and memory\n   * overhead of copying text for every token unless explicitly requested.\n   */ copyText = false;\n    constructor(copyText){\n        this.copyText = copyText ?? false;\n    }\n    create(source, type, text, channel, start, stop, line, column) {\n        const t = $c1efbdb2cbf46748$export$c9b1d0b06becfda3.fromSource(source, type, channel, start, stop);\n        t.line = line;\n        t.column = column;\n        if (text) t.text = text;\n        else if (this.copyText && source[1] !== null) t.text = source[1].getTextFromRange(start, stop);\n        return t;\n    }\n};\n// src/RecognitionException.ts\nvar $c1efbdb2cbf46748$export$c1c401305ad687ac = class _RecognitionException extends Error {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RecognitionException\");\n    }\n    ctx;\n    /**\n   * The current {@link Token} when an error occurred. Since not all streams\n   * support accessing symbols by index, we have to track the {@link Token}\n   * instance itself\n   */ offendingToken = null;\n    /**\n   * Get the ATN state number the parser was in at the time the error\n   * occurred. For {@link NoViableAltException} and\n   * {@link LexerNoViableAltException} exceptions, this is the\n   * {@link DecisionState} number. For others, it is the state whose outgoing\n   * edge we couldn't match.\n   */ offendingState = -1;\n    recognizer;\n    input;\n    constructor(params){\n        super(params.message);\n        if (Error.captureStackTrace) Error.captureStackTrace(this, _RecognitionException);\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        if (this.recognizer !== null) this.offendingState = this.recognizer.state;\n    }\n    /**\n   * Gets the set of input symbols which could potentially follow the\n   * previously matched symbol at the time this exception was thrown.\n   *\n   * If the set of expected tokens is not known and could not be computed,\n   * this method returns `null`.\n   *\n   * @returns The set of token types that could potentially follow the current\n   * state in the ATN, or `null` if the information is not available.\n   */ getExpectedTokens() {\n        if (this.recognizer !== null && this.ctx !== null) return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        else return null;\n    }\n    // If the state number is not known, this method returns -1.\n    toString() {\n        return this.message;\n    }\n};\n// src/LexerNoViableAltException.ts\nvar $c1efbdb2cbf46748$export$b0273c9bf9a740df = class extends $c1efbdb2cbf46748$export$c1c401305ad687ac {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerNoViableAltException\");\n    }\n    startIndex;\n    deadEndConfigs;\n    constructor(lexer, input, startIndex, deadEndConfigs){\n        super({\n            message: \"\",\n            recognizer: lexer,\n            input: input,\n            ctx: null\n        });\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n    toString() {\n        let symbol = \"\";\n        if (this.input && this.startIndex >= 0 && this.startIndex < this.input.size) symbol = this.input.getTextFromRange(this.startIndex, this.startIndex);\n        return `LexerNoViableAltException(${symbol})`;\n    }\n};\n// src/Lexer.ts\nvar $c1efbdb2cbf46748$export$6168dc8908a6c652 = class _Lexer extends $c1efbdb2cbf46748$export$d051b53981c4a264 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Lexer\");\n    }\n    static DEFAULT_MODE = 0;\n    static MORE = -2;\n    static SKIP = -3;\n    static DEFAULT_TOKEN_CHANNEL = $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n    static HIDDEN = $c1efbdb2cbf46748$export$50792b0e93539fde.HIDDEN_CHANNEL;\n    options = {\n        minDFAEdge: 0,\n        maxDFAEdge: 256,\n        minCodePoint: 0,\n        maxCodePoint: 1114111\n    };\n    /**\n   * What character index in the stream did the current token start at?\n   *  Needed, for example, to get the text for current token.  Set at\n   *  the start of nextToken.\n   */ tokenStartCharIndex = -1;\n    /** The channel number for the current token */ channel = 0;\n    /** The token type for the current token */ type = 0;\n    mode = _Lexer.DEFAULT_MODE;\n    /** The start column of the current token (the one that was last read by `nextToken`). */ currentTokenColumn = 0;\n    /**\n   * The line on which the first character of the current token (the one that was last read by `nextToken`) resides.\n   */ currentTokenStartLine = 0;\n    input;\n    /**\n   * The goal of all lexer rules/methods is to create a token object.\n   *  This is an instance variable as multiple rules may collaborate to\n   *  create a single token.  nextToken will return this object after\n   *  matching lexer rule(s).  If you subclass to allow multiple token\n   *  emissions, then set this to the last token to be matched or\n   *  something non-null so that the auto token emit mechanism will not\n   *  emit another token.\n   */ token = null;\n    /**\n   * Once we see EOF on char stream, next token will be EOF.\n   * If you have DONE : EOF ; then you see DONE EOF.\n   */ hitEOF = false;\n    factory;\n    #modeStack = [];\n    /**\n   * The text to be used for the next token. If this is not null, then the text\n   * for the next token is fixed and is not subject to change in the normal\n   * workflow of the lexer.\n   */ #text;\n    constructor(input, options){\n        super();\n        this.options = {\n            ...this.options,\n            ...options\n        };\n        this.input = input;\n        this.factory = $c1efbdb2cbf46748$export$37f5fb6f74ae1f7.DEFAULT;\n    }\n    reset(seekBack = true) {\n        if (seekBack) this.input.seek(0);\n        this.token = null;\n        this.type = $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n        this.channel = $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n        this.tokenStartCharIndex = -1;\n        this.currentTokenColumn = -1;\n        this.currentTokenStartLine = -1;\n        this.#text = void 0;\n        this.hitEOF = false;\n        this.mode = _Lexer.DEFAULT_MODE;\n        this.#modeStack = [];\n        this.interpreter.reset();\n    }\n    /** @returns a token from this source; i.e., match a token on the char stream. */ nextToken() {\n        if (this.input === null) throw new Error(\"nextToken requires a non-null input stream.\");\n        const tokenStartMarker = this.input.mark();\n        try {\n            while(true){\n                if (this.hitEOF) {\n                    this.emitEOF();\n                    return this.token;\n                }\n                this.token = null;\n                this.channel = $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n                this.tokenStartCharIndex = this.input.index;\n                this.currentTokenColumn = this.interpreter.column;\n                this.currentTokenStartLine = this.interpreter.line;\n                this.#text = void 0;\n                let continueOuter = false;\n                while(true){\n                    this.type = $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n                    let ttype = _Lexer.SKIP;\n                    try {\n                        ttype = this.interpreter.match(this.input, this.mode);\n                    } catch (e) {\n                        if (e instanceof $c1efbdb2cbf46748$export$b0273c9bf9a740df) {\n                            this.notifyListeners(e);\n                            this.recover(e);\n                        } else throw e;\n                    }\n                    if (this.input.LA(1) === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) this.hitEOF = true;\n                    if (this.type === $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE) this.type = ttype;\n                    if (this.type === _Lexer.SKIP) {\n                        continueOuter = true;\n                        break;\n                    }\n                    if (this.type !== _Lexer.MORE) break;\n                }\n                if (continueOuter) continue;\n                if (this.token === null) this.emit();\n                return this.token;\n            }\n        } finally{\n            this.input.release(tokenStartMarker);\n        }\n    }\n    /**\n   * Instruct the lexer to skip creating a token for current lexer rule\n   * and look for another token. nextToken() knows to keep looking when\n   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n   * if token==null at end of any token rule, it creates one for you\n   * and emits it.\n   */ skip() {\n        this.type = _Lexer.SKIP;\n    }\n    more() {\n        this.type = _Lexer.MORE;\n    }\n    pushMode(m2) {\n        if ($c1efbdb2cbf46748$export$e2b3d84d700fff0a.debug) console.log(\"pushMode \" + m2);\n        this.#modeStack.push(this.mode);\n        this.mode = m2;\n    }\n    popMode() {\n        if (this.#modeStack.length === 0) throw new Error(\"Empty Stack\");\n        if ($c1efbdb2cbf46748$export$e2b3d84d700fff0a.debug) console.log(\"popMode back to \" + this.#modeStack.slice(0, -1));\n        this.mode = this.#modeStack.pop();\n        return this.mode;\n    }\n    get modeStack() {\n        return this.#modeStack;\n    }\n    /**\n   * By default does not support multiple emits per nextToken invocation\n   * for efficiency reasons. Subclass and override this method, nextToken,\n   * and getToken (to push tokens into a list and pull from that list\n   * rather than a single variable as this implementation does).\n   */ emitToken(token) {\n        this.token = token;\n    }\n    /**\n   * The standard method called to automatically emit a token at the\n   * outermost lexical rule. The token object should point into the\n   * char buffer start..stop. If there is a text override in 'text',\n   * use that to set the token's text. Override this method to emit\n   * custom Token objects or provide a new factory.\n   */ emit() {\n        const t = this.factory.create([\n            this,\n            this.input\n        ], this.type, this.#text, this.channel, this.tokenStartCharIndex, this.getCharIndex() - 1, this.currentTokenStartLine, this.currentTokenColumn);\n        this.emitToken(t);\n        return t;\n    }\n    emitEOF() {\n        const eof = this.factory.create([\n            this,\n            this.input\n        ], $c1efbdb2cbf46748$export$50792b0e93539fde.EOF, void 0, $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL, this.input.index, this.input.index - 1, this.line, this.column);\n        this.emitToken(eof);\n        return eof;\n    }\n    /** What is the index of the current character of lookahead? */ getCharIndex() {\n        return this.input.index;\n    }\n    /**\n   * Return a list of all Token objects in input char stream.\n   * Forces load of all tokens. Does not include EOF token.\n   */ getAllTokens() {\n        const tokens = [];\n        let t = this.nextToken();\n        while(t.type !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF){\n            tokens.push(t);\n            t = this.nextToken();\n        }\n        return tokens;\n    }\n    notifyListeners(e) {\n        const start = this.tokenStartCharIndex;\n        const stop = this.input.index;\n        const text = this.input.getTextFromRange(start, stop);\n        const msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n        this.errorListenerDispatch.syntaxError(this, null, this.currentTokenStartLine, this.currentTokenColumn, msg, e);\n    }\n    getErrorDisplay(s) {\n        return s;\n    }\n    getErrorDisplayForChar(c) {\n        if (c.charCodeAt(0) === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"<EOF>\";\n        if (c === \"\\n\") return \"\\\\n\";\n        if (c === \"\t\") return \"\\\\t\";\n        if (c === \"\\r\") return \"\\\\r\";\n        return c;\n    }\n    getCharErrorDisplay(c) {\n        return \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n    }\n    /**\n   * Lexers can normally match any char in it's vocabulary after matching\n   * a token, so do the easy thing and just kill a character and hope\n   * it all works out. You can instead use the rule invocation stack\n   * to do sophisticated error recovery if you are in a fragment rule.\n   */ recover(re) {\n        if (this.input.LA(1) !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n            if (re instanceof $c1efbdb2cbf46748$export$b0273c9bf9a740df) this.interpreter.consume(this.input);\n            else this.input.consume();\n        }\n    }\n    get inputStream() {\n        return this.input;\n    }\n    set inputStream(input) {\n        this.reset(false);\n        this.input = input;\n    }\n    set tokenFactory(factory) {\n        this.factory = factory;\n    }\n    get tokenFactory() {\n        return this.factory;\n    }\n    get sourceName() {\n        return this.input.getSourceName();\n    }\n    get line() {\n        return this.interpreter.line;\n    }\n    set line(line) {\n        this.interpreter.line = line;\n    }\n    get column() {\n        return this.interpreter.column;\n    }\n    set column(column) {\n        this.interpreter.column = column;\n    }\n    get text() {\n        if (this.#text) return this.#text;\n        else return this.interpreter.getText(this.input);\n    }\n    set text(text) {\n        this.#text = text;\n    }\n};\n// src/dfa/DFASerializer.ts\nvar $c1efbdb2cbf46748$export$58907c774c5f6b76 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DFASerializer\");\n    }\n    dfa;\n    vocabulary;\n    constructor(dfa, vocabulary){\n        this.dfa = dfa;\n        this.vocabulary = vocabulary;\n    }\n    toString() {\n        if (!this.dfa.s0) return \"\";\n        let buf = \"\";\n        const states = this.dfa.getStates();\n        for (const s of states){\n            let n2 = 0;\n            n2 = s.edges.length;\n            for(let i = 0; i < n2; i++){\n                const t = s.edges[i];\n                if (t && t.stateNumber !== 2147483647) {\n                    buf += this.getStateString(s);\n                    const label = this.getEdgeLabel(i);\n                    buf += \"-\";\n                    buf += label;\n                    buf += \"->\";\n                    buf += this.getStateString(t);\n                    buf += \"\\n\";\n                }\n            }\n        }\n        return buf;\n    }\n    getEdgeLabel(i) {\n        const name = this.vocabulary.getDisplayName(i - 1);\n        return `${name}`;\n    }\n    getStateString(s) {\n        const n2 = s.stateNumber;\n        const baseStateStr = (s.isAcceptState ? \":\" : \"\") + \"s\" + n2 + (s.requiresFullContext ? \"^\" : \"\");\n        if (s.isAcceptState) {\n            if (s.predicates !== null) return `${baseStateStr}=>${s.predicates.toString()}`;\n            return `${baseStateStr}=>${s.prediction}`;\n        } else return `${baseStateStr}`;\n    }\n};\n// src/dfa/LexerDFASerializer.ts\nvar $c1efbdb2cbf46748$export$99ec819fcd61fb61 = class extends $c1efbdb2cbf46748$export$58907c774c5f6b76 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerDFASerializer\");\n    }\n    constructor(dfa){\n        super(dfa, $c1efbdb2cbf46748$export$6fe78fc0b86aec88.EMPTY_VOCABULARY);\n    }\n    getEdgeLabel = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((i)=>{\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }, \"getEdgeLabel\");\n};\n// src/dfa/DFA.ts\nvar $c1efbdb2cbf46748$export$d210bcfe90c75f0 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DFA\");\n    }\n    s0;\n    decision;\n    /** From which ATN state did we create this DFA? */ atnStartState;\n    /**\n   * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n   * start state {@link #s0} which is not stored in {@link #states}. The\n   * {@link DFAState#edges} array for this start state contains outgoing edges\n   * supplying individual start states corresponding to specific precedence\n   * values.\n   *\n   * @returns `true` if this is a precedence DFA; otherwise, `false`.\n   */ isPrecedenceDfa;\n    /**\n   * A mapping from an ATNConfigSet hash to a DFAState.\n   * Used to quick look up the DFA state for a particular configuration set.\n   */ states = /* @__PURE__ */ new Map();\n    constructor(atnStartState, decision){\n        this.atnStartState = atnStartState;\n        this.decision = decision ?? 0;\n        let precedenceDfa = false;\n        if (atnStartState instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376) {\n            if (atnStartState.precedenceRuleDecision) {\n                precedenceDfa = true;\n                this.s0 = $c1efbdb2cbf46748$export$61470cd35b9c4833.fromState(-1);\n            }\n        }\n        this.isPrecedenceDfa = precedenceDfa;\n    }\n    [Symbol.iterator] = ()=>{\n        return this.states.values()[Symbol.iterator]();\n    };\n    /**\n   * Get the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n    @returns The start state corresponding to the specified precedence, or\n   * `null` if no start state exists for the specified precedence.\n   *\n   * @throws IllegalStateException if this is not a precedence DFA.\n   * @see #isPrecedenceDfa\n   */ getPrecedenceStartState = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((precedence)=>{\n        if (!this.isPrecedenceDfa) throw new Error(`Only precedence DFAs may contain a precedence start state.`);\n        if (!this.s0 || !this.s0.edges || precedence < 0 || precedence >= this.s0.edges.length) return void 0;\n        return this.s0.edges[precedence];\n    }, \"getPrecedenceStartState\");\n    /**\n   * Set the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n   * @param startState The start state corresponding to the specified precedence.\n   */ setPrecedenceStartState = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((precedence, startState)=>{\n        if (!this.isPrecedenceDfa) throw new Error(`Only precedence DFAs may contain a precedence start state.`);\n        if (precedence < 0 || !this.s0) return;\n        this.s0.edges[precedence] = startState;\n    }, \"setPrecedenceStartState\");\n    /**\n   * @returns a list of all states in this DFA, ordered by state number.\n   */ getStates() {\n        const result = [\n            ...this.states.values()\n        ];\n        result.sort((o1, o2)=>{\n            return o1.stateNumber - o2.stateNumber;\n        });\n        return result;\n    }\n    getState(state) {\n        return this.states.get(state.configs.hashCode()) ?? null;\n    }\n    getStateForConfigs(configs) {\n        return this.states.get(configs.hashCode()) ?? null;\n    }\n    addState(state) {\n        const hash = state.configs.hashCode();\n        if (this.states.has(hash)) return;\n        this.states.set(hash, state);\n        state.stateNumber = this.states.size - 1;\n    }\n    toString(vocabulary) {\n        if (!vocabulary) return this.toString($c1efbdb2cbf46748$export$6fe78fc0b86aec88.EMPTY_VOCABULARY);\n        if (!this.s0) return \"\";\n        const serializer = new $c1efbdb2cbf46748$export$58907c774c5f6b76(this, vocabulary);\n        return serializer.toString() ?? \"\";\n    }\n    toLexerString() {\n        if (!this.s0) return \"\";\n        const serializer = new $c1efbdb2cbf46748$export$99ec819fcd61fb61(this);\n        return serializer.toString() ?? \"\";\n    }\n    get length() {\n        return this.states.size;\n    }\n};\n// src/atn/LexerIndexedCustomAction.ts\nvar $c1efbdb2cbf46748$export$4db024666b607969 = class _LexerIndexedCustomAction {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerIndexedCustomAction\");\n    }\n    offset;\n    action;\n    actionType;\n    isPositionDependent = true;\n    cachedHashCode;\n    constructor(offset, action){\n        this.actionType = action.actionType;\n        this.offset = offset;\n        this.action = action;\n    }\n    /**\n   * This method calls {@link execute} on the result of {@link getAction}\n   * using the provided `lexer`.\n   */ execute(lexer) {\n        this.action.execute(lexer);\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize();\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hash, this.offset);\n            hash = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hash, this.action);\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hash, 2);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (!(other instanceof _LexerIndexedCustomAction)) return false;\n        return this.offset === other.offset && this.action === other.action;\n    }\n};\n// src/atn/LexerActionExecutor.ts\nvar $c1efbdb2cbf46748$export$291583ae58f6a758 = class _LexerActionExecutor {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerActionExecutor\");\n    }\n    lexerActions;\n    actionType;\n    isPositionDependent = false;\n    cachedHashCode;\n    /**\n   * Represents an executor for a sequence of lexer actions which traversed during\n   * the matching operation of a lexer rule (token).\n   *\n   * The executor tracks position information for position-dependent lexer actions\n   * efficiently, ensuring that actions appearing only at the end of the rule do\n   * not cause bloating of the {@link DFA} created for the lexer.\n   */ constructor(lexerActions){\n        this.actionType = -1;\n        this.lexerActions = lexerActions ?? [];\n        return this;\n    }\n    /**\n   * Creates a {@link LexerActionExecutor} which executes the actions for\n   * the input `lexerActionExecutor` followed by a specified\n   * `lexerAction`.\n   *\n   * @param lexerActionExecutor The executor for actions already traversed by\n   * the lexer while matching a token within a particular\n   * {@link LexerATNConfig}. If this is `null`, the method behaves as\n   * though it were an empty executor.\n   * @param lexerAction The lexer action to execute after the actions\n   * specified in `lexerActionExecutor`.\n   *\n   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n   * of `lexerActionExecutor` and `lexerAction`.\n   */ static append(lexerActionExecutor, lexerAction) {\n        if (lexerActionExecutor === null) return new _LexerActionExecutor([\n            lexerAction\n        ]);\n        const lexerActions = lexerActionExecutor.lexerActions.concat([\n            lexerAction\n        ]);\n        return new _LexerActionExecutor(lexerActions);\n    }\n    /**\n   * Creates a {@link LexerActionExecutor} which encodes the current offset\n   * for position-dependent lexer actions.\n   *\n   * Normally, when the executor encounters lexer actions where\n   * {@link LexerAction//isPositionDependent} returns `true`, it calls\n   * {@link IntStream.seek} on the input {@link CharStream} to set the input\n   * position to the *end* of the current token. This behavior provides\n   * for efficient DFA representation of lexer actions which appear at the end\n   * of a lexer rule, even when the lexer rule matches a variable number of\n   * characters.\n   *\n   * Prior to traversing a match transition in the ATN, the current offset\n   * from the token start index is assigned to all position-dependent lexer\n   * actions which have not already been assigned a fixed offset. By storing\n   * the offsets relative to the token start index, the DFA representation of\n   * lexer actions which appear in the middle of tokens remains efficient due\n   * to sharing among tokens of the same length, regardless of their absolute\n   * position in the input stream.\n   *\n   * If the current executor already has offsets assigned to all\n   * position-dependent lexer actions, the method returns `this`.\n   *\n   * @param offset The current offset to assign to all position-dependent\n   * lexer actions which do not already have offsets assigned.\n   *\n   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n   * for all position-dependent lexer actions.\n   */ fixOffsetBeforeMatch(offset) {\n        let updatedLexerActions = null;\n        for(let i = 0; i < this.lexerActions.length; i++)if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof $c1efbdb2cbf46748$export$4db024666b607969)) {\n            if (updatedLexerActions === null) updatedLexerActions = this.lexerActions.concat([]);\n            updatedLexerActions[i] = new $c1efbdb2cbf46748$export$4db024666b607969(offset, this.lexerActions[i]);\n        }\n        if (updatedLexerActions === null) return this;\n        else return new _LexerActionExecutor(updatedLexerActions);\n    }\n    /**\n   * Execute the actions encapsulated by this executor within the context of a\n   * particular {@link Lexer}.\n   *\n   * This method calls {@link IntStream.seek} to set the position of the\n   * `input` {@link CharStream} prior to calling\n   * {@link LexerAction.execute} on a position-dependent action. Before the\n   * method returns, the input position will be restored to the same position\n   * it was in when the method was invoked.\n   *\n   * @param lexer The lexer instance.\n   * @param input The input stream which is the source for the current token.\n   * When this method is called, the current {@link IntStream.index} for\n   * `input` should be the start of the following token, i.e. 1\n   * character past the end of the current token.\n   * @param startIndex The token start index. This value may be passed to\n   * {@link IntStream.seek} to set the `input` position to the beginning\n   * of the token.\n   */ execute(lexer, input, startIndex) {\n        if (input === void 0 || startIndex === void 0) return;\n        let requiresSeek = false;\n        const stopIndex = input.index;\n        try {\n            for (const lexerAction of this.lexerActions){\n                let action = lexerAction;\n                if (lexerAction instanceof $c1efbdb2cbf46748$export$4db024666b607969) {\n                    const offset = lexerAction.offset;\n                    input.seek(startIndex + offset);\n                    action = lexerAction.action;\n                    requiresSeek = startIndex + offset !== stopIndex;\n                } else if (lexerAction.isPositionDependent) {\n                    input.seek(stopIndex);\n                    requiresSeek = false;\n                }\n                action.execute(lexer);\n            }\n        } finally{\n            if (requiresSeek) input.seek(stopIndex);\n        }\n    }\n    hashCode() {\n        if (this.cachedHashCode === void 0) {\n            let hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(7);\n            for (const lexerAction of this.lexerActions)hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, lexerAction.hashCode());\n            this.cachedHashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hashCode, this.lexerActions.length);\n        }\n        return this.cachedHashCode;\n    }\n    equals(other) {\n        if (this === other) return true;\n        if (this.cachedHashCode !== other.cachedHashCode) return false;\n        if (this.lexerActions.length !== other.lexerActions.length) return false;\n        return this.lexerActions.every((action, index)=>{\n            return action.equals(other.lexerActions[index]);\n        });\n    }\n};\n// src/misc/OrderedHashSet.ts\nvar $c1efbdb2cbf46748$export$d5d979e8d34e65c7 = class _OrderedHashSet extends $c1efbdb2cbf46748$export$9d0bf21c11057332 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"OrderedHashSet\");\n    }\n    elements = [];\n    getOrAdd(o) {\n        const oldSize = this.size;\n        const result = super.getOrAdd(o);\n        if (this.size > oldSize) this.elements.push(o);\n        return result;\n    }\n    equals(o) {\n        if (!(o instanceof _OrderedHashSet)) return false;\n        return super.equals(o);\n    }\n    clear() {\n        super.clear();\n        this.elements = [];\n    }\n    *[Symbol.iterator]() {\n        yield* this.elements;\n    }\n    toArray() {\n        return this.elements.slice(0);\n    }\n};\n// src/atn/OrderedATNConfigSet.ts\nvar $c1efbdb2cbf46748$export$21ea10f62e292dcc = class extends $c1efbdb2cbf46748$export$3e159d9d82bfca90 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"OrderedATNConfigSet\");\n    }\n    constructor(){\n        super();\n        this.configLookup = new $c1efbdb2cbf46748$export$d5d979e8d34e65c7();\n    }\n};\n// src/atn/LexerATNSimulator.ts\nvar $c1efbdb2cbf46748$export$e2b3d84d700fff0a = class _LexerATNSimulator extends $c1efbdb2cbf46748$export$b12c0eaae78de602 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerATNSimulator\");\n    }\n    static debug = false;\n    decisionToDFA;\n    recognizer = null;\n    /**\n   * The current token's starting index into the character stream.\n   *  Shared across DFA to ATN simulation in case the ATN fails and the\n   *  DFA did not have a previous accept state. In this case, we use the\n   *  ATN-generated exception object.\n   */ startIndex = -1;\n    /** line number 1..n within the input */ line = 1;\n    /** The index of the character relative to the beginning of the line 0..n-1 */ column = 0;\n    mode = $c1efbdb2cbf46748$export$6168dc8908a6c652.DEFAULT_MODE;\n    /** Used during DFA/ATN exec to record the most recent accept configuration info */ prevAccept;\n    options;\n    /** Lookup table for lexer ATN config creation. */ lexerATNConfigFactory;\n    /**\n   * When we hit an accept state in either the DFA or the ATN, we\n   * have to notify the character stream to start buffering characters\n   * via {@link IntStream//mark} and record the current state. The current sim state\n   * includes the current index into the input, the current line,\n   * and current character position in that line. Note that the Lexer is\n   * tracking the starting line and characterization of the token. These\n   * variables track the \"state\" of the simulator when it hits an accept state.\n   *\n   * We track these variables separately for the DFA and ATN simulation\n   * because the DFA simulation often has to fail over to the ATN\n   * simulation. If the ATN simulation fails, we need the DFA to fall\n   * back to its previously accepted state, if any. If the ATN succeeds,\n   * then the ATN does the accept and the DFA simulator that invoked it\n   * can simply return the predicted token type.\n   */ constructor(recog, atn, decisionToDFA, sharedContextCache){\n        super(atn, sharedContextCache);\n        this.decisionToDFA = decisionToDFA;\n        this.recognizer = recog;\n        if (recog) this.options = recog.options;\n        else this.options = {\n            minDFAEdge: 0,\n            maxDFAEdge: 256,\n            minCodePoint: 0,\n            maxCodePoint: 1114111\n        };\n    }\n    match(input, mode) {\n        this.mode = mode;\n        const mark = input.mark();\n        try {\n            this.startIndex = input.index;\n            this.prevAccept = void 0;\n            const dfa = this.decisionToDFA[mode];\n            if (!dfa.s0) return this.matchATN(input);\n            return this.execATN(input, dfa.s0);\n        } finally{\n            input.release(mark);\n        }\n    }\n    reset() {\n        this.prevAccept = void 0;\n        this.startIndex = -1;\n        this.line = 1;\n        this.column = 0;\n        this.mode = $c1efbdb2cbf46748$export$6168dc8908a6c652.DEFAULT_MODE;\n    }\n    clearDFA() {\n        for(let d = 0; d < this.decisionToDFA.length; d++)this.decisionToDFA[d] = new $c1efbdb2cbf46748$export$d210bcfe90c75f0(this.atn.getDecisionState(d), d);\n    }\n    getDFA(mode) {\n        return this.decisionToDFA[mode];\n    }\n    /** @returns the text matched so far for the current token. */ getText(input) {\n        return input.getTextFromRange(this.startIndex, input.index - 1);\n    }\n    consume(input) {\n        const curChar = input.LA(1);\n        if (curChar === \"\\n\".charCodeAt(0)) {\n            this.line += 1;\n            this.column = 0;\n        } else this.column += 1;\n        input.consume();\n    }\n    getTokenName(tt) {\n        if (tt === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"EOF\";\n        else return \"'\" + String.fromCharCode(tt) + \"'\";\n    }\n    matchATN(input) {\n        const startState = this.atn.modeToStartState[this.mode];\n        if (_LexerATNSimulator.debug) console.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n        const oldMode = this.mode;\n        const s0Closure = this.computeStartState(input, startState);\n        const suppressEdge = s0Closure.hasSemanticContext;\n        s0Closure.hasSemanticContext = false;\n        const next = this.addDFAState(s0Closure);\n        if (!suppressEdge) this.decisionToDFA[this.mode].s0 = next;\n        const predict = this.execATN(input, next);\n        if (_LexerATNSimulator.debug) console.log(\"DFA after matchATN: \" + this.decisionToDFA[oldMode].toLexerString());\n        return predict;\n    }\n    execATN(input, state) {\n        if (_LexerATNSimulator.debug) console.log(\"start state closure=\" + state.configs);\n        if (state.isAcceptState) this.captureSimState(input, state);\n        let t = input.LA(1);\n        while(true){\n            if (_LexerATNSimulator.debug) console.log(\"execATN loop starting closure: \" + state.configs);\n            let target = this.getExistingTargetState(state, t);\n            if (!target) target = this.computeTargetState(input, state, t);\n            if (target === $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR) break;\n            if (t !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) this.consume(input);\n            if (target.isAcceptState) {\n                this.captureSimState(input, target);\n                if (t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) break;\n            }\n            t = input.LA(1);\n            state = target;\n        }\n        return this.failOrAccept(input, state.configs, t);\n    }\n    /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns `null`.\n   *\n   * @param s The current DFA state.\n   * @param t The next input symbol.\n   *\n   * @returns The existing target DFA state for the given input symbol\n   * `t`, or `null` if the target state for this edge is not already cached\n   */ getExistingTargetState(s, t) {\n        if (t >= this.options.minDFAEdge && t <= this.options.maxDFAEdge) {\n            const target = s.edges[t - this.options.minDFAEdge];\n            if (_LexerATNSimulator.debug && target) console.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n            return target;\n        }\n        return void 0;\n    }\n    /**\n   * Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding\n   * edge to the DFA.\n   *\n   * @param input The input stream\n   * @param s The current DFA state\n   * @param t The next input symbol\n   *\n   * @returns The computed target DFA state for the given input symbol `t`.\n   *          If `t` does not lead to a valid DFA state, this method returns `ERROR`.\n   */ computeTargetState(input, s, t) {\n        const reach = new $c1efbdb2cbf46748$export$21ea10f62e292dcc();\n        this.getReachableConfigSet(input, s.configs, reach, t);\n        if (reach.length === 0) {\n            if (!reach.hasSemanticContext) this.addDFAEdge(s, t, $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR);\n            return $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR;\n        }\n        return this.addDFAEdge(s, t, null, reach);\n    }\n    failOrAccept(input, reach, t) {\n        if (this.prevAccept?.dfaState) {\n            const { dfaState: dfaState, index: index, line: line, column: column } = this.prevAccept;\n            this.accept(input, dfaState.lexerActionExecutor, this.startIndex, index, line, column);\n            return dfaState.prediction;\n        }\n        if (t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF && input.index === this.startIndex) return $c1efbdb2cbf46748$export$50792b0e93539fde.EOF;\n        throw new $c1efbdb2cbf46748$export$b0273c9bf9a740df(this.recognizer, input, this.startIndex, reach);\n    }\n    /**\n   * Given a starting configuration set, figure out all ATN configurations we can reach upon input `t`.\n   * Parameter `reach` is a return parameter.\n   */ getReachableConfigSet(input, closure, reach, t) {\n        let skipAlt = $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        for (const cfg of closure){\n            const currentAltReachedAcceptState = cfg.alt === skipAlt;\n            if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) continue;\n            if (_LexerATNSimulator.debug) console.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg.toString(this.recognizer, true));\n            for (const trans of cfg.state.transitions){\n                const target = this.getReachableTarget(trans, t);\n                if (target) {\n                    let lexerActionExecutor = cfg.lexerActionExecutor;\n                    if (lexerActionExecutor) lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n                    const treatEofAsEpsilon = t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF;\n                    const config = $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithExecutor(cfg, target, lexerActionExecutor);\n                    if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) skipAlt = cfg.alt;\n                }\n            }\n        }\n    }\n    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n        if (_LexerATNSimulator.debug) console.log(\"ACTION %s\\n\", lexerActionExecutor);\n        input.seek(index);\n        this.line = line;\n        this.column = charPos;\n        if (lexerActionExecutor && this.recognizer) lexerActionExecutor.execute(this.recognizer, input, startIndex);\n    }\n    getReachableTarget(trans, t) {\n        if (trans.matches(t, this.options.minCodePoint, this.options.maxCodePoint)) return trans.target;\n        else return void 0;\n    }\n    computeStartState(input, p) {\n        const initialContext = $c1efbdb2cbf46748$export$179fd11580abda9d.instance;\n        const configs = new $c1efbdb2cbf46748$export$21ea10f62e292dcc();\n        for(let i = 0; i < p.transitions.length; i++){\n            const target = p.transitions[i].target;\n            const cfg = $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithContext(target, i + 1, initialContext);\n            this.closure(input, cfg, configs, false, false, false);\n        }\n        return configs;\n    }\n    /**\n   * Since the alternatives within any lexer decision are ordered by\n   * preference, this method stops pursuing the closure as soon as an accept\n   * state is reached. After the first accept state is reached by depth-first\n   * search from `config`, all other (potentially reachable) states for\n   * this rule would have a lower priority.\n   *\n   * @returns {boolean} `true` if an accept state is reached, otherwise `false`.\n   */ closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n        let cfg = null;\n        if (_LexerATNSimulator.debug) console.log(\"closure(\" + config.toString(this.recognizer, true) + \")\");\n        if (config.state.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) {\n            if (_LexerATNSimulator.debug) {\n                if (this.recognizer !== null) console.log(\"closure at %s rule stop %s\\n\", this.recognizer.ruleNames[config.state.ruleIndex], config);\n                else console.log(\"closure at rule stop %s\\n\", config);\n            }\n            if (!config.context || config.context.hasEmptyPath()) {\n                if (!config.context || config.context.isEmpty()) {\n                    configs.add(config);\n                    return true;\n                } else {\n                    configs.add($c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(config.state, config, $c1efbdb2cbf46748$export$179fd11580abda9d.instance));\n                    currentAltReachedAcceptState = true;\n                }\n            }\n            if (config.context && !config.context.isEmpty()) {\n                for(let i = 0; i < config.context.length; i++)if (config.context.getReturnState(i) !== $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE) {\n                    const newContext = config.context.getParent(i);\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    cfg = $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(returnState, config, newContext);\n                    currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n                }\n            }\n            return currentAltReachedAcceptState;\n        }\n        if (!config.state.epsilonOnlyTransitions) {\n            if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) configs.add(config);\n        }\n        for (const trans of config.state.transitions){\n            cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n            if (cfg) currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n        }\n        return currentAltReachedAcceptState;\n    }\n    // side-effect: can alter configs.hasSemanticContext\n    getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {\n        if (!this.lexerATNConfigFactory) this.setupATNFactoryLookup();\n        const factory = this.lexerATNConfigFactory[trans.transitionType];\n        if (!factory) return null;\n        return factory(input, config, trans, configs, speculative, treatEofAsEpsilon);\n    }\n    /**\n   * Fills the lookup table for creating lexer ATN configs. This helps to avoid frequent checks of the transition\n   * type, which determines the configuration of the created config.\n   */ setupATNFactoryLookup() {\n        this.lexerATNConfigFactory = [];\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.RULE] = (input, config, trans)=>{\n            const newContext = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(config.context ?? void 0, trans.followState.stateNumber);\n            return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(trans.target, config, newContext);\n        };\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE] = ()=>{\n            throw new Error(\"Precedence predicates are not supported in lexers.\");\n        };\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE] = (input, config, trans, configs, speculative)=>{\n            const pt = trans;\n            if (_LexerATNSimulator.debug) console.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n            configs.hasSemanticContext = true;\n            if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(trans.target, config);\n            return null;\n        };\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.ACTION] = (input, config, trans)=>{\n            if (config.context === null || config.context.hasEmptyPath()) {\n                const lexerActionExecutor = $c1efbdb2cbf46748$export$291583ae58f6a758.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);\n                return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithExecutor(config, trans.target, lexerActionExecutor);\n            } else return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(trans.target, config);\n        };\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.EPSILON] = (input, config, trans)=>{\n            return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(trans.target, config);\n        };\n        const simple = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((input, config, trans, configs, speculative, treatEofAsEpsilon)=>{\n            if (treatEofAsEpsilon) {\n                if (trans.matches($c1efbdb2cbf46748$export$50792b0e93539fde.EOF, this.options.minCodePoint, this.options.maxCodePoint)) return $c1efbdb2cbf46748$export$2c28ca15a370dd3e.createWithConfig(trans.target, config);\n            }\n            return null;\n        }, \"simple\");\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.ATOM] = simple;\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.RANGE] = simple;\n        this.lexerATNConfigFactory[$c1efbdb2cbf46748$export$be58926105124dd4.SET] = simple;\n    }\n    /**\n   * Evaluate a predicate specified in the lexer.\n   *\n   * If `speculative` is `true`, this method was called before\n   * {@link consume} for the matched character. This method should call\n   * {@link consume} before evaluating the predicate to ensure position\n   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n   * and {@link Lexer}, properly reflect the current\n   * lexer state. This method should restore `input` and the simulator\n   * to the original state before returning (i.e. undo the actions made by the\n   * call to {@link consume}.\n   *\n   * @param input The input stream.\n   * @param ruleIndex The rule containing the predicate.\n   * @param predIndex The index of the predicate within the rule.\n   * @param speculative `true` if the current index in `input` is\n   * one character before the predicate's location.\n   *\n   * @returns `true` if the specified predicate evaluates to\n   * `true`.\n   */ evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n        if (!this.recognizer) return true;\n        if (!speculative) return this.recognizer.sempred(null, ruleIndex, predIndex);\n        const savedColumn = this.column;\n        const savedLine = this.line;\n        const index = input.index;\n        const marker = input.mark();\n        try {\n            this.consume(input);\n            return this.recognizer.sempred(null, ruleIndex, predIndex);\n        } finally{\n            this.column = savedColumn;\n            this.line = savedLine;\n            input.seek(index);\n            input.release(marker);\n        }\n    }\n    captureSimState(input, dfaState) {\n        this.prevAccept = {\n            index: input.index,\n            line: this.line,\n            column: this.column,\n            dfaState: dfaState\n        };\n    }\n    addDFAEdge(from, tk, to, configs) {\n        if (!to && configs) {\n            const suppressEdge = configs.hasSemanticContext;\n            configs.hasSemanticContext = false;\n            to = this.addDFAState(configs);\n            if (suppressEdge) return to;\n        }\n        if (tk < this.options.minDFAEdge || tk > this.options.maxDFAEdge) return to;\n        if (_LexerATNSimulator.debug) console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + tk);\n        from.edges[tk - this.options.minDFAEdge] = to;\n        return to;\n    }\n    /**\n   * Add a new DFA state if there isn't one with this set of configurations already. This method also detects\n   * the first configuration containing an ATN rule stop state. Later, when traversing the DFA, we will know\n   * which rule to accept.\n   */ addDFAState(configs) {\n        const dfa = this.decisionToDFA[this.mode];\n        const existing = dfa.getStateForConfigs(configs);\n        if (existing) return existing;\n        const proposed = $c1efbdb2cbf46748$export$61470cd35b9c4833.fromConfigs(configs);\n        const firstConfigWithRuleStopState = configs.firstStopState;\n        if (firstConfigWithRuleStopState) {\n            proposed.isAcceptState = true;\n            proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n            proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n        }\n        configs.setReadonly(true);\n        dfa.addState(proposed);\n        return proposed;\n    }\n};\n// src/atn/ParseInfo.ts\nvar $c1efbdb2cbf46748$export$3d86ef9f5652e0c2 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseInfo\");\n    }\n    atnSimulator;\n    constructor(atnSimulator){\n        this.atnSimulator = atnSimulator;\n    }\n    /**\n   * Gets an array of {@link DecisionInfo} instances containing the profiling\n   * information gathered for each decision in the ATN.\n   *\n   * @returns An array of {@link DecisionInfo} instances, indexed by decision\n   * number.\n   */ getDecisionInfo() {\n        return this.atnSimulator.getDecisionInfo();\n    }\n    /**\n   * Gets the decision numbers for decisions that required one or more\n   * full-context predictions during parsing. These are decisions for which\n   * {@link DecisionInfo#llFallback} is non-zero.\n   *\n   * @returns A list of decision numbers which required one or more\n   * full-context predictions during parsing.\n   */ getLLDecisions() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        const result = new Array();\n        for(let i = 0; i < decisions.length; i++){\n            const fallBack = decisions[i].llFallback;\n            if (fallBack > 0) result.push(i);\n        }\n        return result;\n    }\n    /**\n   * Gets the total time spent during prediction across all decisions made\n   * during parsing. This value is the sum of\n   * {@link DecisionInfo#timeInPrediction} for all decisions.\n   */ getTotalTimeInPrediction() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let t = 0;\n        for (const decision of decisions)t += decision.timeInPrediction;\n        return t;\n    }\n    /**\n   * Gets the total number of SLL lookahead operations across all decisions\n   * made during parsing. This value is the sum of\n   * {@link DecisionInfo#sllTotalLook} for all decisions.\n   */ getTotalSLLLookaheadOps() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let k = 0;\n        for (const decision of decisions)k += decision.sllTotalLook;\n        return k;\n    }\n    /**\n   * Gets the total number of LL lookahead operations across all decisions\n   * made during parsing. This value is the sum of\n   * {@link DecisionInfo#llTotalLook} for all decisions.\n   */ getTotalLLLookaheadOps() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let k = 0;\n        for (const decision of decisions)k += decision.llTotalLook;\n        return k;\n    }\n    /**\n   * Gets the total number of ATN lookahead operations for SLL prediction\n   * across all decisions made during parsing.\n   */ getTotalSLLATNLookaheadOps() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let k = 0;\n        for (const decision of decisions)k += decision.sllATNTransitions;\n        return k;\n    }\n    /**\n   * Gets the total number of ATN lookahead operations for LL prediction\n   * across all decisions made during parsing.\n   */ getTotalLLATNLookaheadOps() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let k = 0;\n        for (const decision of decisions)k += decision.llATNTransitions;\n        return k;\n    }\n    /**\n   * Gets the total number of ATN lookahead operations for SLL and LL\n   * prediction across all decisions made during parsing.\n   *\n   *\n   * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and\n   * {@link #getTotalLLATNLookaheadOps}.\n   */ getTotalATNLookaheadOps() {\n        const decisions = this.atnSimulator.getDecisionInfo();\n        let k = 0;\n        for (const decision of decisions){\n            k += decision.sllATNTransitions;\n            k += decision.llATNTransitions;\n        }\n        return k;\n    }\n    getDFASize(decision) {\n        if (decision === void 0) {\n            let n2 = 0;\n            const decisionToDFA = this.atnSimulator.decisionToDFA;\n            for(let i = 0; i < decisionToDFA.length; i++)n2 += this.getDFASize(i);\n            return n2;\n        } else {\n            const decisionToDFA = this.atnSimulator.decisionToDFA[decision];\n            return decisionToDFA.length;\n        }\n    }\n};\n// src/NoViableAltException.ts\nvar $c1efbdb2cbf46748$export$24170894ee7a3e61 = class extends $c1efbdb2cbf46748$export$c1c401305ad687ac {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"NoViableAltException\");\n    }\n    /** Which configurations did we try at input.index() that couldn't match input.LT(1)? */ deadEndConfigs = null;\n    /**\n   * The token object at the start index; the input stream might\n   * \tnot be buffering tokens so get a reference to it. (At the\n   *  time the error occurred, of course the stream needs to keep a\n   *  buffer all of the tokens but later we might not have access to those.)\n   */ startToken;\n    constructor(recognizer, input = null, startToken = null, offendingToken = null, deadEndConfigs = null, ctx = null){\n        ctx = ctx ?? recognizer.context;\n        offendingToken = offendingToken ?? recognizer.getCurrentToken();\n        startToken = startToken ?? recognizer.getCurrentToken();\n        input = input ?? recognizer.inputStream;\n        super({\n            message: \"\",\n            recognizer: recognizer,\n            input: input,\n            ctx: ctx\n        });\n        this.deadEndConfigs = deadEndConfigs;\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n};\n// src/utils/DoubleDict.ts\nvar $c1efbdb2cbf46748$export$5c60622321c5364e = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DoubleDict\");\n    }\n    cacheMap;\n    constructor(){\n        this.cacheMap = new $c1efbdb2cbf46748$export$60ef0b43d585640a();\n    }\n    get(a, b) {\n        const d = this.cacheMap.get(a) ?? null;\n        return d === null ? null : d.get(b) ?? null;\n    }\n    set(a, b, o) {\n        let d = this.cacheMap.get(a);\n        if (!d) {\n            d = new $c1efbdb2cbf46748$export$60ef0b43d585640a();\n            this.cacheMap.set(a, d);\n        }\n        d.set(b, o);\n    }\n};\n// src/atn/PredictionMode.ts\nvar $c1efbdb2cbf46748$var$SubsetEqualityComparer = class _SubsetEqualityComparer {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"SubsetEqualityComparer\");\n    }\n    static instance = new _SubsetEqualityComparer();\n    hashCode(config) {\n        let hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.initialize(7);\n        hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.update(hashCode, config.state.stateNumber);\n        hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.updateFromComparable(hashCode, config.context);\n        hashCode = $c1efbdb2cbf46748$export$27c628f6789aefe9.finish(hashCode, 2);\n        return hashCode;\n    }\n    equals(a, b) {\n        return a.state.stateNumber === b.state.stateNumber && (a.context?.equals(b.context) ?? true);\n    }\n};\nvar $c1efbdb2cbf46748$export$a8734b9e3c538260 = class _PredictionMode {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PredictionMode\");\n    }\n    /**\n   * The SLL(*) prediction mode. This prediction mode ignores the current\n   * parser context when making predictions. This is the fastest prediction\n   * mode, and provides correct results for many grammars. This prediction\n   * mode is more powerful than the prediction mode provided by ANTLR 3, but\n   * may result in syntax errors for grammar and input combinations which are\n   * not SLL.\n   *\n   *\n   * When using this prediction mode, the parser will either return a correct\n   * parse tree (i.e. the same parse tree that would be returned with the\n   * {@link LL} prediction mode), or it will report a syntax error. If a\n   * syntax error is encountered when using the {@link SLL} prediction mode,\n   * it may be due to either an actual syntax error in the input or indicate\n   * that the particular combination of grammar and input requires the more\n   * powerful {@link LL} prediction abilities to complete successfully.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */ static SLL = 0;\n    /**\n   * The LL(*) prediction mode. This prediction mode allows the current parser\n   * context to be used for resolving SLL conflicts that occur during\n   * prediction. This is the fastest prediction mode that guarantees correct\n   * parse results for all combinations of grammars with syntactically correct\n   * inputs.\n   *\n   *\n   * When using this prediction mode, the parser will make correct decisions\n   * for all syntactically-correct grammar and input combinations. However, in\n   * cases where the grammar is truly ambiguous this prediction mode might not\n   * report a precise answer for *exactly which* alternatives are\n   * ambiguous.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */ static LL = 1;\n    /**\n   *\n   * The LL(*) prediction mode with exact ambiguity detection. In addition to\n   * the correctness guarantees provided by the {@link LL} prediction mode,\n   * this prediction mode instructs the prediction algorithm to determine the\n   * complete and exact set of ambiguous alternatives for every ambiguous\n   * decision encountered while parsing.\n   *\n   *\n   * This prediction mode may be used for diagnosing ambiguities during\n   * grammar development. Due to the performance overhead of calculating sets\n   * of ambiguous alternatives, this prediction mode should be avoided when\n   * the exact results are not necessary.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */ static LL_EXACT_AMBIG_DETECTION = 2;\n    /**\n   *\n   *Computes the SLL prediction termination condition.\n   *\n   *\n   *This method computes the SLL prediction termination condition for both of\n   *the following cases.\n   *\n   * - The usual SLL+LL fallback upon SLL conflict\n   * - Pure SLL without LL fallback\n   *\n   ***COMBINED SLL+LL PARSING**\n   *\n   *When LL-fallback is enabled upon SLL conflict, correct predictions are\n   *ensured regardless of how the termination condition is computed by this\n   *method. Due to the substantially higher cost of LL prediction, the\n   *prediction should only fall back to LL when the additional lookahead\n   *cannot lead to a unique SLL prediction.\n   *\n   *Assuming combined SLL+LL parsing, an SLL configuration set with only\n   *conflicting subsets should fall back to full LL, even if the\n   *configuration sets don't resolve to the same alternative (e.g.\n   *`{1,2`} and `{3,4`}. If there is at least one non-conflicting\n   *configuration, SLL could continue with the hopes that more lookahead will\n   *resolve via one of those non-conflicting configurations.\n   *\n   *Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n   *stops when it sees only conflicting configuration subsets. In contrast,\n   *full LL keeps going when there is uncertainty.\n   *\n   ***HEURISTIC**\n   *\n   *As a heuristic, we stop prediction when we see any conflicting subset\n   *unless we see a state that only has one alternative associated with it.\n   *The single-alt-state thing lets prediction continue upon rules like\n   *(otherwise, it would admit defeat too soon):\n   *\n   *`[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;`\n   *\n   *When the ATN simulation reaches the state before `';'`, it has a\n   *DFA state that looks like: `[12|1|[], 6|2|[], 12|2|[]]`. Naturally\n   *`12|1|[]` and `12|2|[]` conflict, but we cannot stop\n   *processing this node because alternative to has another way to continue,\n   *via `[6|2|[]]`.\n   *\n   *It also let's us continue for this rule:\n   *\n   *`[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;`\n   *\n   *After matching input A, we reach the stop state for rule A, state 1.\n   *State 8 is the state right before B. Clearly alternatives 1 and 2\n   *conflict and no amount of further lookahead will separate the two.\n   *However, alternative 3 will be able to continue and so we do not stop\n   *working on this state. In the previous example, we're concerned with\n   *states associated with the conflicting alternatives. Here alt 3 is not\n   *associated with the conflicting configs, but since we can continue\n   *looking for input reasonably, don't declare the state done.\n   *\n   ***PURE SLL PARSING**\n   *\n   *To handle pure SLL parsing, all we have to do is make sure that we\n   *combine stack contexts for configurations that differ only by semantic\n   *predicate. From there, we can do the usual SLL termination heuristic.\n   *\n   ***PREDICATES IN SLL+LL PARSING**\n   *\n   *SLL decisions don't evaluate predicates until after they reach DFA stop\n   *states because they need to create the DFA cache that works in all\n   *semantic situations. In contrast, full LL evaluates predicates collected\n   *during start state computation so it can ignore predicates thereafter.\n   *This means that SLL termination detection can totally ignore semantic\n   *predicates.\n   *\n   *Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n   *semantic predicate contexts so we might see two configurations like the\n   *following.\n   *\n   *`(s, 1, x, {`), (s, 1, x', {p})}\n   *\n   *Before testing these configurations against others, we have to merge\n   *`x` and `x'` (without modifying the existing configurations).\n   *For example, we test `(x+x')==x''` when looking for conflicts in\n   *the following configurations.\n   *\n   *`(s, 1, x, {`), (s, 1, x', {p}), (s, 2, x'', {})}\n   *\n   *If the configuration set has predicates (as indicated by\n   *{@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n   *the configurations to strip out all of the predicates so that a standard\n   *{@link ATNConfigSet} will merge everything ignoring predicates.\n   */ static hasSLLConflictTerminatingPrediction(mode, configs) {\n        if (_PredictionMode.allConfigsInRuleStopStates(configs)) return true;\n        if (mode === _PredictionMode.SLL) {\n            if (configs.hasSemanticContext) {\n                const dup = new $c1efbdb2cbf46748$export$3e159d9d82bfca90();\n                for (let c of configs){\n                    c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.duplicate(c, $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n        }\n        const altSets = _PredictionMode.getConflictingAltSubsets(configs);\n        return _PredictionMode.hasConflictingAltSet(altSets) && !_PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    }\n    /**\n   * Checks if any configuration in `configs` is in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @returns `true` if any configuration in `configs` is in a\n   * {@link RuleStopState}, otherwise `false`\n   */ static hasConfigInRuleStopState(configs) {\n        for (const c of configs){\n            if (c.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks if all configurations in `configs` are in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @returns `true` if all configurations in `configs` are in a\n   * {@link RuleStopState}, otherwise `false`\n   */ static allConfigsInRuleStopStates(configs) {\n        for (const c of configs){\n            if (!(c.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c)) return false;\n        }\n        return true;\n    }\n    /**\n   *\n   * Full LL prediction termination.\n   *\n   * Can we stop looking ahead during ATN simulation or is there some\n   * uncertainty as to which alternative we will ultimately pick, after\n   * consuming more input? Even if there are partial conflicts, we might know\n   * that everything is going to resolve to the same minimum alternative. That\n   * means we can stop since no more lookahead will change that fact. On the\n   * other hand, there might be multiple conflicts that resolve to different\n   * minimums. That means we need more look ahead to decide which of those\n   * alternatives we should predict.\n   *\n   * The basic idea is to split the set of configurations `C`, into\n   * conflicting subsets `(s, _, ctx, _)` and singleton subsets with\n   * non-conflicting configurations. Two configurations conflict if they have\n   * identical {@link ATNConfig.state} and {@link ATNConfig.context} values\n   * but different {@link ATNConfig.alt} value, e.g. `(s, i, ctx, _)`\n   * and `(s, j, ctx, _)` for `i!=j`.\n   *\n   * Reduce these configuration subsets to the set of possible alternatives.\n   * You can compute the alternative subsets in one pass as follows:\n   *\n   * `A_s,ctx = {i | (s, i, ctx, _)`} for each configuration in\n   * `C` holding `s` and `ctx` fixed.\n   *\n   * Or in pseudo-code, for each configuration `c` in `C`:\n   *\n   * ```\n   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * ```\n   *\n   * The values in `map` are the set of `A_s,ctx` sets.\n   *\n   * If `|A_s,ctx|=1` then there is no conflict associated with\n   * `s` and `ctx`.\n   *\n   * Reduce the subsets to singletons by choosing a minimum of each subset. If\n   * the union of these alternative subsets is a singleton, then no amount of\n   * more lookahead will help us. We will always pick that alternative. If,\n   * however, there is more than one alternative, then we are uncertain which\n   * alternative to predict and must continue looking for resolution. We may\n   * or may not discover an ambiguity in the future, even if there are no\n   * conflicting subsets this round.\n   *\n   * The biggest sin is to terminate early because it means we've made a\n   * decision but were uncertain as to the eventual outcome. We haven't used\n   * enough lookahead. On the other hand, announcing a conflict too late is no\n   * big deal; you will still have the conflict. It's just inefficient. It\n   * might even look until the end of file.\n   *\n   * No special consideration for semantic predicates is required because\n   * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n   * no configuration contains a semantic context during the termination\n   * check.\n   *\n   * **CONFLICTING CONFIGS**\n   *\n   * Two configurations `(s, i, x)` and `(s, j, x')`, conflict when `i!=j` but `x=x'`. Because we merge all\n   * `(s, i, _)` configurations together, that means that there are at most `n` configurations associated with state\n   * `s` for `n` possible alternatives in the decision. The merged stacks complicate the comparison of configuration\n   * contexts `x` and `x'`. Sam checks to see if one is a subset of the other by calling merge and checking to see\n   * if the merged result is either `x` or `x'`. If the `x` associated with lowest alternative `i` is the superset,\n   * then `i` is the only possible prediction since the others resolve to `min(i)` as well. However, if `x` is\n   * associated with `j>i` then at least one stack configuration for `j` is not in conflict with alternative `i`.\n   * The algorithm should keep going, looking for more lookahead due to the uncertainty.\n   *\n   * For simplicity, I'm doing a equality check between `x` and `x'` that lets the algorithm continue to consume\n   * lookahead longer than necessary. The reason I like the equality is of course the simplicity but also because\n   * that is the test you need to detect the alternatives that are actually in conflict.\n   *\n   * **CONTINUE/STOP RULE**\n   *\n   * Continue if union of resolved alternative sets from non-conflicting and conflicting alternative subsets has more\n   * than one alternative. We are uncertain about which alternative to predict.\n   *\n   * The complete set of alternatives, `[i for (_,i,_)]`, tells us which alternatives are still in the running for\n   * the amount of input we've consumed at this point. The conflicting sets let us to strip away configurations that\n   * won't lead to more states because we resolve conflicts to the configuration with a minimum alternate for the\n   * conflicting set.\n   *\n   * **CASES**\n   *\n   * - no conflicts and more than 1 alternative in set => continue\n   * -  `(s, 1, x)`, `(s, 2, x)`, `(s, 3, z)`, `(s', 1, y)`, `(s', 2, y)` yields non-conflicting set `{3`} U\n   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1,3`} => continue\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)`, `(s'', 1, z)` yields non-conflicting set `{1`} U\n   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1`} => stop and predict 1\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)` yields conflicting, reduced sets `{1`} U\n   *   `{1`} = `{1`} => stop and predict 1, can announce ambiguity `{1,2`}\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 2, y)`, `(s', 3, y)` yields conflicting, reduced sets `{1`} U\n   *   `{2`} = `{1,2`} => continue\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 3, y)`, `(s', 4, y)` yields conflicting, reduced sets `{1`} U\n   *   `{3`} = `{1,3`} => continue\n   *\n   * **EXACT AMBIGUITY DETECTION**\n   *\n   *If all states report the same conflicting set of alternatives, then we\n   *know we have the exact ambiguity set.\n   *\n   * `|A_*i*|>1` and `A_*i* = A_*j*` for all *i*, *j*.\n   *\n   * In other words, we continue examining lookahead until all `A_i` have more than one alternative and all `A_i`\n   * are the same. If `A={{1,2`, {1,3}}}, then regular LL prediction would terminate because the resolved set\n   * is `{1`}. To determine what the real ambiguity is, we have to know whether the ambiguity is between one and\n   * two or one and three so we keep going. We can only stop prediction when we need exact ambiguity detection when\n   * the sets look like `A={{1,2`}} or `{{1,2`,{1,2}}}, etc...\n   */ static resolvesToJustOneViableAlt(altSets) {\n        return _PredictionMode.getSingleViableAlt(altSets);\n    }\n    /**\n   * Determines if every alternative subset in `altSets` contains more\n   * than one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if every {@link BitSet} in `altSets` has\n   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`\n   */ static allSubsetsConflict(altSets) {\n        return !_PredictionMode.hasNonConflictingAltSet(altSets);\n    }\n    /**\n   * Determines if any single alternative subset in `altSets` contains\n   * exactly one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if `altSets` contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} 1, otherwise `false`\n   */ static hasNonConflictingAltSet(altSets) {\n        for (const alts of altSets){\n            if (alts.length === 1) return true;\n        }\n        return false;\n    }\n    /**\n   * Determines if any single alternative subset in `altSets` contains\n   * more than one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if `altSets` contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`\n   */ static hasConflictingAltSet(altSets) {\n        for (const alts of altSets){\n            if (alts.length > 1) return true;\n        }\n        return false;\n    }\n    /**\n   * Determines if every alternative subset in `altSets` is equivalent.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if every member of `altSets` is equal to the\n   * others, otherwise `false`\n   */ static allSubsetsEqual(altSets) {\n        let first = null;\n        for (const alts of altSets){\n            if (first === null) first = alts;\n            else if (alts !== first) return false;\n        }\n        return true;\n    }\n    /**\n   * Returns the unique alternative predicted by all alternative subsets in\n   * `altSets`. If no such alternative exists, this method returns\n   * {@link ATN.INVALID_ALT_NUMBER}.\n   *\n   * @param altSets a collection of alternative subsets\n   */ static getUniqueAlt(altSets) {\n        const all = _PredictionMode.getAlts(altSets);\n        if (all.length === 1) return all.nextSetBit(0);\n        else return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n    }\n    /**\n   * Gets the complete set of represented alternatives for a collection of\n   * alternative subsets. This method returns the union of each {@link BitSet}\n   * in `altSets`.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns the set of represented alternatives in `altSets`\n   */ static getAlts(altSets) {\n        const all = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n        altSets.forEach((alts)=>{\n            all.or(alts);\n        });\n        return all;\n    }\n    /**\n   * This function gets the conflicting alt subsets from a configuration set.\n   * For each configuration `c` in `configs`:\n   *\n   * ```\n   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * ```\n   */ static getConflictingAltSubsets(configs) {\n        const configToAlts = new $c1efbdb2cbf46748$export$60ef0b43d585640a($c1efbdb2cbf46748$var$SubsetEqualityComparer.instance);\n        for (const cfg of configs){\n            let alts = configToAlts.get(cfg);\n            if (!alts) {\n                alts = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n                configToAlts.set(cfg, alts);\n            }\n            alts.set(cfg.alt);\n        }\n        return Array.from(configToAlts.values());\n    }\n    /**\n   * Get a map from state to alt subset from a configuration set. For each configuration `c` in `configs`:\n   *\n   * ```\n   * map[c.state] = c.alt\n   * ```\n   */ static getStateToAltMap(configs) {\n        const m2 = new $c1efbdb2cbf46748$export$60ef0b43d585640a($c1efbdb2cbf46748$var$ObjectEqualityComparator.instance);\n        for (const c of configs){\n            let alts = m2.get(c.state);\n            if (!alts) {\n                alts = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n                m2.set(c.state, alts);\n            }\n            alts.set(c.alt);\n        }\n        return m2;\n    }\n    static hasStateAssociatedWithOneAlt(configs) {\n        const counts = {};\n        for (const c of configs){\n            const stateNumber = c.state.stateNumber;\n            if (!counts[stateNumber]) counts[stateNumber] = 0;\n            counts[stateNumber]++;\n        }\n        return Object.values(counts).some((count)=>{\n            return count === 1;\n        });\n    }\n    static getSingleViableAlt(altSets) {\n        let result = null;\n        for (const alts of altSets){\n            const minAlt = alts.nextSetBit(0);\n            if (result === null) result = minAlt;\n            else if (result !== minAlt) return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        }\n        return result ?? 0;\n    }\n};\n// src/atn/ParserATNSimulator.ts\nvar $c1efbdb2cbf46748$export$7baac15c7bd92e00 = class _ParserATNSimulator extends $c1efbdb2cbf46748$export$b12c0eaae78de602 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParserATNSimulator\");\n    }\n    static traceATNSimulator = false;\n    static debug;\n    static debugAdd = false;\n    static debugClosure = false;\n    static dfaDebug = false;\n    static retryDebug = false;\n    /** SLL, LL, or LL + exact ambig detection? */ predictionMode;\n    decisionToDFA;\n    parser;\n    /**\n   * Each prediction operation uses a cache for merge of prediction contexts.\n   * Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n   * isn't synchronized but we're ok since two threads shouldn't reuse same\n   * parser/atn sim object because it can only handle one input at a time.\n   * This maps graphs a and b to merged result c. (a,b)->c. We can avoid\n   * the merge if we ever see a and b again.  Note that (b,a)->c should\n   * also be examined during cache lookup.\n   */ mergeCache = new $c1efbdb2cbf46748$export$5c60622321c5364e();\n    // Used also in the profiling ATN simulator.\n    predictionState;\n    constructor(recog, atn, decisionToDFA, sharedContextCache){\n        super(atn, sharedContextCache);\n        this.parser = recog;\n        this.decisionToDFA = decisionToDFA;\n    }\n    static getUniqueAlt(configs) {\n        let alt = $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        for (const c of configs){\n            if (alt === $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) alt = c.alt;\n            else if (c.alt !== alt) return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        }\n        return alt;\n    }\n    reset() {}\n    clearDFA() {\n        for(let d = 0; d < this.decisionToDFA.length; d++)this.decisionToDFA[d] = new $c1efbdb2cbf46748$export$d210bcfe90c75f0(this.atn.getDecisionState(d), d);\n    }\n    // TODO: make outerContext an optional parameter, not optional null.\n    adaptivePredict(input, decision, outerContext) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) console.log(\"adaptivePredict decision \" + decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        const dfa = this.decisionToDFA[decision];\n        this.predictionState = {\n            input: input,\n            startIndex: input.index,\n            outerContext: outerContext ?? void 0,\n            dfa: dfa\n        };\n        const m2 = input.mark();\n        const index = input.index;\n        try {\n            let s0;\n            if (dfa.isPrecedenceDfa) s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            else s0 = dfa.s0;\n            if (!s0) {\n                if (!outerContext) outerContext = $c1efbdb2cbf46748$export$1198dca6f94b6253.empty;\n                if (_ParserATNSimulator.debug) console.log(\"predictATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, $c1efbdb2cbf46748$export$1198dca6f94b6253.empty, fullCtx);\n                if (dfa.isPrecedenceDfa) {\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, $c1efbdb2cbf46748$export$61470cd35b9c4833.fromConfigs(s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, $c1efbdb2cbf46748$export$61470cd35b9c4833.fromConfigs(s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (_ParserATNSimulator.debug) console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.vocabulary));\n            return alt;\n        } finally{\n            this.predictionState.dfa = void 0;\n            this.mergeCache = new $c1efbdb2cbf46748$export$5c60622321c5364e();\n            input.seek(index);\n            input.release(m2);\n        }\n    }\n    /**\n   * Performs ATN simulation to compute a predicted alternative based\n   *  upon the remaining input, but also updates the DFA cache to avoid\n   *  having to traverse the ATN again for the same input sequence.\n   *\n   * There are some key conditions we're looking for after computing a new\n   * set of ATN configs (proposed DFA state):\n   *       if the set is empty, there is no viable alternative for current symbol\n   *       does the state uniquely predict an alternative?\n   *       does the state have a conflict that would prevent us from\n   *         putting it on the work list?\n   *\n   * We also have some key operations to do:\n   *       add an edge from previous DFA state to potentially new DFA state, D,\n   *         upon current symbol but only if adding to work list, which means in all\n   *         cases except no viable alternative (and possibly non-greedy decisions?)\n   *       collecting predicates and adding semantic context to DFA accept states\n   *       adding rule context to context-sensitive DFA accept states\n   *       consuming an input symbol\n   *       reporting a conflict\n   *       reporting an ambiguity\n   *       reporting a context sensitivity\n   *       reporting insufficient predicates\n   *\n   * cover these cases:\n   *    dead end\n   *    single alt\n   *    single alt + preds\n   *    conflict\n   *    conflict + preds\n   */ execATN(dfa, s0, input, startIndex, outerContext) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) console.log(\"execATN decision \" + dfa.decision + \", DFA state \" + s0 + \", LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        let alt;\n        let previousState = s0;\n        let t = input.LA(1);\n        while(true){\n            let nextState = this.getExistingTargetState(previousState, t);\n            if (!nextState) nextState = this.computeTargetState(dfa, previousState, t);\n            if (nextState === $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR) {\n                const e = this.noViableAlt(input, outerContext, previousState.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousState.configs, outerContext);\n                if (alt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) return alt;\n                else throw e;\n            }\n            if (nextState.requiresFullContext && this.predictionMode !== $c1efbdb2cbf46748$export$a8734b9e3c538260.SLL) {\n                let conflictingAlts = null;\n                if (nextState.predicates !== null) {\n                    if (_ParserATNSimulator.debug) console.log(\"DFA state has preds in DFA sim LL failover\");\n                    const conflictIndex = input.index;\n                    if (conflictIndex !== startIndex) input.seek(startIndex);\n                    conflictingAlts = this.evalSemanticContext(nextState.predicates, outerContext, true);\n                    if (conflictingAlts.length === 1) {\n                        if (_ParserATNSimulator.debug) console.log(\"Full LL avoided\");\n                        return conflictingAlts.nextSetBit(0);\n                    }\n                    if (conflictIndex !== startIndex) input.seek(conflictIndex);\n                }\n                if (_ParserATNSimulator.dfaDebug) console.log(\"ctx sensitive state \" + outerContext + \" in \" + nextState);\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, nextState, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (nextState.isAcceptState) {\n                if (nextState.predicates === null) return nextState.prediction;\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(nextState.predicates, outerContext, true);\n                if (alts.length === 0) throw this.noViableAlt(input, outerContext, nextState.configs, startIndex);\n                if (alts.length === 1) return alts.nextSetBit(0);\n                this.reportAmbiguity(dfa, nextState, startIndex, stopIndex, false, alts, nextState.configs);\n                return alts.nextSetBit(0);\n            }\n            previousState = nextState;\n            if (t !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n    /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns `null`.\n   *\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   * @returns The existing target DFA state for the given input symbol\n   * `t`, or `null` if the target state for this edge is not\n   * already cached\n   */ getExistingTargetState(previousD, t) {\n        return previousD.edges[t + 1];\n    }\n    /**\n   * Compute a target state for an edge in the DFA, and attempt to add the\n   * computed state and corresponding edge to the DFA.\n   *\n   * @param dfa The DFA\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   *\n   * @returns The computed target DFA state for the given input symbol\n   * `t`. If `t` does not lead to a valid DFA state, this method\n   * returns {@link ERROR\n   */ computeTargetState(dfa, previousD, t) {\n        const reach = this.computeReachSet(previousD.configs, t, false);\n        if (reach === null) {\n            this.addDFAEdge(dfa, previousD, t, $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR);\n            return $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR;\n        }\n        let D = $c1efbdb2cbf46748$export$61470cd35b9c4833.fromConfigs(reach);\n        const predictedAlt = _ParserATNSimulator.getUniqueAlt(reach);\n        if (_ParserATNSimulator.debug) {\n            const altSubSets = $c1efbdb2cbf46748$export$a8734b9e3c538260.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + $c1efbdb2cbf46748$export$4323cc4280d5be7(altSubSets) + /*\", previous=\" + previousD.configs + */ \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + $c1efbdb2cbf46748$export$a8734b9e3c538260.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + this.getConflictingAlts(reach));\n        }\n        if (predictedAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) {\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if ($c1efbdb2cbf46748$export$a8734b9e3c538260.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.nextSetBit(0);\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if (D.predicates !== null) D.prediction = $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        }\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n    getRuleName(index) {\n        if (this.parser !== null && index >= 0) return this.parser.ruleNames[index];\n        else return \"<rule \" + index + \">\";\n    }\n    getTokenName(t) {\n        if (t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return \"EOF\";\n        const vocabulary = this.parser?.vocabulary ?? $c1efbdb2cbf46748$export$6fe78fc0b86aec88.EMPTY_VOCABULARY;\n        const displayName = vocabulary.getDisplayName(t);\n        if (displayName === t.toString()) return displayName;\n        return displayName + \"<\" + t + \">\";\n    }\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n    /**\n   * Used for debugging in adaptivePredict around execATN but I cut\n   * it out for clarity now that alg. works well. We can leave this\n   * \"dead\" code for a bit\n   */ dumpDeadEndConfigs(e) {\n        console.log(\"dead end configs: \");\n        const decs = e.deadEndConfigs;\n        for (const c of decs){\n            let trans = \"no edges\";\n            if (c.state.transitions.length > 0) {\n                const t = c.state.transitions[0];\n                if (t instanceof $c1efbdb2cbf46748$export$749c9accb19d603f) trans = \"Atom \" + this.getTokenName(t.labelValue);\n                else if (t instanceof $c1efbdb2cbf46748$export$10de5c396f79e800) {\n                    const neg = t instanceof $c1efbdb2cbf46748$export$a0e4d5a57a08628e;\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.label;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n    predicateDFAState(dfaState, decisionState) {\n        const altCount = decisionState.transitions.length;\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, altCount);\n        if (altToPred !== null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        } else dfaState.prediction = altsToCollectPredsFrom.nextSetBit(0);\n    }\n    // comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) console.log(\"execATNWithFullContext \" + s0);\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        for(;;){\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach === null) {\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if (alt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) return alt;\n                else throw e;\n            }\n            const altSubSets = $c1efbdb2cbf46748$export$a8734b9e3c538260.getConflictingAltSubsets(reach);\n            if (_ParserATNSimulator.debug) console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" + $c1efbdb2cbf46748$export$a8734b9e3c538260.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" + $c1efbdb2cbf46748$export$a8734b9e3c538260.resolvesToJustOneViableAlt(altSubSets));\n            reach.uniqueAlt = _ParserATNSimulator.getUniqueAlt(reach);\n            if (reach.uniqueAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== $c1efbdb2cbf46748$export$a8734b9e3c538260.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = $c1efbdb2cbf46748$export$a8734b9e3c538260.resolvesToJustOneViableAlt(altSubSets);\n                if (predictedAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) break;\n            } else if ($c1efbdb2cbf46748$export$a8734b9e3c538260.allSubsetsConflict(altSubSets) && $c1efbdb2cbf46748$export$a8734b9e3c538260.allSubsetsEqual(altSubSets)) {\n                foundExactAmbig = true;\n                predictedAlt = $c1efbdb2cbf46748$export$a8734b9e3c538260.getSingleViableAlt(altSubSets);\n                break;\n            }\n            previous = reach;\n            if (t !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        if (reach.uniqueAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, reach.getAlts(), reach);\n        return predictedAlt;\n    }\n    computeReachSet(closure, t, fullCtx) {\n        if (_ParserATNSimulator.debug) console.log(\"in computeReachSet, starting closure: \" + closure);\n        const intermediate = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(fullCtx);\n        let skippedStopStates = null;\n        for (const c of closure){\n            if (_ParserATNSimulator.debug) console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            if (c.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) {\n                if (fullCtx || t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                    if (skippedStopStates === null) skippedStopStates = [];\n                    skippedStopStates.push(c);\n                }\n                continue;\n            }\n            for (const trans of c.state.transitions){\n                const target = this.getReachableTarget(trans, t);\n                if (target !== null) {\n                    const cfg = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(target, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if (_ParserATNSimulator.debugAdd) console.log(\"added \" + cfg + \" to intermediate\");\n                }\n            }\n        }\n        let reach = null;\n        if (skippedStopStates === null && t !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n            if (intermediate.length === 1) reach = intermediate;\n            else if (_ParserATNSimulator.getUniqueAlt(intermediate) !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) reach = intermediate;\n        }\n        if (reach === null) {\n            reach = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(fullCtx);\n            const closureBusy = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n            const treatEofAsEpsilon = t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF;\n            for (const config of intermediate)this.closure(config, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n        }\n        if (t === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        if (skippedStopStates !== null && (!fullCtx || !$c1efbdb2cbf46748$export$a8734b9e3c538260.hasConfigInRuleStopState(reach))) for (const config of skippedStopStates)reach.add(config, this.mergeCache);\n        if (_ParserATNSimulator.traceATNSimulator) console.log(\"computeReachSet \" + closure + \" -> \" + reach);\n        if (reach.length === 0) return null;\n        else return reach;\n    }\n    /**\n   * Return a configuration set containing only the configurations from\n   * `configs` which are in a {@link RuleStopState}. If all\n   * configurations in `configs` are already in a rule stop state, this\n   * method simply returns `configs`.\n   *\n   * When `lookToEndOfRule` is true, this method uses\n   * {@link ATN.nextTokens} for each configuration in `configs` which is\n   * not already in a rule stop state to see if a rule stop state is reachable\n   * from the configuration via epsilon-only transitions.\n   *\n   * @param configs the configuration set to update\n   * @param lookToEndOfRule when true, this method checks for rule stop states\n   * reachable by epsilon-only transitions from each configuration in\n   * `configs`.\n   *\n   * @returns `configs` if all configurations in `configs` are in a\n   * rule stop state, otherwise return a new configuration set containing only\n   * the configurations from `configs` which are in a rule stop state\n   */ removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if ($c1efbdb2cbf46748$export$a8734b9e3c538260.allConfigsInRuleStopStates(configs)) return configs;\n        const result = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(configs.fullCtx);\n        for (const config of configs){\n            if (config.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add($c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(endOfRuleState, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n    computeStartState(p, ctx, fullCtx) {\n        const initialContext = $c1efbdb2cbf46748$export$c1f97ac8322a726f(this.atn, ctx);\n        const configs = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(fullCtx);\n        if (_ParserATNSimulator.traceATNSimulator) console.log(\"computeStartState from ATN state \" + p + \" initialContext=\" + initialContext.toString(this.parser));\n        for(let i = 0; i < p.transitions.length; i++){\n            const target = p.transitions[i].target;\n            const c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithContext(target, i + 1, initialContext);\n            const closureBusy = new $c1efbdb2cbf46748$export$9d0bf21c11057332();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n    /**\n   * This method transforms the start state computed by\n   * {@link computeStartState} to the special start state used by a\n   * precedence DFA for a particular precedence value. The transformation\n   * process applies the following changes to the start state's configuration\n   * set.\n   *\n   * 1. Evaluate the precedence predicates for each configuration using\n   * {@link SemanticContext//evalPrecedence}.\n   * 2. Remove all configurations which predict an alternative greater than\n   * 1, for which another configuration that predicts alternative 1 is in the\n   * same ATN state with the same prediction context. This transformation is\n   * valid for the following reasons:\n   * 3. The closure block cannot contain any epsilon transitions which bypass\n   * the body of the closure, so all states reachable via alternative 1 are\n   * part of the precedence alternatives of the transformed left-recursive\n   * rule.\n   * 4. The \"primary\" portion of a left recursive rule cannot contain an\n   * epsilon transition, so the only way an alternative other than 1 can exist\n   * in a state that is also reachable via alternative 1 is by nesting calls\n   * to the left-recursive rule, with the outer calls not being at the\n   * preferred precedence level.\n   *\n   *\n   * The prediction context must be considered by this filter to address\n   * situations like the following.\n   *\n   * `\n   * ```\n   * grammar TA;\n   * prog: statement* EOF;\n   * statement: letterA | statement letterA 'b' ;\n   * letterA: 'a';\n   * ```\n   * `\n   *\n   * If the above grammar, the ATN state immediately before the token\n   * reference `'a'` in `letterA` is reachable from the left edge\n   * of both the primary and closure blocks of the left-recursive rule\n   * `statement`. The prediction context associated with each of these\n   * configurations distinguishes between them, and prevents the alternative\n   * which stepped out to `prog` (and then back in to `statement`\n   * from being eliminated by the filter.\n   *\n   * @param configs The configuration set computed by\n   * {@link computeStartState} as the start state for the DFA.\n   * @returns The transformed configuration set representing the start state\n   * for a precedence DFA at a particular precedence level (determined by\n   * calling {@link Parser//getPrecedence})\n   */ applyPrecedenceFilter(configs) {\n        const statesFromAlt1 = [];\n        const configSet = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(configs.fullCtx);\n        for (const config of configs){\n            if (config.alt !== 1) continue;\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this.predictionState.outerContext);\n            if (updatedContext === null) continue;\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) configSet.add($c1efbdb2cbf46748$export$b371505ec63d1c9b.duplicate(config, updatedContext), this.mergeCache);\n            else configSet.add(config, this.mergeCache);\n        }\n        for (const config of configs){\n            if (config.alt === 1) continue;\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context !== null && context.equals(config.context)) continue;\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) return trans.target;\n        else return null;\n    }\n    getPredsForAmbigAlts(ambigAlts, configs, altCount) {\n        let altToPred = [];\n        for (const c of configs)if (ambigAlts.get(c.alt)) altToPred[c.alt] = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.orContext(altToPred[c.alt] ?? null, c.semanticContext);\n        let nPredAlts = 0;\n        for(let i = 1; i < altCount + 1; i++){\n            const pred = altToPred[i] ?? null;\n            if (pred === null) altToPred[i] = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE;\n            else if (pred !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) nPredAlts += 1;\n        }\n        if (nPredAlts === 0) altToPred = null;\n        if (_ParserATNSimulator.debug) console.log(\"getPredsForAmbigAlts result \" + $c1efbdb2cbf46748$export$4323cc4280d5be7(altToPred));\n        return altToPred;\n    }\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for(let i = 1; i < altToPred.length; i++){\n            const pred = altToPred[i];\n            if (ambigAlts.get(i)) pairs.push({\n                pred: pred,\n                alt: i\n            });\n            if (pred !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) containsPredicate = true;\n        }\n        if (!containsPredicate) return null;\n        return pairs;\n    }\n    /**\n   * This method is used to improve the localization of error messages by\n   * choosing an alternative rather than throwing a\n   * {@link NoViableAltException} in particular prediction scenarios where the\n   * {@link ERROR} state was reached during ATN simulation.\n   *\n   *\n   * The default implementation of this method uses the following\n   * algorithm to identify an ATN configuration which successfully parsed the\n   * decision entry rule. Choosing such an alternative ensures that the\n   * {@link ParserRuleContext} returned by the calling rule will be complete\n   * and valid, and the syntax error will be reported later at a more\n   * localized location.\n   *\n   * - If a syntactically valid path or paths reach the end of the decision rule and\n   * they are semantically valid if predicated, return the min associated alt.\n   * - Else, if a semantically invalid but syntactically valid path exist\n   * or paths exist, return the minimum associated alt.\n   *\n   * - Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.\n   *\n   *\n   * In some scenarios, the algorithm described above could predict an\n   * alternative which will result in a {@link FailedPredicateException} in\n   * the parser. Specifically, this could occur if the *only* configuration\n   * capable of successfully parsing to the end of the decision rule is\n   * blocked by a semantic predicate. By choosing this alternative within\n   * {@link adaptivePredict} instead of throwing a\n   * {@link NoViableAltException}, the resulting\n   * {@link FailedPredicateException} in the parser will identify the specific\n   * predicate which is preventing the parser from successfully parsing the\n   * decision rule, which helps developers identify and correct logic errors\n   * in semantic predicates.\n   *\n   * @param configs The ATN configurations which were valid immediately before\n   * the {@link ERROR} state was reached\n   * @param outerContext The is the \\gamma_0 initial parser context from the paper\n   * or the parser stack at the instant before prediction commences.\n   *\n   * @returns The value to return from {@link adaptivePredict}, or\n   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n   * identified and {@link adaptivePredict} should report an error instead\n   */ getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const splitConfigs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = splitConfigs[0];\n        const semInvalidConfigs = splitConfigs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) return alt;\n        if (semInvalidConfigs.length > 0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) return alt;\n        }\n        return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n    }\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for (const c of configs){\n            if (c.reachesIntoOuterContext || c.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c && c.context.hasEmptyPath()) {\n                if (alts.indexOf(c.alt) < 0) alts.push(c.alt);\n            }\n        }\n        if (alts.length === 0) return $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER;\n        else return Math.min(...alts);\n    }\n    /**\n   * Walk the list of configurations and split them according to\n   * those that have preds evaluating to true/false.  If no pred, assume\n   * true pred and include in succeeded set.  Returns Pair of sets.\n   *\n   * Create a new set so as not to alter the incoming parameter.\n   *\n   * Assumption: the input stream has been restored to the starting point\n   * prediction, which is where predicates need to evaluate.\n   */ splitAccordingToSemanticValidity(configs, outerContext) {\n        const succeeded = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(configs.fullCtx);\n        const failed = new $c1efbdb2cbf46748$export$3e159d9d82bfca90(configs.fullCtx);\n        for (const c of configs)if (c.semanticContext !== $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) {\n            const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n            if (predicateEvaluationResult) succeeded.add(c);\n            else failed.add(c);\n        } else succeeded.add(c);\n        return [\n            succeeded,\n            failed\n        ];\n    }\n    /**\n   * Look through a list of predicate/alt pairs, returning alts for the\n   * pairs that win. A `NONE` predicate indicates an alt containing an\n   * unpredicated config which behaves as \"always true.\" If !complete\n   * then we stop at the first predicate that evaluates to true. This\n   * includes pairs with null predicates.\n   */ evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n        for (const pair of predPredictions){\n            if (pair.pred === $c1efbdb2cbf46748$export$946e3ad1112f0fcb.NONE) {\n                predictions.set(pair.alt);\n                if (!complete) break;\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (_ParserATNSimulator.debug || _ParserATNSimulator.dfaDebug) console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            if (predicateEvaluationResult) {\n                predictions.set(pair.alt);\n                if (!complete) break;\n            }\n        }\n        return predictions;\n    }\n    // TODO: If we are doing predicates, there is no point in pursuing\n    //     closure operations if we reach a DFA state that uniquely predicts\n    //     alternative. We will not be caching that DFA state and it is a\n    //     waste to pursue the closure. Might have to advance when we do\n    //     ambig detection thought :(\n    //\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (_ParserATNSimulator.traceATNSimulator || _ParserATNSimulator.debugClosure) console.log(\"closure(\" + config.toString(this.parser, true) + \")\");\n        if (config.state instanceof $c1efbdb2cbf46748$export$ba787240acf6572c) {\n            if (config.context && !config.context.isEmpty()) {\n                for(let i = 0; i < config.context.length; i++){\n                    if (config.context.getReturnState(i) === $c1efbdb2cbf46748$export$95ea21db2ed34266.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add($c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(config.state, config, $c1efbdb2cbf46748$export$179fd11580abda9d.instance), this.mergeCache);\n                            continue;\n                        } else {\n                            if (_ParserATNSimulator.debug) console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i);\n                    const c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithContext(returnState, config.alt, newContext, config.semanticContext);\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if (fullCtx) {\n                configs.add(config, this.mergeCache);\n                return;\n            } else if (_ParserATNSimulator.debug) console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        if (!p.epsilonOnlyTransitions) configs.add(config, this.mergeCache);\n        for(let i = 0; i < p.transitions.length; i++){\n            if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof $c1efbdb2cbf46748$export$56d58b5b6c0e2f81);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c) {\n                let newDepth = depth;\n                if (config.state.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP) {\n                    if (this.predictionState.dfa && this.predictionState?.dfa.isPrecedenceDfa) {\n                        const outermostPrecedenceReturn = t.outermostPrecedenceReturn;\n                        if (outermostPrecedenceReturn === this.predictionState?.dfa.atnStartState?.ruleIndex) c.precedenceFilterSuppressed = true;\n                    }\n                    c.reachesIntoOuterContext = true;\n                    if (closureBusy.getOrAdd(c) !== c) continue;\n                    configs.dipsIntoOuterContext = true;\n                    newDepth -= 1;\n                    if (_ParserATNSimulator.debug) console.log(\"dips into outer ctx: \" + c);\n                } else {\n                    if (!t.isEpsilon && closureBusy.getOrAdd(c) !== c) continue;\n                    if (t instanceof $c1efbdb2cbf46748$export$5a1cda5a00fd126) {\n                        if (newDepth >= 0) newDepth += 1;\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        const p = config.state;\n        if (p.constructor.stateType !== $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_ENTRY || !config.context) return false;\n        if (!p.precedenceRuleDecision || config.context.isEmpty() || config.context.hasEmptyPath()) return false;\n        const numCtxs = config.context.length;\n        for(let i = 0; i < numCtxs; i++){\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex) return false;\n        }\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n        for(let i = 0; i < numCtxs; i++){\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) return false;\n            const returnStateTarget = returnState.transitions[0].target;\n            if (returnState.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_END && returnStateTarget === p) continue;\n            if (returnState === blockEndState) continue;\n            if (returnStateTarget === blockEndState) continue;\n            if (returnStateTarget.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) continue;\n            return false;\n        }\n        return true;\n    }\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.transitionType){\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RULE:\n                return this.ruleTransition(config, t);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE:\n                return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE:\n                return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ACTION:\n                if (_ParserATNSimulator.debug) {\n                    const at = t;\n                    const index = at.actionIndex === -1 ? 65535 : at.actionIndex;\n                    console.log(\"ACTION edge \" + at.ruleIndex + \":\" + index);\n                }\n                return $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(t.target, config);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.EPSILON:\n                return $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(t.target, config);\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ATOM:\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RANGE:\n            case $c1efbdb2cbf46748$export$be58926105124dd4.SET:\n                if (treatEofAsEpsilon) {\n                    if (t.matches($c1efbdb2cbf46748$export$50792b0e93539fde.EOF, 0, 1)) return $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(t.target, config);\n                }\n                return null;\n            default:\n                return null;\n        }\n    }\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (_ParserATNSimulator.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser !== null) console.log(\"context surrounding pred is \" + $c1efbdb2cbf46748$export$4323cc4280d5be7(this.parser.getRuleInvocationStack()));\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx && this.predictionState?.input) {\n                const currentPosition = this.predictionState.input.index;\n                this.predictionState.input.seek(this.predictionState.startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);\n                this.predictionState.input.seek(currentPosition);\n                if (predSucceeds) c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(pt.target, config);\n            } else {\n                const newSemCtx = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.andContext(config.semanticContext, pt.getPredicate());\n                c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithSemanticContext(pt.target, config, newSemCtx);\n            }\n        } else c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(pt.target, config);\n        if (_ParserATNSimulator.debug) console.log(\"config from pred transition=\" + c);\n        return c;\n    }\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (_ParserATNSimulator.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser !== null) console.log(\"context surrounding pred is \" + $c1efbdb2cbf46748$export$4323cc4280d5be7(this.parser.getRuleInvocationStack()));\n        }\n        let c = null;\n        if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {\n            if (fullCtx && this.predictionState?.input) {\n                const currentPosition = this.predictionState.input.index;\n                this.predictionState.input.seek(this.predictionState.startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);\n                this.predictionState.input.seek(currentPosition);\n                if (predSucceeds) c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(pt.target, config);\n            } else {\n                const newSemCtx = $c1efbdb2cbf46748$export$946e3ad1112f0fcb.andContext(config.semanticContext, pt.getPredicate());\n                c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithSemanticContext(pt.target, config, newSemCtx);\n            }\n        } else c = $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(pt.target, config);\n        if (_ParserATNSimulator.debug) console.log(\"config from pred transition=\" + c);\n        return c;\n    }\n    ruleTransition(config, t) {\n        if (_ParserATNSimulator.debug) console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        const returnState = t.followState;\n        const newContext = $c1efbdb2cbf46748$export$85d7977d7e5c4cc2(config.context ?? void 0, returnState.stateNumber);\n        return $c1efbdb2cbf46748$export$b371505ec63d1c9b.createWithConfig(t.target, config, newContext);\n    }\n    getConflictingAlts(configs) {\n        const altSets = $c1efbdb2cbf46748$export$a8734b9e3c538260.getConflictingAltSubsets(configs);\n        return $c1efbdb2cbf46748$export$a8734b9e3c538260.getAlts(altSets);\n    }\n    /**\n   * Sam pointed out a problem with the previous definition, v3, of\n   * ambiguous states. If we have another state associated with conflicting\n   * alternatives, we should keep going. For example, the following grammar\n   *\n   * s : (ID | ID ID?) ';' ;\n   *\n   * When the ATN simulation reaches the state before ';', it has a DFA\n   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n   * because alternative to has another way to continue, via [6|2|[]].\n   * The key is that we have a single state that has config's only associated\n   * with a single alternative, 2, and crucially the state transitions\n   * among the configurations are all non-epsilon transitions. That means\n   * we don't consider any conflicts that include alternative 2. So, we\n   * ignore the conflict between alts 1 and 2. We ignore a set of\n   * conflicting alts when there is an intersection with an alternative\n   * associated with a single alt state in the state -> config-list map.\n   *\n   * It's also the case that we might have two conflicting configurations but\n   * also a 3rd nonconflicting configuration for a different alternative:\n   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n   *\n   * a : A | A | A B ;\n   *\n   * After matching input A, we reach the stop state for rule A, state 1.\n   * State 8 is the state right before B. Clearly alternatives 1 and 2\n   * conflict and no amount of further lookahead will separate the two.\n   * However, alternative 3 will be able to continue and so we do not\n   * stop working on this state. In the previous example, we're concerned\n   * with states associated with the conflicting alternatives. Here alt\n   * 3 is not associated with the conflicting configs, but since we can continue\n   * looking for input reasonably, I don't declare the state done. We\n   * ignore a set of conflicting alts when we have an alternative\n   * that we still need to pursue\n   */ getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts;\n        if (configs.uniqueAlt !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER) {\n            conflictingAlts = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n            conflictingAlts.set(configs.uniqueAlt);\n        } else conflictingAlts = configs.conflictingAlts;\n        return conflictingAlts;\n    }\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new $c1efbdb2cbf46748$export$24170894ee7a3e61(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n    /**\n   * Add an edge to the DFA, if possible. This method calls\n   * {@link addDFAState} to ensure the `to` state is present in the\n   * DFA. If `from` is `null`, or if `t` is outside the\n   * range of edges that can be represented in the DFA tables, this method\n   * returns without adding the edge to the DFA.\n   *\n   * If `to` is `null`, this method returns `null`.\n   * Otherwise, this method returns the {@link DFAState} returned by calling\n   * {@link addDFAState} for the `to` state.\n   *\n   * @param dfa The DFA\n   * @param from The source state for the edge\n   * @param t The input symbol\n   * @param to The target state for the edge\n   *\n   * @returns If `to` is `null`, this method returns `null`;\n   * otherwise this method returns the result of calling {@link addDFAState}\n   * on `to`\n   */ addDFAEdge(dfa, from, t, to) {\n        if (_ParserATNSimulator.debug) console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        to = this.addDFAState(dfa, to);\n        if (t < -1 || t > this.atn.maxTokenType) return to;\n        if (_ParserATNSimulator.debug) console.log(\"DFA=\\n\" + dfa.toString(this.parser != null ? this.parser.vocabulary : $c1efbdb2cbf46748$export$6fe78fc0b86aec88.EMPTY_VOCABULARY));\n        from.edges[t + 1] = to;\n        return to;\n    }\n    /**\n   * Add state `D` to the DFA if it is not already present, and return\n   * the actual instance stored in the DFA. If a state equivalent to `D`\n   * is already in the DFA, the existing state is returned. Otherwise this\n   * method returns `D` after adding it to the DFA.\n   *\n   * If `D` is {@link ERROR}, this method returns {@link ERROR} and\n   * does not change the DFA.\n   *\n   * @param dfa The dfa.\n   * @param newState The DFA state to add.\n   *\n   * @returns The state stored in the DFA. This will be either the existing state if `newState` is already in\n   *          the DFA, or `newState` itself if the state was not already present.\n   */ addDFAState(dfa, newState) {\n        if (newState === $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR) return newState;\n        const existing = dfa.getState(newState);\n        if (existing !== null) return existing;\n        if (!newState.configs.readOnly) {\n            newState.configs.optimizeConfigs(this);\n            newState.configs.setReadonly(true);\n        }\n        if (_ParserATNSimulator.traceATNSimulator) console.log(\"addDFAState new \" + newState);\n        dfa.addState(newState);\n        return newState;\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n            const interval = new $c1efbdb2cbf46748$export$e659c2681d58d45b(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n        }\n        this.parser.errorListenerDispatch.reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n    }\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n            const interval = new $c1efbdb2cbf46748$export$e659c2681d58d45b(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n        }\n        this.parser.errorListenerDispatch.reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n    }\n    // If context sensitive parsing, we know it's ambiguity not conflict.\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n        if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n            const interval = new $c1efbdb2cbf46748$export$e659c2681d58d45b(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n        }\n        this.parser.errorListenerDispatch.reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n};\n// src/atn/PredictionContextCache.ts\nvar $c1efbdb2cbf46748$export$5afaa830ff2e40ab = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"PredictionContextCache\");\n    }\n    cache = new $c1efbdb2cbf46748$export$60ef0b43d585640a($c1efbdb2cbf46748$var$ObjectEqualityComparator.instance);\n    /**\n   * Add a context to the cache and return it. If the context already exists,\n   * return that one instead and do not add a new context to the cache.\n   * Protect shared cache from unsafe thread access.\n   *\n   * @param ctx tbd\n   * @returns tbd\n   */ add(ctx) {\n        if (ctx === $c1efbdb2cbf46748$export$179fd11580abda9d.instance) return ctx;\n        const existing = this.cache.get(ctx);\n        if (existing) return existing;\n        this.cache.set(ctx, ctx);\n        return ctx;\n    }\n    get(ctx) {\n        return this.cache.get(ctx);\n    }\n    get length() {\n        return this.cache.size;\n    }\n};\n// src/atn/ProfilingATNSimulator.ts\nvar $c1efbdb2cbf46748$export$82d303abae5db5e0 = class extends $c1efbdb2cbf46748$export$7baac15c7bd92e00 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ProfilingATNSimulator\");\n    }\n    decisions;\n    numDecisions = 0;\n    currentDecision = 0;\n    currentState;\n    /**\n   * At the point of LL failover, we record how SLL would resolve the conflict so that\n   *  we can determine whether or not a decision / input pair is context-sensitive.\n   *  If LL gives a different result than SLL's predicted alternative, we have a\n   *  context sensitivity for sure. The converse is not necessarily true, however.\n   *  It's possible that after conflict resolution chooses minimum alternatives,\n   *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\n   *  an ambiguity, it is not treated as a context sensitivity because LL prediction\n   *  was not required in order to produce a correct prediction for this decision and input sequence.\n   *  It may in fact still be a context sensitivity but we don't know by looking at the\n   *  minimum alternatives for the current input.\n   */ conflictingAltResolvedBySLL;\n    sllStopIndex = 0;\n    llStopIndex = 0;\n    constructor(parser){\n        const sharedContextCache = parser.interpreter.sharedContextCache;\n        super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA, sharedContextCache);\n        if (sharedContextCache) {\n            this.numDecisions = this.atn.decisionToState.length;\n            this.decisions = new Array(this.numDecisions);\n            for(let i = 0; i < this.numDecisions; i++)this.decisions[i] = new $c1efbdb2cbf46748$export$7dca65db55187a88(i);\n        }\n    }\n    adaptivePredict(input, decision, outerContext) {\n        try {\n            this.sllStopIndex = -1;\n            this.llStopIndex = -1;\n            this.currentDecision = decision;\n            const start = performance.now();\n            const alt = super.adaptivePredict(input, decision, outerContext);\n            const stop = performance.now();\n            this.decisions[decision].timeInPrediction += stop - start;\n            this.decisions[decision].invocations++;\n            const sllLook = this.sllStopIndex - this.predictionState.startIndex + 1;\n            this.decisions[decision].sllTotalLook += sllLook;\n            this.decisions[decision].sllMinLook = this.decisions[decision].sllMinLook === 0 ? sllLook : Math.min(this.decisions[decision].sllMinLook, sllLook);\n            if (sllLook > this.decisions[decision].sllMaxLook) {\n                this.decisions[decision].sllMaxLook = sllLook;\n                this.decisions[decision].sllMaxLookEvent = {\n                    decision: decision,\n                    configs: null,\n                    predictedAlt: alt,\n                    input: input,\n                    startIndex: this.predictionState.startIndex,\n                    stopIndex: this.sllStopIndex,\n                    fullCtx: false\n                };\n            }\n            if (this.llStopIndex >= 0) {\n                const llLook = this.llStopIndex - this.predictionState.startIndex + 1;\n                this.decisions[decision].llTotalLook += llLook;\n                this.decisions[decision].llMinLook = this.decisions[decision].llMinLook === 0 ? llLook : Math.min(this.decisions[decision].llMinLook, llLook);\n                if (llLook > this.decisions[decision].llMaxLook) {\n                    this.decisions[decision].llMaxLook = llLook;\n                    this.decisions[decision].llMaxLookEvent = {\n                        decision: decision,\n                        configs: null,\n                        predictedAlt: alt,\n                        input: input,\n                        startIndex: this.predictionState.startIndex,\n                        stopIndex: this.llStopIndex,\n                        fullCtx: true\n                    };\n                }\n            }\n            return alt;\n        } finally{\n            this.currentDecision = -1;\n        }\n    }\n    getExistingTargetState(previousD, t) {\n        this.sllStopIndex = this.predictionState.input.index;\n        const existingTargetState = super.getExistingTargetState(previousD, t);\n        if (existingTargetState !== void 0) {\n            this.decisions[this.currentDecision].sllDFATransitions++;\n            if (existingTargetState === $c1efbdb2cbf46748$export$b12c0eaae78de602.ERROR) this.decisions[this.currentDecision].errors.push({\n                decision: this.currentDecision,\n                configs: previousD.configs,\n                input: this.predictionState.input,\n                startIndex: this.predictionState.startIndex,\n                stopIndex: this.sllStopIndex,\n                fullCtx: false\n            });\n        }\n        this.currentState = existingTargetState;\n        return existingTargetState;\n    }\n    computeTargetState(dfa, previousD, t) {\n        const state = super.computeTargetState(dfa, previousD, t);\n        this.currentState = state;\n        return state;\n    }\n    computeReachSet(closure, t, fullCtx) {\n        if (fullCtx && this.predictionState?.input) this.llStopIndex = this.predictionState.input.index;\n        const reachConfigs = super.computeReachSet(closure, t, fullCtx);\n        if (this.predictionState?.input) {\n            if (fullCtx) {\n                this.decisions[this.currentDecision].llATNTransitions++;\n                if (reachConfigs === null) this.decisions[this.currentDecision].errors.push({\n                    decision: this.currentDecision,\n                    configs: closure,\n                    input: this.predictionState.input,\n                    startIndex: this.predictionState.startIndex,\n                    stopIndex: this.sllStopIndex,\n                    fullCtx: true\n                });\n            } else {\n                this.decisions[this.currentDecision].sllATNTransitions++;\n                if (reachConfigs === null) this.decisions[this.currentDecision].errors.push({\n                    decision: this.currentDecision,\n                    configs: closure,\n                    input: this.predictionState.input,\n                    startIndex: this.predictionState.startIndex,\n                    stopIndex: this.sllStopIndex,\n                    fullCtx: false\n                });\n            }\n        }\n        return reachConfigs;\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (conflictingAlts !== null) this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\n        else this.conflictingAltResolvedBySLL = configs.getAlts().nextSetBit(0);\n        this.decisions[this.currentDecision].llFallback++;\n        if (conflictingAlts) super.reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex);\n    }\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (prediction !== this.conflictingAltResolvedBySLL && this.predictionState.input) this.decisions[this.currentDecision].contextSensitivities.push({\n            decision: this.currentDecision,\n            configs: configs,\n            input: this.predictionState.input,\n            startIndex: startIndex,\n            stopIndex: stopIndex,\n            fullCtx: true\n        });\n        super.reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex);\n    }\n    reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs) {\n        let prediction;\n        if (ambigAlts) prediction = ambigAlts.nextSetBit(0);\n        else prediction = configs.getAlts().nextSetBit(0);\n        if (this.predictionState?.input) {\n            if (configs.fullCtx && prediction !== this.conflictingAltResolvedBySLL) this.decisions[this.currentDecision].contextSensitivities.push({\n                decision: this.currentDecision,\n                configs: configs,\n                input: this.predictionState.input,\n                startIndex: startIndex,\n                stopIndex: stopIndex,\n                fullCtx: true\n            });\n            this.decisions[this.currentDecision].ambiguities.push({\n                ambigAlts: ambigAlts,\n                decision: this.currentDecision,\n                configs: configs,\n                input: this.predictionState.input,\n                startIndex: startIndex,\n                stopIndex: stopIndex,\n                fullCtx: configs.fullCtx\n            });\n        }\n        super.reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n    getDecisionInfo() {\n        return this.decisions;\n    }\n    getCurrentState() {\n        return this.currentState;\n    }\n};\n// src/dfa/PredPrediction.ts\nvar $c1efbdb2cbf46748$export$6d92bd5817d5392b;\n((PredPrediction2)=>{\n    PredPrediction2.toString = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((prediction)=>{\n        return `(${prediction.pred}, ${prediction.alt})`;\n    }, \"toString\");\n})($c1efbdb2cbf46748$export$6d92bd5817d5392b || ($c1efbdb2cbf46748$export$6d92bd5817d5392b = {}));\n// src/misc/ParseCancellationException.ts\nvar $c1efbdb2cbf46748$export$6b89c498ba520494 = class extends Error {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseCancellationException\");\n    }\n    constructor(e){\n        super();\n        this.cause = e;\n    }\n};\n// src/misc/InterpreterDataReader.ts\nvar $c1efbdb2cbf46748$export$71bb03618e789c6f = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"InterpreterDataReader\");\n    }\n    /**\n   * The structure of the data file is very simple. Everything is line based with empty lines\n   * separating the different parts. For lexers the layout is:\n   * token literal names:\n   * ...\n   *\n   * token symbolic names:\n   * ...\n   *\n   * rule names:\n   * ...\n   *\n   * channel names:\n   * ...\n   *\n   * mode names:\n   * ...\n   *\n   * atn:\n   * a single line with comma separated int values, enclosed in a pair of squared brackets.\n   *\n   * Data for a parser does not contain channel and mode names.\n   */ static parseInterpreterData(source) {\n        const ruleNames = [];\n        const channels = [];\n        const modes = [];\n        const literalNames = [];\n        const symbolicNames = [];\n        const lines = source.split(\"\\n\");\n        let index = 0;\n        let line = lines[index++];\n        if (line !== \"token literal names:\") throw new Error(\"Unexpected data entry\");\n        do {\n            line = lines[index++];\n            if (line.length === 0) break;\n            literalNames.push(line === \"null\" ? null : line);\n        }while (true);\n        line = lines[index++];\n        if (line !== \"token symbolic names:\") throw new Error(\"Unexpected data entry\");\n        do {\n            line = lines[index++];\n            if (line.length === 0) break;\n            symbolicNames.push(line === \"null\" ? null : line);\n        }while (true);\n        line = lines[index++];\n        if (line !== \"rule names:\") throw new Error(\"Unexpected data entry\");\n        do {\n            line = lines[index++];\n            if (line.length === 0) break;\n            ruleNames.push(line);\n        }while (true);\n        line = lines[index++];\n        if (line === \"channel names:\") {\n            do {\n                line = lines[index++];\n                if (line.length === 0) break;\n                channels.push(line);\n            }while (true);\n            line = lines[index++];\n            if (line !== \"mode names:\") throw new Error(\"Unexpected data entry\");\n            do {\n                line = lines[index++];\n                if (line.length === 0) break;\n                modes.push(line);\n            }while (true);\n        }\n        line = lines[index++];\n        if (line !== \"atn:\") throw new Error(\"Unexpected data entry\");\n        line = lines[index++];\n        const elements = line.split(\",\");\n        let value;\n        const serializedATN = [];\n        for(let i = 0; i < elements.length; ++i){\n            const element = elements[i];\n            if (element.startsWith(\"[\")) value = Number(element.substring(1).trim());\n            else if (element.endsWith(\"]\")) value = Number(element.substring(0, element.length - 1).trim());\n            else value = Number(element.trim());\n            serializedATN[i] = value;\n        }\n        const deserializer = new $c1efbdb2cbf46748$export$8d551c119323a3a7();\n        return {\n            atn: deserializer.deserialize(serializedATN),\n            vocabulary: new $c1efbdb2cbf46748$export$6fe78fc0b86aec88(literalNames, symbolicNames, []),\n            ruleNames: ruleNames,\n            channels: channels.length > 0 ? channels : void 0,\n            modes: modes.length > 0 ? modes : void 0\n        };\n    }\n};\n// src/tree/AbstractParseTreeVisitor.ts\nvar $c1efbdb2cbf46748$export$fcb1c891d90b4082 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"AbstractParseTreeVisitor\");\n    }\n    visit(tree) {\n        return tree.accept(this);\n    }\n    visitChildren(node) {\n        let result = this.defaultResult();\n        const n2 = node.getChildCount();\n        for(let i = 0; i < n2; i++){\n            if (!this.shouldVisitNextChild(node, result)) break;\n            const c = node.getChild(i);\n            if (c) {\n                const childResult = c.accept(this);\n                result = this.aggregateResult(result, childResult);\n            }\n        }\n        return result;\n    }\n    visitTerminal(_node) {\n        return this.defaultResult();\n    }\n    visitErrorNode(_node) {\n        return this.defaultResult();\n    }\n    defaultResult() {\n        return null;\n    }\n    shouldVisitNextChild(_node, _currentResult) {\n        return true;\n    }\n    aggregateResult(aggregate, nextResult) {\n        return nextResult;\n    }\n};\n// src/tree/ParseTreeWalker.ts\nvar $c1efbdb2cbf46748$export$2f3ccbd0b2533c4d = class _ParseTreeWalker {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseTreeWalker\");\n    }\n    static DEFAULT = new _ParseTreeWalker();\n    /**\n   * Performs a walk on the given parse tree starting at the root and going down recursively\n   * with depth-first search. On each node, {@link ParseTreeWalker.enterRule} is called before\n   * recursively walking down into child nodes, then\n   * {@link ParseTreeWalker.exitRule} is called after the recursive call to wind up.\n   *\n   * @param listener The listener used by the walker to process grammar rules\n   * @param t The parse tree to be walked on\n   */ walk(listener, t) {\n        const errorNode = t instanceof $c1efbdb2cbf46748$export$d3ee467d32253151;\n        if (errorNode) listener.visitErrorNode(t);\n        else if (t instanceof $c1efbdb2cbf46748$export$f6a002739fa43001) listener.visitTerminal(t);\n        else {\n            const r = t;\n            this.enterRule(listener, r);\n            for(let i = 0; i < t.getChildCount(); i++)this.walk(listener, t.getChild(i));\n            this.exitRule(listener, r);\n        }\n    }\n    /**\n   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener.enterEveryRule}\n   * then by triggering the event specific to the given parse tree node\n   *\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */ enterRule(listener, r) {\n        const ctx = r.ruleContext;\n        listener.enterEveryRule(ctx);\n        ctx.enterRule(listener);\n    }\n    /**\n   * Exits a grammar rule by first triggering the event specific to the given parse tree node\n   * then by triggering the generic event {@link ParseTreeListener.exitEveryRule}\n   *\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */ exitRule(listener, r) {\n        const ctx = r.ruleContext;\n        ctx.exitRule(listener);\n        listener.exitEveryRule(ctx);\n    }\n};\n// src/CharStream.ts\nvar $c1efbdb2cbf46748$export$7bbbaf2220a3f180;\n((CharStream2)=>{\n    CharStream2.fromString = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((str)=>{\n        return new $c1efbdb2cbf46748$export$e7f59ed6635e55ad(str);\n    }, \"fromString\");\n})($c1efbdb2cbf46748$export$7bbbaf2220a3f180 || ($c1efbdb2cbf46748$export$7bbbaf2220a3f180 = {}));\nvar $c1efbdb2cbf46748$export$e7f59ed6635e55ad = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CharStreamImpl\");\n    }\n    name = \"\";\n    index = 0;\n    data;\n    constructor(input){\n        const codePoints = [];\n        for (const char of input)codePoints.push(char.codePointAt(0));\n        this.data = new Uint32Array(codePoints);\n    }\n    /**\n   * Reset the stream so that it's in the same state it was\n   * when the object was created *except* the data array is not\n   * touched.\n   */ reset() {\n        this.index = 0;\n    }\n    consume() {\n        if (this.index >= this.data.length) throw new Error(\"cannot consume EOF\");\n        this.index += 1;\n    }\n    LA(offset) {\n        if (offset === 0) return 0;\n        if (offset < 0) offset += 1;\n        const pos = this.index + offset - 1;\n        if (pos < 0 || pos >= this.data.length) return $c1efbdb2cbf46748$export$50792b0e93539fde.EOF;\n        return this.data[pos];\n    }\n    // mark/release do nothing; we have entire buffer\n    mark() {\n        return -1;\n    }\n    release(_marker) {}\n    /**\n   * consume() ahead until p==_index; can't just set p=_index as we must\n   * update line and column. If we seek backwards, just set p\n   */ seek(index) {\n        if (index <= this.index) {\n            this.index = index;\n            return;\n        }\n        this.index = Math.min(index, this.data.length);\n    }\n    getTextFromRange(start, stop) {\n        stop = stop ?? this.data.length - 1;\n        if (stop >= this.data.length) stop = this.data.length - 1;\n        if (start >= this.data.length) return \"\";\n        return this.stringFromRange(start, stop + 1);\n    }\n    getTextFromInterval(interval) {\n        const start = interval.start;\n        let stop = interval.stop;\n        if (stop >= this.data.length) stop = this.data.length - 1;\n        if (start >= this.data.length) return \"\";\n        return this.stringFromRange(start, stop + 1);\n    }\n    toString() {\n        return this.stringFromRange(0);\n    }\n    get size() {\n        return this.data.length;\n    }\n    getSourceName() {\n        if (this.name) return this.name;\n        return $c1efbdb2cbf46748$export$194a8984a055b1cc.UNKNOWN_SOURCE_NAME;\n    }\n    stringFromRange(start, stop) {\n        const data = this.data.slice(start, stop);\n        let result = \"\";\n        data.forEach((value)=>{\n            result += String.fromCodePoint(value);\n        });\n        return result;\n    }\n};\n// src/WritableToken.ts\nvar $c1efbdb2cbf46748$export$fc9236fcd9399ac6 = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((candidate)=>{\n    return candidate.setText !== void 0;\n}, \"isWritableToken\");\n// src/BufferedTokenStream.ts\nvar $c1efbdb2cbf46748$export$574d442acf9221a4 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BufferedTokenStream\");\n    }\n    /**\n   * The {@link TokenSource} from which tokens for this stream are fetched.\n   */ tokenSource;\n    /**\n   * A collection of all tokens fetched from the token source. The list is\n   * considered a complete view of the input once {@link fetchedEOF} is set\n   * to `true`.\n   */ tokens = [];\n    /**\n   * The index into {@link tokens} of the current token (next token to\n   * {@link consume}). {@link tokens}`[p]` should be\n   * {@link LT LT(1)}.\n   *\n   * This field is set to -1 when the stream is first constructed or when\n   * {@link setTokenSource} is called, indicating that the first token has\n   * not yet been fetched from the token source. For additional information,\n   * see the documentation of {@link IntStream} for a description of\n   * Initializing Methods.\n   */ p = -1;\n    /**\n   * Indicates whether the {@link Token.EOF} token has been fetched from\n   * {@link tokenSource} and added to {@link tokens}. This field improves\n   * performance for the following cases:\n   *\n   * - {@link consume}: The lookahead check in {@link consume} to prevent\n   * consuming the EOF symbol is optimized by checking the values of\n   * {@link fetchedEOF} and {@link p} instead of calling {@link LA}.\n   * - {@link fetch}: The check to prevent adding multiple EOF symbols into\n   * {@link tokens} is trivial with this field.\n   */ fetchedEOF = false;\n    constructor(tokenSource){\n        this.tokenSource = tokenSource;\n    }\n    mark() {\n        return 0;\n    }\n    release(_marker) {}\n    reset() {\n        this.seek(0);\n    }\n    seek(index) {\n        this.lazyInit();\n        this.p = this.adjustSeekIndex(index);\n    }\n    get size() {\n        return this.tokens.length;\n    }\n    get index() {\n        return this.p;\n    }\n    get(index) {\n        this.lazyInit();\n        return this.tokens[index];\n    }\n    consume() {\n        let skipEofCheck = false;\n        if (this.p >= 0) {\n            if (this.fetchedEOF) skipEofCheck = this.p < this.tokens.length - 1;\n            else skipEofCheck = this.p < this.tokens.length;\n        } else skipEofCheck = false;\n        if (!skipEofCheck && this.LA(1) === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) throw new Error(\"cannot consume EOF\");\n        if (this.sync(this.p + 1)) this.p = this.adjustSeekIndex(this.p + 1);\n    }\n    /**\n   * Make sure index `i` in tokens has a token.\n   *\n   * @returns {boolean} `true` if a token is located at index `i`, otherwise `false`.\n   */ sync(i) {\n        const n2 = i - this.tokens.length + 1;\n        if (n2 > 0) {\n            const fetched = this.fetch(n2);\n            return fetched >= n2;\n        }\n        return true;\n    }\n    /**\n   * Add `n` elements to buffer.\n   *\n   * @returns {number} The actual number of elements added to the buffer.\n   */ fetch(n2) {\n        if (this.fetchedEOF) return 0;\n        for(let i = 0; i < n2; i++){\n            const t = this.tokenSource.nextToken();\n            if ($c1efbdb2cbf46748$export$fc9236fcd9399ac6(t)) t.tokenIndex = this.tokens.length;\n            this.tokens.push(t);\n            if (t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                this.fetchedEOF = true;\n                return i + 1;\n            }\n        }\n        return n2;\n    }\n    /** Get all tokens from start..stop, inclusively. */ getTokens(start, stop, types) {\n        this.lazyInit();\n        if (start === void 0 && stop === void 0) return this.tokens;\n        start ??= 0;\n        if (stop === void 0) stop = this.tokens.length - 1;\n        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) throw new RangeError(\"start \" + start + \" or stop \" + stop + \" not in 0..\" + (this.tokens.length - 1));\n        if (start > stop) return [];\n        if (types === void 0) return this.tokens.slice(start, stop + 1);\n        const subset = [];\n        if (stop >= this.tokens.length) stop = this.tokens.length - 1;\n        for(let i = start; i < stop; i++){\n            const t = this.tokens[i];\n            if (t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) {\n                subset.push(t);\n                break;\n            }\n            if (types.has(t.type)) subset.push(t);\n        }\n        return subset;\n    }\n    LA(k) {\n        return this.LT(k)?.type ?? $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n    }\n    LB(k) {\n        if (this.p - k < 0) return null;\n        return this.tokens[this.p - k];\n    }\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) return null;\n        if (k < 0) return this.LB(-k);\n        const i = this.p + k - 1;\n        this.sync(i);\n        if (i >= this.tokens.length) return this.tokens[this.tokens.length - 1];\n        return this.tokens[i];\n    }\n    /**\n   * Allowed derived classes to modify the behavior of operations which change\n   * the current stream position by adjusting the target token index of a seek\n   * operation. The default implementation simply returns `i`. If an\n   * exception is thrown in this method, the current stream index should not be\n   * changed.\n   *\n   * For example, {@link CommonTokenStream} overrides this method to ensure that\n   * the seek target is always an on-channel token.\n   *\n   * @param  i The target token index.\n   *\n   * @returns The adjusted target token index.\n   */ adjustSeekIndex(i) {\n        return i;\n    }\n    lazyInit() {\n        if (this.p === -1) this.setup();\n    }\n    setup() {\n        this.sync(0);\n        this.p = this.adjustSeekIndex(0);\n    }\n    /** Reset this token stream by setting its token source. */ setTokenSource(tokenSource) {\n        this.tokenSource = tokenSource;\n        this.tokens = [];\n        this.p = -1;\n        this.fetchedEOF = false;\n    }\n    /**\n   * Given a starting index, return the index of the next token on channel.\n   * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n   * on channel between i and EOF.\n   */ nextTokenOnChannel(i, channel) {\n        this.sync(i);\n        if (i >= this.tokens.length) return -1;\n        let token = this.tokens[i];\n        while(token.channel !== channel){\n            if (token.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return -1;\n            i += 1;\n            this.sync(i);\n            token = this.tokens[i];\n        }\n        return i;\n    }\n    /**\n   * Given a starting index, return the index of the previous token on\n   * channel. Return `i` if `tokens[i]` is on channel. Return -1\n   * if there are no tokens on channel between `i` and 0.\n   *\n   * If `i` specifies an index at or after the EOF token, the EOF token\n   * index is returned. This is due to the fact that the EOF token is treated\n   * as though it were on every channel.\n   */ previousTokenOnChannel(i, channel) {\n        if (i >= this.tokens.length) return this.tokens.length - 1;\n        while(i >= 0){\n            const token = this.tokens[i];\n            if (token.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF || token.channel === channel) return i;\n            --i;\n        }\n        return i;\n    }\n    /**\n   * Collect all tokens on specified channel to the right of\n   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n   * EOF. If channel is -1, find any non default channel token.\n   */ getHiddenTokensToRight(tokenIndex, channel) {\n        if (channel === void 0) channel = -1;\n        this.lazyInit();\n        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);\n        const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, $c1efbdb2cbf46748$export$6168dc8908a6c652.DEFAULT_TOKEN_CHANNEL);\n        const from = tokenIndex + 1;\n        const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n        return this.filterForChannel(from, to, channel);\n    }\n    /**\n   * Collect all tokens on specified channel to the left of\n   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n   * If channel is -1, find any non default channel token.\n   */ getHiddenTokensToLeft(tokenIndex, channel) {\n        if (channel === void 0) channel = -1;\n        this.lazyInit();\n        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);\n        const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, $c1efbdb2cbf46748$export$6168dc8908a6c652.DEFAULT_TOKEN_CHANNEL);\n        if (prevOnChannel === tokenIndex - 1) return void 0;\n        const from = prevOnChannel + 1;\n        const to = tokenIndex - 1;\n        return this.filterForChannel(from, to, channel);\n    }\n    filterForChannel(left, right, channel) {\n        const hidden = [];\n        for(let i = left; i < right + 1; i++){\n            const t = this.tokens[i];\n            if (channel === -1) {\n                if (t.channel !== $c1efbdb2cbf46748$export$6168dc8908a6c652.DEFAULT_TOKEN_CHANNEL) hidden.push(t);\n            } else if (t.channel === channel) hidden.push(t);\n        }\n        if (hidden.length === 0) return void 0;\n        return hidden;\n    }\n    getSourceName() {\n        return this.tokenSource.sourceName;\n    }\n    /** Get the text of all tokens in this buffer. */ getText() {\n        return this.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(0, this.size - 1));\n    }\n    getTextFromInterval(interval) {\n        const start = interval.start;\n        let stop = interval.stop;\n        if (start < 0 || stop < 0) return \"\";\n        this.sync(stop);\n        if (stop >= this.tokens.length) stop = this.tokens.length - 1;\n        let result = \"\";\n        for(let i = start; i <= stop; ++i){\n            const t = this.tokens[i];\n            if (t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) break;\n            result += t.text;\n        }\n        return result;\n    }\n    getTextFromContext(ctx) {\n        return this.getTextFromInterval(ctx.getSourceInterval());\n    }\n    getTextFromRange(start, stop) {\n        if (start !== null && stop !== null) return this.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(start.tokenIndex, stop.tokenIndex));\n        return \"\";\n    }\n    /** Get all tokens from lexer until EOF. */ fill() {\n        this.lazyInit();\n        while(this.fetch(1e3) === 1e3);\n    }\n    setLine(line) {\n        this.tokenSource.line = line;\n    }\n    setColumn(column) {\n        this.tokenSource.column = column;\n    }\n};\n// src/CommonTokenStream.ts\nvar $c1efbdb2cbf46748$export$3b6c0b5bd4a5b0b9 = class extends $c1efbdb2cbf46748$export$574d442acf9221a4 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CommonTokenStream\");\n    }\n    /**\n   * Specifies the channel to use for filtering tokens.\n   *\n   *\n   * The default value is {@link Token.DEFAULT_CHANNEL}, which matches the\n   * default channel assigned to tokens created by the lexer.\n   */ channel = $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n    constructor(lexer, channel){\n        super(lexer);\n        this.channel = channel ?? $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n    }\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n    LB(k) {\n        if (k === 0 || this.index - k < 0) return null;\n        let i = this.index;\n        let n2 = 1;\n        while(n2 <= k){\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n2 += 1;\n        }\n        if (i < 0) return null;\n        return this.tokens[i];\n    }\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) return null;\n        if (k < 0) return this.LB(-k);\n        let i = this.index;\n        let n2 = 1;\n        while(n2 < k){\n            if (this.sync(i + 1)) i = this.nextTokenOnChannel(i + 1, this.channel);\n            n2 += 1;\n        }\n        return this.tokens[i];\n    }\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n2 = 0;\n        this.fill();\n        for (const t of this.tokens){\n            if (t.channel === this.channel) n2 += 1;\n            if (t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) break;\n        }\n        return n2;\n    }\n};\n// src/tree/xpath/XPathLexer.ts\nvar $c1efbdb2cbf46748$export$5b42d76e23d5259b = class _XPathLexer extends $c1efbdb2cbf46748$export$6168dc8908a6c652 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathLexer\");\n    }\n    static TOKEN_REF = 1;\n    static RULE_REF = 2;\n    static ANYWHERE = 3;\n    static ROOT = 4;\n    static WILDCARD = 5;\n    static BANG = 6;\n    static ID = 7;\n    static STRING = 8;\n    static channelNames = [\n        \"DEFAULT_TOKEN_CHANNEL\",\n        \"HIDDEN\"\n    ];\n    static literalNames = [\n        null,\n        null,\n        null,\n        \"'//'\",\n        \"'/'\",\n        \"'*'\",\n        \"'!'\"\n    ];\n    static symbolicNames = [\n        null,\n        \"TOKEN_REF\",\n        \"RULE_REF\",\n        \"ANYWHERE\",\n        \"ROOT\",\n        \"WILDCARD\",\n        \"BANG\",\n        \"ID\",\n        \"STRING\"\n    ];\n    static modeNames = [\n        \"DEFAULT_MODE\"\n    ];\n    static ruleNames = [\n        \"ANYWHERE\",\n        \"ROOT\",\n        \"WILDCARD\",\n        \"BANG\",\n        \"ID\",\n        \"NameChar\",\n        \"NameStartChar\",\n        \"STRING\"\n    ];\n    constructor(input){\n        super(input);\n        this.interpreter = new $c1efbdb2cbf46748$export$e2b3d84d700fff0a(this, _XPathLexer._ATN, _XPathLexer.decisionsToDFA, new $c1efbdb2cbf46748$export$5afaa830ff2e40ab());\n    }\n    get grammarFileName() {\n        return \"XPathLexer.g4\";\n    }\n    get literalNames() {\n        return _XPathLexer.literalNames;\n    }\n    get symbolicNames() {\n        return _XPathLexer.symbolicNames;\n    }\n    get ruleNames() {\n        return _XPathLexer.ruleNames;\n    }\n    get serializedATN() {\n        return _XPathLexer._serializedATN;\n    }\n    get channelNames() {\n        return _XPathLexer.channelNames;\n    }\n    get modeNames() {\n        return _XPathLexer.modeNames;\n    }\n    action(localContext, ruleIndex, actionIndex) {\n        switch(ruleIndex){\n            case 4:\n                this.ID_action(localContext, actionIndex);\n                break;\n        }\n    }\n    ID_action(localContext, actionIndex) {\n        switch(actionIndex){\n            case 0:\n                const text = this.text;\n                if (text.charAt(0) === text.charAt(0).toUpperCase()) this.type = _XPathLexer.TOKEN_REF;\n                else this.type = _XPathLexer.RULE_REF;\n                break;\n        }\n    }\n    static _serializedATN = [\n        4,\n        0,\n        8,\n        48,\n        6,\n        -1,\n        2,\n        0,\n        7,\n        0,\n        2,\n        1,\n        7,\n        1,\n        2,\n        2,\n        7,\n        2,\n        2,\n        3,\n        7,\n        3,\n        2,\n        4,\n        7,\n        4,\n        2,\n        5,\n        7,\n        5,\n        2,\n        6,\n        7,\n        6,\n        2,\n        7,\n        7,\n        7,\n        1,\n        0,\n        1,\n        0,\n        1,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        2,\n        1,\n        2,\n        1,\n        3,\n        1,\n        3,\n        1,\n        4,\n        1,\n        4,\n        5,\n        4,\n        29,\n        8,\n        4,\n        10,\n        4,\n        12,\n        4,\n        32,\n        9,\n        4,\n        1,\n        4,\n        1,\n        4,\n        1,\n        5,\n        1,\n        5,\n        1,\n        6,\n        1,\n        6,\n        1,\n        7,\n        1,\n        7,\n        5,\n        7,\n        42,\n        8,\n        7,\n        10,\n        7,\n        12,\n        7,\n        45,\n        9,\n        7,\n        1,\n        7,\n        1,\n        7,\n        1,\n        43,\n        0,\n        8,\n        1,\n        3,\n        3,\n        4,\n        5,\n        5,\n        7,\n        6,\n        9,\n        7,\n        11,\n        0,\n        13,\n        0,\n        15,\n        8,\n        1,\n        0,\n        2,\n        784,\n        0,\n        0,\n        8,\n        14,\n        27,\n        48,\n        57,\n        65,\n        90,\n        95,\n        95,\n        97,\n        122,\n        127,\n        159,\n        170,\n        170,\n        173,\n        173,\n        181,\n        181,\n        186,\n        186,\n        192,\n        214,\n        216,\n        246,\n        248,\n        705,\n        710,\n        721,\n        736,\n        740,\n        748,\n        748,\n        750,\n        750,\n        768,\n        884,\n        886,\n        887,\n        890,\n        893,\n        895,\n        895,\n        902,\n        902,\n        904,\n        906,\n        908,\n        908,\n        910,\n        929,\n        931,\n        1013,\n        1015,\n        1153,\n        1155,\n        1159,\n        1162,\n        1327,\n        1329,\n        1366,\n        1369,\n        1369,\n        1376,\n        1416,\n        1425,\n        1469,\n        1471,\n        1471,\n        1473,\n        1474,\n        1476,\n        1477,\n        1479,\n        1479,\n        1488,\n        1514,\n        1519,\n        1522,\n        1536,\n        1541,\n        1552,\n        1562,\n        1564,\n        1564,\n        1568,\n        1641,\n        1646,\n        1747,\n        1749,\n        1757,\n        1759,\n        1768,\n        1770,\n        1788,\n        1791,\n        1791,\n        1807,\n        1866,\n        1869,\n        1969,\n        1984,\n        2037,\n        2042,\n        2042,\n        2045,\n        2045,\n        2048,\n        2093,\n        2112,\n        2139,\n        2144,\n        2154,\n        2160,\n        2183,\n        2185,\n        2190,\n        2192,\n        2193,\n        2200,\n        2403,\n        2406,\n        2415,\n        2417,\n        2435,\n        2437,\n        2444,\n        2447,\n        2448,\n        2451,\n        2472,\n        2474,\n        2480,\n        2482,\n        2482,\n        2486,\n        2489,\n        2492,\n        2500,\n        2503,\n        2504,\n        2507,\n        2510,\n        2519,\n        2519,\n        2524,\n        2525,\n        2527,\n        2531,\n        2534,\n        2545,\n        2556,\n        2556,\n        2558,\n        2558,\n        2561,\n        2563,\n        2565,\n        2570,\n        2575,\n        2576,\n        2579,\n        2600,\n        2602,\n        2608,\n        2610,\n        2611,\n        2613,\n        2614,\n        2616,\n        2617,\n        2620,\n        2620,\n        2622,\n        2626,\n        2631,\n        2632,\n        2635,\n        2637,\n        2641,\n        2641,\n        2649,\n        2652,\n        2654,\n        2654,\n        2662,\n        2677,\n        2689,\n        2691,\n        2693,\n        2701,\n        2703,\n        2705,\n        2707,\n        2728,\n        2730,\n        2736,\n        2738,\n        2739,\n        2741,\n        2745,\n        2748,\n        2757,\n        2759,\n        2761,\n        2763,\n        2765,\n        2768,\n        2768,\n        2784,\n        2787,\n        2790,\n        2799,\n        2809,\n        2815,\n        2817,\n        2819,\n        2821,\n        2828,\n        2831,\n        2832,\n        2835,\n        2856,\n        2858,\n        2864,\n        2866,\n        2867,\n        2869,\n        2873,\n        2876,\n        2884,\n        2887,\n        2888,\n        2891,\n        2893,\n        2901,\n        2903,\n        2908,\n        2909,\n        2911,\n        2915,\n        2918,\n        2927,\n        2929,\n        2929,\n        2946,\n        2947,\n        2949,\n        2954,\n        2958,\n        2960,\n        2962,\n        2965,\n        2969,\n        2970,\n        2972,\n        2972,\n        2974,\n        2975,\n        2979,\n        2980,\n        2984,\n        2986,\n        2990,\n        3001,\n        3006,\n        3010,\n        3014,\n        3016,\n        3018,\n        3021,\n        3024,\n        3024,\n        3031,\n        3031,\n        3046,\n        3055,\n        3072,\n        3084,\n        3086,\n        3088,\n        3090,\n        3112,\n        3114,\n        3129,\n        3132,\n        3140,\n        3142,\n        3144,\n        3146,\n        3149,\n        3157,\n        3158,\n        3160,\n        3162,\n        3165,\n        3165,\n        3168,\n        3171,\n        3174,\n        3183,\n        3200,\n        3203,\n        3205,\n        3212,\n        3214,\n        3216,\n        3218,\n        3240,\n        3242,\n        3251,\n        3253,\n        3257,\n        3260,\n        3268,\n        3270,\n        3272,\n        3274,\n        3277,\n        3285,\n        3286,\n        3293,\n        3294,\n        3296,\n        3299,\n        3302,\n        3311,\n        3313,\n        3315,\n        3328,\n        3340,\n        3342,\n        3344,\n        3346,\n        3396,\n        3398,\n        3400,\n        3402,\n        3406,\n        3412,\n        3415,\n        3423,\n        3427,\n        3430,\n        3439,\n        3450,\n        3455,\n        3457,\n        3459,\n        3461,\n        3478,\n        3482,\n        3505,\n        3507,\n        3515,\n        3517,\n        3517,\n        3520,\n        3526,\n        3530,\n        3530,\n        3535,\n        3540,\n        3542,\n        3542,\n        3544,\n        3551,\n        3558,\n        3567,\n        3570,\n        3571,\n        3585,\n        3642,\n        3648,\n        3662,\n        3664,\n        3673,\n        3713,\n        3714,\n        3716,\n        3716,\n        3718,\n        3722,\n        3724,\n        3747,\n        3749,\n        3749,\n        3751,\n        3773,\n        3776,\n        3780,\n        3782,\n        3782,\n        3784,\n        3790,\n        3792,\n        3801,\n        3804,\n        3807,\n        3840,\n        3840,\n        3864,\n        3865,\n        3872,\n        3881,\n        3893,\n        3893,\n        3895,\n        3895,\n        3897,\n        3897,\n        3902,\n        3911,\n        3913,\n        3948,\n        3953,\n        3972,\n        3974,\n        3991,\n        3993,\n        4028,\n        4038,\n        4038,\n        4096,\n        4169,\n        4176,\n        4253,\n        4256,\n        4293,\n        4295,\n        4295,\n        4301,\n        4301,\n        4304,\n        4346,\n        4348,\n        4680,\n        4682,\n        4685,\n        4688,\n        4694,\n        4696,\n        4696,\n        4698,\n        4701,\n        4704,\n        4744,\n        4746,\n        4749,\n        4752,\n        4784,\n        4786,\n        4789,\n        4792,\n        4798,\n        4800,\n        4800,\n        4802,\n        4805,\n        4808,\n        4822,\n        4824,\n        4880,\n        4882,\n        4885,\n        4888,\n        4954,\n        4957,\n        4959,\n        4992,\n        5007,\n        5024,\n        5109,\n        5112,\n        5117,\n        5121,\n        5740,\n        5743,\n        5759,\n        5761,\n        5786,\n        5792,\n        5866,\n        5870,\n        5880,\n        5888,\n        5909,\n        5919,\n        5940,\n        5952,\n        5971,\n        5984,\n        5996,\n        5998,\n        6e3,\n        6002,\n        6003,\n        6016,\n        6099,\n        6103,\n        6103,\n        6108,\n        6109,\n        6112,\n        6121,\n        6155,\n        6169,\n        6176,\n        6264,\n        6272,\n        6314,\n        6320,\n        6389,\n        6400,\n        6430,\n        6432,\n        6443,\n        6448,\n        6459,\n        6470,\n        6509,\n        6512,\n        6516,\n        6528,\n        6571,\n        6576,\n        6601,\n        6608,\n        6617,\n        6656,\n        6683,\n        6688,\n        6750,\n        6752,\n        6780,\n        6783,\n        6793,\n        6800,\n        6809,\n        6823,\n        6823,\n        6832,\n        6845,\n        6847,\n        6862,\n        6912,\n        6988,\n        6992,\n        7001,\n        7019,\n        7027,\n        7040,\n        7155,\n        7168,\n        7223,\n        7232,\n        7241,\n        7245,\n        7293,\n        7296,\n        7304,\n        7312,\n        7354,\n        7357,\n        7359,\n        7376,\n        7378,\n        7380,\n        7418,\n        7424,\n        7957,\n        7960,\n        7965,\n        7968,\n        8005,\n        8008,\n        8013,\n        8016,\n        8023,\n        8025,\n        8025,\n        8027,\n        8027,\n        8029,\n        8029,\n        8031,\n        8061,\n        8064,\n        8116,\n        8118,\n        8124,\n        8126,\n        8126,\n        8130,\n        8132,\n        8134,\n        8140,\n        8144,\n        8147,\n        8150,\n        8155,\n        8160,\n        8172,\n        8178,\n        8180,\n        8182,\n        8188,\n        8203,\n        8207,\n        8234,\n        8238,\n        8255,\n        8256,\n        8276,\n        8276,\n        8288,\n        8292,\n        8294,\n        8303,\n        8305,\n        8305,\n        8319,\n        8319,\n        8336,\n        8348,\n        8400,\n        8412,\n        8417,\n        8417,\n        8421,\n        8432,\n        8450,\n        8450,\n        8455,\n        8455,\n        8458,\n        8467,\n        8469,\n        8469,\n        8473,\n        8477,\n        8484,\n        8484,\n        8486,\n        8486,\n        8488,\n        8488,\n        8490,\n        8493,\n        8495,\n        8505,\n        8508,\n        8511,\n        8517,\n        8521,\n        8526,\n        8526,\n        8544,\n        8584,\n        11264,\n        11492,\n        11499,\n        11507,\n        11520,\n        11557,\n        11559,\n        11559,\n        11565,\n        11565,\n        11568,\n        11623,\n        11631,\n        11631,\n        11647,\n        11670,\n        11680,\n        11686,\n        11688,\n        11694,\n        11696,\n        11702,\n        11704,\n        11710,\n        11712,\n        11718,\n        11720,\n        11726,\n        11728,\n        11734,\n        11736,\n        11742,\n        11744,\n        11775,\n        11823,\n        11823,\n        12293,\n        12295,\n        12321,\n        12335,\n        12337,\n        12341,\n        12344,\n        12348,\n        12353,\n        12438,\n        12441,\n        12442,\n        12445,\n        12447,\n        12449,\n        12538,\n        12540,\n        12543,\n        12549,\n        12591,\n        12593,\n        12686,\n        12704,\n        12735,\n        12784,\n        12799,\n        13312,\n        19903,\n        19968,\n        42124,\n        42192,\n        42237,\n        42240,\n        42508,\n        42512,\n        42539,\n        42560,\n        42607,\n        42612,\n        42621,\n        42623,\n        42737,\n        42775,\n        42783,\n        42786,\n        42888,\n        42891,\n        42954,\n        42960,\n        42961,\n        42963,\n        42963,\n        42965,\n        42969,\n        42994,\n        43047,\n        43052,\n        43052,\n        43072,\n        43123,\n        43136,\n        43205,\n        43216,\n        43225,\n        43232,\n        43255,\n        43259,\n        43259,\n        43261,\n        43309,\n        43312,\n        43347,\n        43360,\n        43388,\n        43392,\n        43456,\n        43471,\n        43481,\n        43488,\n        43518,\n        43520,\n        43574,\n        43584,\n        43597,\n        43600,\n        43609,\n        43616,\n        43638,\n        43642,\n        43714,\n        43739,\n        43741,\n        43744,\n        43759,\n        43762,\n        43766,\n        43777,\n        43782,\n        43785,\n        43790,\n        43793,\n        43798,\n        43808,\n        43814,\n        43816,\n        43822,\n        43824,\n        43866,\n        43868,\n        43881,\n        43888,\n        44010,\n        44012,\n        44013,\n        44016,\n        44025,\n        44032,\n        55203,\n        55216,\n        55238,\n        55243,\n        55291,\n        63744,\n        64109,\n        64112,\n        64217,\n        64256,\n        64262,\n        64275,\n        64279,\n        64285,\n        64296,\n        64298,\n        64310,\n        64312,\n        64316,\n        64318,\n        64318,\n        64320,\n        64321,\n        64323,\n        64324,\n        64326,\n        64433,\n        64467,\n        64829,\n        64848,\n        64911,\n        64914,\n        64967,\n        65008,\n        65019,\n        65024,\n        65039,\n        65056,\n        65071,\n        65075,\n        65076,\n        65101,\n        65103,\n        65136,\n        65140,\n        65142,\n        65276,\n        65279,\n        65279,\n        65296,\n        65305,\n        65313,\n        65338,\n        65343,\n        65343,\n        65345,\n        65370,\n        65382,\n        65470,\n        65474,\n        65479,\n        65482,\n        65487,\n        65490,\n        65495,\n        65498,\n        65500,\n        65529,\n        65531,\n        65536,\n        65547,\n        65549,\n        65574,\n        65576,\n        65594,\n        65596,\n        65597,\n        65599,\n        65613,\n        65616,\n        65629,\n        65664,\n        65786,\n        65856,\n        65908,\n        66045,\n        66045,\n        66176,\n        66204,\n        66208,\n        66256,\n        66272,\n        66272,\n        66304,\n        66335,\n        66349,\n        66378,\n        66384,\n        66426,\n        66432,\n        66461,\n        66464,\n        66499,\n        66504,\n        66511,\n        66513,\n        66517,\n        66560,\n        66717,\n        66720,\n        66729,\n        66736,\n        66771,\n        66776,\n        66811,\n        66816,\n        66855,\n        66864,\n        66915,\n        66928,\n        66938,\n        66940,\n        66954,\n        66956,\n        66962,\n        66964,\n        66965,\n        66967,\n        66977,\n        66979,\n        66993,\n        66995,\n        67001,\n        67003,\n        67004,\n        67072,\n        67382,\n        67392,\n        67413,\n        67424,\n        67431,\n        67456,\n        67461,\n        67463,\n        67504,\n        67506,\n        67514,\n        67584,\n        67589,\n        67592,\n        67592,\n        67594,\n        67637,\n        67639,\n        67640,\n        67644,\n        67644,\n        67647,\n        67669,\n        67680,\n        67702,\n        67712,\n        67742,\n        67808,\n        67826,\n        67828,\n        67829,\n        67840,\n        67861,\n        67872,\n        67897,\n        67968,\n        68023,\n        68030,\n        68031,\n        68096,\n        68099,\n        68101,\n        68102,\n        68108,\n        68115,\n        68117,\n        68119,\n        68121,\n        68149,\n        68152,\n        68154,\n        68159,\n        68159,\n        68192,\n        68220,\n        68224,\n        68252,\n        68288,\n        68295,\n        68297,\n        68326,\n        68352,\n        68405,\n        68416,\n        68437,\n        68448,\n        68466,\n        68480,\n        68497,\n        68608,\n        68680,\n        68736,\n        68786,\n        68800,\n        68850,\n        68864,\n        68903,\n        68912,\n        68921,\n        69248,\n        69289,\n        69291,\n        69292,\n        69296,\n        69297,\n        69373,\n        69404,\n        69415,\n        69415,\n        69424,\n        69456,\n        69488,\n        69509,\n        69552,\n        69572,\n        69600,\n        69622,\n        69632,\n        69702,\n        69734,\n        69749,\n        69759,\n        69818,\n        69821,\n        69821,\n        69826,\n        69826,\n        69837,\n        69837,\n        69840,\n        69864,\n        69872,\n        69881,\n        69888,\n        69940,\n        69942,\n        69951,\n        69956,\n        69959,\n        69968,\n        70003,\n        70006,\n        70006,\n        70016,\n        70084,\n        70089,\n        70092,\n        70094,\n        70106,\n        70108,\n        70108,\n        70144,\n        70161,\n        70163,\n        70199,\n        70206,\n        70209,\n        70272,\n        70278,\n        70280,\n        70280,\n        70282,\n        70285,\n        70287,\n        70301,\n        70303,\n        70312,\n        70320,\n        70378,\n        70384,\n        70393,\n        70400,\n        70403,\n        70405,\n        70412,\n        70415,\n        70416,\n        70419,\n        70440,\n        70442,\n        70448,\n        70450,\n        70451,\n        70453,\n        70457,\n        70459,\n        70468,\n        70471,\n        70472,\n        70475,\n        70477,\n        70480,\n        70480,\n        70487,\n        70487,\n        70493,\n        70499,\n        70502,\n        70508,\n        70512,\n        70516,\n        70656,\n        70730,\n        70736,\n        70745,\n        70750,\n        70753,\n        70784,\n        70853,\n        70855,\n        70855,\n        70864,\n        70873,\n        71040,\n        71093,\n        71096,\n        71104,\n        71128,\n        71133,\n        71168,\n        71232,\n        71236,\n        71236,\n        71248,\n        71257,\n        71296,\n        71352,\n        71360,\n        71369,\n        71424,\n        71450,\n        71453,\n        71467,\n        71472,\n        71481,\n        71488,\n        71494,\n        71680,\n        71738,\n        71840,\n        71913,\n        71935,\n        71942,\n        71945,\n        71945,\n        71948,\n        71955,\n        71957,\n        71958,\n        71960,\n        71989,\n        71991,\n        71992,\n        71995,\n        72003,\n        72016,\n        72025,\n        72096,\n        72103,\n        72106,\n        72151,\n        72154,\n        72161,\n        72163,\n        72164,\n        72192,\n        72254,\n        72263,\n        72263,\n        72272,\n        72345,\n        72349,\n        72349,\n        72368,\n        72440,\n        72704,\n        72712,\n        72714,\n        72758,\n        72760,\n        72768,\n        72784,\n        72793,\n        72818,\n        72847,\n        72850,\n        72871,\n        72873,\n        72886,\n        72960,\n        72966,\n        72968,\n        72969,\n        72971,\n        73014,\n        73018,\n        73018,\n        73020,\n        73021,\n        73023,\n        73031,\n        73040,\n        73049,\n        73056,\n        73061,\n        73063,\n        73064,\n        73066,\n        73102,\n        73104,\n        73105,\n        73107,\n        73112,\n        73120,\n        73129,\n        73440,\n        73462,\n        73472,\n        73488,\n        73490,\n        73530,\n        73534,\n        73538,\n        73552,\n        73561,\n        73648,\n        73648,\n        73728,\n        74649,\n        74752,\n        74862,\n        74880,\n        75075,\n        77712,\n        77808,\n        77824,\n        78933,\n        82944,\n        83526,\n        92160,\n        92728,\n        92736,\n        92766,\n        92768,\n        92777,\n        92784,\n        92862,\n        92864,\n        92873,\n        92880,\n        92909,\n        92912,\n        92916,\n        92928,\n        92982,\n        92992,\n        92995,\n        93008,\n        93017,\n        93027,\n        93047,\n        93053,\n        93071,\n        93760,\n        93823,\n        93952,\n        94026,\n        94031,\n        94087,\n        94095,\n        94111,\n        94176,\n        94177,\n        94179,\n        94180,\n        94192,\n        94193,\n        94208,\n        100343,\n        100352,\n        101589,\n        101632,\n        101640,\n        110576,\n        110579,\n        110581,\n        110587,\n        110589,\n        110590,\n        110592,\n        110882,\n        110898,\n        110898,\n        110928,\n        110930,\n        110933,\n        110933,\n        110948,\n        110951,\n        110960,\n        111355,\n        113664,\n        113770,\n        113776,\n        113788,\n        113792,\n        113800,\n        113808,\n        113817,\n        113821,\n        113822,\n        113824,\n        113827,\n        118528,\n        118573,\n        118576,\n        118598,\n        119141,\n        119145,\n        119149,\n        119170,\n        119173,\n        119179,\n        119210,\n        119213,\n        119362,\n        119364,\n        119808,\n        119892,\n        119894,\n        119964,\n        119966,\n        119967,\n        119970,\n        119970,\n        119973,\n        119974,\n        119977,\n        119980,\n        119982,\n        119993,\n        119995,\n        119995,\n        119997,\n        120003,\n        120005,\n        120069,\n        120071,\n        120074,\n        120077,\n        120084,\n        120086,\n        120092,\n        120094,\n        120121,\n        120123,\n        120126,\n        120128,\n        120132,\n        120134,\n        120134,\n        120138,\n        120144,\n        120146,\n        120485,\n        120488,\n        120512,\n        120514,\n        120538,\n        120540,\n        120570,\n        120572,\n        120596,\n        120598,\n        120628,\n        120630,\n        120654,\n        120656,\n        120686,\n        120688,\n        120712,\n        120714,\n        120744,\n        120746,\n        120770,\n        120772,\n        120779,\n        120782,\n        120831,\n        121344,\n        121398,\n        121403,\n        121452,\n        121461,\n        121461,\n        121476,\n        121476,\n        121499,\n        121503,\n        121505,\n        121519,\n        122624,\n        122654,\n        122661,\n        122666,\n        122880,\n        122886,\n        122888,\n        122904,\n        122907,\n        122913,\n        122915,\n        122916,\n        122918,\n        122922,\n        122928,\n        122989,\n        123023,\n        123023,\n        123136,\n        123180,\n        123184,\n        123197,\n        123200,\n        123209,\n        123214,\n        123214,\n        123536,\n        123566,\n        123584,\n        123641,\n        124112,\n        124153,\n        124896,\n        124902,\n        124904,\n        124907,\n        124909,\n        124910,\n        124912,\n        124926,\n        124928,\n        125124,\n        125136,\n        125142,\n        125184,\n        125259,\n        125264,\n        125273,\n        126464,\n        126467,\n        126469,\n        126495,\n        126497,\n        126498,\n        126500,\n        126500,\n        126503,\n        126503,\n        126505,\n        126514,\n        126516,\n        126519,\n        126521,\n        126521,\n        126523,\n        126523,\n        126530,\n        126530,\n        126535,\n        126535,\n        126537,\n        126537,\n        126539,\n        126539,\n        126541,\n        126543,\n        126545,\n        126546,\n        126548,\n        126548,\n        126551,\n        126551,\n        126553,\n        126553,\n        126555,\n        126555,\n        126557,\n        126557,\n        126559,\n        126559,\n        126561,\n        126562,\n        126564,\n        126564,\n        126567,\n        126570,\n        126572,\n        126578,\n        126580,\n        126583,\n        126585,\n        126588,\n        126590,\n        126590,\n        126592,\n        126601,\n        126603,\n        126619,\n        126625,\n        126627,\n        126629,\n        126633,\n        126635,\n        126651,\n        130032,\n        130041,\n        131072,\n        173791,\n        173824,\n        177977,\n        177984,\n        178205,\n        178208,\n        183969,\n        183984,\n        191456,\n        194560,\n        195101,\n        196608,\n        201546,\n        201552,\n        205743,\n        917505,\n        917505,\n        917536,\n        917631,\n        917760,\n        917999,\n        662,\n        0,\n        65,\n        90,\n        97,\n        122,\n        170,\n        170,\n        181,\n        181,\n        186,\n        186,\n        192,\n        214,\n        216,\n        246,\n        248,\n        705,\n        710,\n        721,\n        736,\n        740,\n        748,\n        748,\n        750,\n        750,\n        880,\n        884,\n        886,\n        887,\n        890,\n        893,\n        895,\n        895,\n        902,\n        902,\n        904,\n        906,\n        908,\n        908,\n        910,\n        929,\n        931,\n        1013,\n        1015,\n        1153,\n        1162,\n        1327,\n        1329,\n        1366,\n        1369,\n        1369,\n        1376,\n        1416,\n        1488,\n        1514,\n        1519,\n        1522,\n        1568,\n        1610,\n        1646,\n        1647,\n        1649,\n        1747,\n        1749,\n        1749,\n        1765,\n        1766,\n        1774,\n        1775,\n        1786,\n        1788,\n        1791,\n        1791,\n        1808,\n        1808,\n        1810,\n        1839,\n        1869,\n        1957,\n        1969,\n        1969,\n        1994,\n        2026,\n        2036,\n        2037,\n        2042,\n        2042,\n        2048,\n        2069,\n        2074,\n        2074,\n        2084,\n        2084,\n        2088,\n        2088,\n        2112,\n        2136,\n        2144,\n        2154,\n        2160,\n        2183,\n        2185,\n        2190,\n        2208,\n        2249,\n        2308,\n        2361,\n        2365,\n        2365,\n        2384,\n        2384,\n        2392,\n        2401,\n        2417,\n        2432,\n        2437,\n        2444,\n        2447,\n        2448,\n        2451,\n        2472,\n        2474,\n        2480,\n        2482,\n        2482,\n        2486,\n        2489,\n        2493,\n        2493,\n        2510,\n        2510,\n        2524,\n        2525,\n        2527,\n        2529,\n        2544,\n        2545,\n        2556,\n        2556,\n        2565,\n        2570,\n        2575,\n        2576,\n        2579,\n        2600,\n        2602,\n        2608,\n        2610,\n        2611,\n        2613,\n        2614,\n        2616,\n        2617,\n        2649,\n        2652,\n        2654,\n        2654,\n        2674,\n        2676,\n        2693,\n        2701,\n        2703,\n        2705,\n        2707,\n        2728,\n        2730,\n        2736,\n        2738,\n        2739,\n        2741,\n        2745,\n        2749,\n        2749,\n        2768,\n        2768,\n        2784,\n        2785,\n        2809,\n        2809,\n        2821,\n        2828,\n        2831,\n        2832,\n        2835,\n        2856,\n        2858,\n        2864,\n        2866,\n        2867,\n        2869,\n        2873,\n        2877,\n        2877,\n        2908,\n        2909,\n        2911,\n        2913,\n        2929,\n        2929,\n        2947,\n        2947,\n        2949,\n        2954,\n        2958,\n        2960,\n        2962,\n        2965,\n        2969,\n        2970,\n        2972,\n        2972,\n        2974,\n        2975,\n        2979,\n        2980,\n        2984,\n        2986,\n        2990,\n        3001,\n        3024,\n        3024,\n        3077,\n        3084,\n        3086,\n        3088,\n        3090,\n        3112,\n        3114,\n        3129,\n        3133,\n        3133,\n        3160,\n        3162,\n        3165,\n        3165,\n        3168,\n        3169,\n        3200,\n        3200,\n        3205,\n        3212,\n        3214,\n        3216,\n        3218,\n        3240,\n        3242,\n        3251,\n        3253,\n        3257,\n        3261,\n        3261,\n        3293,\n        3294,\n        3296,\n        3297,\n        3313,\n        3314,\n        3332,\n        3340,\n        3342,\n        3344,\n        3346,\n        3386,\n        3389,\n        3389,\n        3406,\n        3406,\n        3412,\n        3414,\n        3423,\n        3425,\n        3450,\n        3455,\n        3461,\n        3478,\n        3482,\n        3505,\n        3507,\n        3515,\n        3517,\n        3517,\n        3520,\n        3526,\n        3585,\n        3632,\n        3634,\n        3635,\n        3648,\n        3654,\n        3713,\n        3714,\n        3716,\n        3716,\n        3718,\n        3722,\n        3724,\n        3747,\n        3749,\n        3749,\n        3751,\n        3760,\n        3762,\n        3763,\n        3773,\n        3773,\n        3776,\n        3780,\n        3782,\n        3782,\n        3804,\n        3807,\n        3840,\n        3840,\n        3904,\n        3911,\n        3913,\n        3948,\n        3976,\n        3980,\n        4096,\n        4138,\n        4159,\n        4159,\n        4176,\n        4181,\n        4186,\n        4189,\n        4193,\n        4193,\n        4197,\n        4198,\n        4206,\n        4208,\n        4213,\n        4225,\n        4238,\n        4238,\n        4256,\n        4293,\n        4295,\n        4295,\n        4301,\n        4301,\n        4304,\n        4346,\n        4348,\n        4680,\n        4682,\n        4685,\n        4688,\n        4694,\n        4696,\n        4696,\n        4698,\n        4701,\n        4704,\n        4744,\n        4746,\n        4749,\n        4752,\n        4784,\n        4786,\n        4789,\n        4792,\n        4798,\n        4800,\n        4800,\n        4802,\n        4805,\n        4808,\n        4822,\n        4824,\n        4880,\n        4882,\n        4885,\n        4888,\n        4954,\n        4992,\n        5007,\n        5024,\n        5109,\n        5112,\n        5117,\n        5121,\n        5740,\n        5743,\n        5759,\n        5761,\n        5786,\n        5792,\n        5866,\n        5870,\n        5880,\n        5888,\n        5905,\n        5919,\n        5937,\n        5952,\n        5969,\n        5984,\n        5996,\n        5998,\n        6e3,\n        6016,\n        6067,\n        6103,\n        6103,\n        6108,\n        6108,\n        6176,\n        6264,\n        6272,\n        6276,\n        6279,\n        6312,\n        6314,\n        6314,\n        6320,\n        6389,\n        6400,\n        6430,\n        6480,\n        6509,\n        6512,\n        6516,\n        6528,\n        6571,\n        6576,\n        6601,\n        6656,\n        6678,\n        6688,\n        6740,\n        6823,\n        6823,\n        6917,\n        6963,\n        6981,\n        6988,\n        7043,\n        7072,\n        7086,\n        7087,\n        7098,\n        7141,\n        7168,\n        7203,\n        7245,\n        7247,\n        7258,\n        7293,\n        7296,\n        7304,\n        7312,\n        7354,\n        7357,\n        7359,\n        7401,\n        7404,\n        7406,\n        7411,\n        7413,\n        7414,\n        7418,\n        7418,\n        7424,\n        7615,\n        7680,\n        7957,\n        7960,\n        7965,\n        7968,\n        8005,\n        8008,\n        8013,\n        8016,\n        8023,\n        8025,\n        8025,\n        8027,\n        8027,\n        8029,\n        8029,\n        8031,\n        8061,\n        8064,\n        8116,\n        8118,\n        8124,\n        8126,\n        8126,\n        8130,\n        8132,\n        8134,\n        8140,\n        8144,\n        8147,\n        8150,\n        8155,\n        8160,\n        8172,\n        8178,\n        8180,\n        8182,\n        8188,\n        8305,\n        8305,\n        8319,\n        8319,\n        8336,\n        8348,\n        8450,\n        8450,\n        8455,\n        8455,\n        8458,\n        8467,\n        8469,\n        8469,\n        8473,\n        8477,\n        8484,\n        8484,\n        8486,\n        8486,\n        8488,\n        8488,\n        8490,\n        8493,\n        8495,\n        8505,\n        8508,\n        8511,\n        8517,\n        8521,\n        8526,\n        8526,\n        8544,\n        8584,\n        11264,\n        11492,\n        11499,\n        11502,\n        11506,\n        11507,\n        11520,\n        11557,\n        11559,\n        11559,\n        11565,\n        11565,\n        11568,\n        11623,\n        11631,\n        11631,\n        11648,\n        11670,\n        11680,\n        11686,\n        11688,\n        11694,\n        11696,\n        11702,\n        11704,\n        11710,\n        11712,\n        11718,\n        11720,\n        11726,\n        11728,\n        11734,\n        11736,\n        11742,\n        11823,\n        11823,\n        12293,\n        12295,\n        12321,\n        12329,\n        12337,\n        12341,\n        12344,\n        12348,\n        12353,\n        12438,\n        12445,\n        12447,\n        12449,\n        12538,\n        12540,\n        12543,\n        12549,\n        12591,\n        12593,\n        12686,\n        12704,\n        12735,\n        12784,\n        12799,\n        13312,\n        19903,\n        19968,\n        42124,\n        42192,\n        42237,\n        42240,\n        42508,\n        42512,\n        42527,\n        42538,\n        42539,\n        42560,\n        42606,\n        42623,\n        42653,\n        42656,\n        42735,\n        42775,\n        42783,\n        42786,\n        42888,\n        42891,\n        42954,\n        42960,\n        42961,\n        42963,\n        42963,\n        42965,\n        42969,\n        42994,\n        43009,\n        43011,\n        43013,\n        43015,\n        43018,\n        43020,\n        43042,\n        43072,\n        43123,\n        43138,\n        43187,\n        43250,\n        43255,\n        43259,\n        43259,\n        43261,\n        43262,\n        43274,\n        43301,\n        43312,\n        43334,\n        43360,\n        43388,\n        43396,\n        43442,\n        43471,\n        43471,\n        43488,\n        43492,\n        43494,\n        43503,\n        43514,\n        43518,\n        43520,\n        43560,\n        43584,\n        43586,\n        43588,\n        43595,\n        43616,\n        43638,\n        43642,\n        43642,\n        43646,\n        43695,\n        43697,\n        43697,\n        43701,\n        43702,\n        43705,\n        43709,\n        43712,\n        43712,\n        43714,\n        43714,\n        43739,\n        43741,\n        43744,\n        43754,\n        43762,\n        43764,\n        43777,\n        43782,\n        43785,\n        43790,\n        43793,\n        43798,\n        43808,\n        43814,\n        43816,\n        43822,\n        43824,\n        43866,\n        43868,\n        43881,\n        43888,\n        44002,\n        44032,\n        55203,\n        55216,\n        55238,\n        55243,\n        55291,\n        63744,\n        64109,\n        64112,\n        64217,\n        64256,\n        64262,\n        64275,\n        64279,\n        64285,\n        64285,\n        64287,\n        64296,\n        64298,\n        64310,\n        64312,\n        64316,\n        64318,\n        64318,\n        64320,\n        64321,\n        64323,\n        64324,\n        64326,\n        64433,\n        64467,\n        64829,\n        64848,\n        64911,\n        64914,\n        64967,\n        65008,\n        65019,\n        65136,\n        65140,\n        65142,\n        65276,\n        65313,\n        65338,\n        65345,\n        65370,\n        65382,\n        65470,\n        65474,\n        65479,\n        65482,\n        65487,\n        65490,\n        65495,\n        65498,\n        65500,\n        65536,\n        65547,\n        65549,\n        65574,\n        65576,\n        65594,\n        65596,\n        65597,\n        65599,\n        65613,\n        65616,\n        65629,\n        65664,\n        65786,\n        65856,\n        65908,\n        66176,\n        66204,\n        66208,\n        66256,\n        66304,\n        66335,\n        66349,\n        66378,\n        66384,\n        66421,\n        66432,\n        66461,\n        66464,\n        66499,\n        66504,\n        66511,\n        66513,\n        66517,\n        66560,\n        66717,\n        66736,\n        66771,\n        66776,\n        66811,\n        66816,\n        66855,\n        66864,\n        66915,\n        66928,\n        66938,\n        66940,\n        66954,\n        66956,\n        66962,\n        66964,\n        66965,\n        66967,\n        66977,\n        66979,\n        66993,\n        66995,\n        67001,\n        67003,\n        67004,\n        67072,\n        67382,\n        67392,\n        67413,\n        67424,\n        67431,\n        67456,\n        67461,\n        67463,\n        67504,\n        67506,\n        67514,\n        67584,\n        67589,\n        67592,\n        67592,\n        67594,\n        67637,\n        67639,\n        67640,\n        67644,\n        67644,\n        67647,\n        67669,\n        67680,\n        67702,\n        67712,\n        67742,\n        67808,\n        67826,\n        67828,\n        67829,\n        67840,\n        67861,\n        67872,\n        67897,\n        67968,\n        68023,\n        68030,\n        68031,\n        68096,\n        68096,\n        68112,\n        68115,\n        68117,\n        68119,\n        68121,\n        68149,\n        68192,\n        68220,\n        68224,\n        68252,\n        68288,\n        68295,\n        68297,\n        68324,\n        68352,\n        68405,\n        68416,\n        68437,\n        68448,\n        68466,\n        68480,\n        68497,\n        68608,\n        68680,\n        68736,\n        68786,\n        68800,\n        68850,\n        68864,\n        68899,\n        69248,\n        69289,\n        69296,\n        69297,\n        69376,\n        69404,\n        69415,\n        69415,\n        69424,\n        69445,\n        69488,\n        69505,\n        69552,\n        69572,\n        69600,\n        69622,\n        69635,\n        69687,\n        69745,\n        69746,\n        69749,\n        69749,\n        69763,\n        69807,\n        69840,\n        69864,\n        69891,\n        69926,\n        69956,\n        69956,\n        69959,\n        69959,\n        69968,\n        70002,\n        70006,\n        70006,\n        70019,\n        70066,\n        70081,\n        70084,\n        70106,\n        70106,\n        70108,\n        70108,\n        70144,\n        70161,\n        70163,\n        70187,\n        70207,\n        70208,\n        70272,\n        70278,\n        70280,\n        70280,\n        70282,\n        70285,\n        70287,\n        70301,\n        70303,\n        70312,\n        70320,\n        70366,\n        70405,\n        70412,\n        70415,\n        70416,\n        70419,\n        70440,\n        70442,\n        70448,\n        70450,\n        70451,\n        70453,\n        70457,\n        70461,\n        70461,\n        70480,\n        70480,\n        70493,\n        70497,\n        70656,\n        70708,\n        70727,\n        70730,\n        70751,\n        70753,\n        70784,\n        70831,\n        70852,\n        70853,\n        70855,\n        70855,\n        71040,\n        71086,\n        71128,\n        71131,\n        71168,\n        71215,\n        71236,\n        71236,\n        71296,\n        71338,\n        71352,\n        71352,\n        71424,\n        71450,\n        71488,\n        71494,\n        71680,\n        71723,\n        71840,\n        71903,\n        71935,\n        71942,\n        71945,\n        71945,\n        71948,\n        71955,\n        71957,\n        71958,\n        71960,\n        71983,\n        71999,\n        71999,\n        72001,\n        72001,\n        72096,\n        72103,\n        72106,\n        72144,\n        72161,\n        72161,\n        72163,\n        72163,\n        72192,\n        72192,\n        72203,\n        72242,\n        72250,\n        72250,\n        72272,\n        72272,\n        72284,\n        72329,\n        72349,\n        72349,\n        72368,\n        72440,\n        72704,\n        72712,\n        72714,\n        72750,\n        72768,\n        72768,\n        72818,\n        72847,\n        72960,\n        72966,\n        72968,\n        72969,\n        72971,\n        73008,\n        73030,\n        73030,\n        73056,\n        73061,\n        73063,\n        73064,\n        73066,\n        73097,\n        73112,\n        73112,\n        73440,\n        73458,\n        73474,\n        73474,\n        73476,\n        73488,\n        73490,\n        73523,\n        73648,\n        73648,\n        73728,\n        74649,\n        74752,\n        74862,\n        74880,\n        75075,\n        77712,\n        77808,\n        77824,\n        78895,\n        78913,\n        78918,\n        82944,\n        83526,\n        92160,\n        92728,\n        92736,\n        92766,\n        92784,\n        92862,\n        92880,\n        92909,\n        92928,\n        92975,\n        92992,\n        92995,\n        93027,\n        93047,\n        93053,\n        93071,\n        93760,\n        93823,\n        93952,\n        94026,\n        94032,\n        94032,\n        94099,\n        94111,\n        94176,\n        94177,\n        94179,\n        94179,\n        94208,\n        100343,\n        100352,\n        101589,\n        101632,\n        101640,\n        110576,\n        110579,\n        110581,\n        110587,\n        110589,\n        110590,\n        110592,\n        110882,\n        110898,\n        110898,\n        110928,\n        110930,\n        110933,\n        110933,\n        110948,\n        110951,\n        110960,\n        111355,\n        113664,\n        113770,\n        113776,\n        113788,\n        113792,\n        113800,\n        113808,\n        113817,\n        119808,\n        119892,\n        119894,\n        119964,\n        119966,\n        119967,\n        119970,\n        119970,\n        119973,\n        119974,\n        119977,\n        119980,\n        119982,\n        119993,\n        119995,\n        119995,\n        119997,\n        120003,\n        120005,\n        120069,\n        120071,\n        120074,\n        120077,\n        120084,\n        120086,\n        120092,\n        120094,\n        120121,\n        120123,\n        120126,\n        120128,\n        120132,\n        120134,\n        120134,\n        120138,\n        120144,\n        120146,\n        120485,\n        120488,\n        120512,\n        120514,\n        120538,\n        120540,\n        120570,\n        120572,\n        120596,\n        120598,\n        120628,\n        120630,\n        120654,\n        120656,\n        120686,\n        120688,\n        120712,\n        120714,\n        120744,\n        120746,\n        120770,\n        120772,\n        120779,\n        122624,\n        122654,\n        122661,\n        122666,\n        122928,\n        122989,\n        123136,\n        123180,\n        123191,\n        123197,\n        123214,\n        123214,\n        123536,\n        123565,\n        123584,\n        123627,\n        124112,\n        124139,\n        124896,\n        124902,\n        124904,\n        124907,\n        124909,\n        124910,\n        124912,\n        124926,\n        124928,\n        125124,\n        125184,\n        125251,\n        125259,\n        125259,\n        126464,\n        126467,\n        126469,\n        126495,\n        126497,\n        126498,\n        126500,\n        126500,\n        126503,\n        126503,\n        126505,\n        126514,\n        126516,\n        126519,\n        126521,\n        126521,\n        126523,\n        126523,\n        126530,\n        126530,\n        126535,\n        126535,\n        126537,\n        126537,\n        126539,\n        126539,\n        126541,\n        126543,\n        126545,\n        126546,\n        126548,\n        126548,\n        126551,\n        126551,\n        126553,\n        126553,\n        126555,\n        126555,\n        126557,\n        126557,\n        126559,\n        126559,\n        126561,\n        126562,\n        126564,\n        126564,\n        126567,\n        126570,\n        126572,\n        126578,\n        126580,\n        126583,\n        126585,\n        126588,\n        126590,\n        126590,\n        126592,\n        126601,\n        126603,\n        126619,\n        126625,\n        126627,\n        126629,\n        126633,\n        126635,\n        126651,\n        131072,\n        173791,\n        173824,\n        177977,\n        177984,\n        178205,\n        178208,\n        183969,\n        183984,\n        191456,\n        194560,\n        195101,\n        196608,\n        201546,\n        201552,\n        205743,\n        47,\n        0,\n        1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        3,\n        1,\n        0,\n        0,\n        0,\n        0,\n        5,\n        1,\n        0,\n        0,\n        0,\n        0,\n        7,\n        1,\n        0,\n        0,\n        0,\n        0,\n        9,\n        1,\n        0,\n        0,\n        0,\n        0,\n        15,\n        1,\n        0,\n        0,\n        0,\n        1,\n        17,\n        1,\n        0,\n        0,\n        0,\n        3,\n        20,\n        1,\n        0,\n        0,\n        0,\n        5,\n        22,\n        1,\n        0,\n        0,\n        0,\n        7,\n        24,\n        1,\n        0,\n        0,\n        0,\n        9,\n        26,\n        1,\n        0,\n        0,\n        0,\n        11,\n        35,\n        1,\n        0,\n        0,\n        0,\n        13,\n        37,\n        1,\n        0,\n        0,\n        0,\n        15,\n        39,\n        1,\n        0,\n        0,\n        0,\n        17,\n        18,\n        5,\n        47,\n        0,\n        0,\n        18,\n        19,\n        5,\n        47,\n        0,\n        0,\n        19,\n        2,\n        1,\n        0,\n        0,\n        0,\n        20,\n        21,\n        5,\n        47,\n        0,\n        0,\n        21,\n        4,\n        1,\n        0,\n        0,\n        0,\n        22,\n        23,\n        5,\n        42,\n        0,\n        0,\n        23,\n        6,\n        1,\n        0,\n        0,\n        0,\n        24,\n        25,\n        5,\n        33,\n        0,\n        0,\n        25,\n        8,\n        1,\n        0,\n        0,\n        0,\n        26,\n        30,\n        3,\n        13,\n        6,\n        0,\n        27,\n        29,\n        3,\n        11,\n        5,\n        0,\n        28,\n        27,\n        1,\n        0,\n        0,\n        0,\n        29,\n        32,\n        1,\n        0,\n        0,\n        0,\n        30,\n        28,\n        1,\n        0,\n        0,\n        0,\n        30,\n        31,\n        1,\n        0,\n        0,\n        0,\n        31,\n        33,\n        1,\n        0,\n        0,\n        0,\n        32,\n        30,\n        1,\n        0,\n        0,\n        0,\n        33,\n        34,\n        6,\n        4,\n        0,\n        0,\n        34,\n        10,\n        1,\n        0,\n        0,\n        0,\n        35,\n        36,\n        7,\n        0,\n        0,\n        0,\n        36,\n        12,\n        1,\n        0,\n        0,\n        0,\n        37,\n        38,\n        7,\n        1,\n        0,\n        0,\n        38,\n        14,\n        1,\n        0,\n        0,\n        0,\n        39,\n        43,\n        5,\n        39,\n        0,\n        0,\n        40,\n        42,\n        9,\n        0,\n        0,\n        0,\n        41,\n        40,\n        1,\n        0,\n        0,\n        0,\n        42,\n        45,\n        1,\n        0,\n        0,\n        0,\n        43,\n        44,\n        1,\n        0,\n        0,\n        0,\n        43,\n        41,\n        1,\n        0,\n        0,\n        0,\n        44,\n        46,\n        1,\n        0,\n        0,\n        0,\n        45,\n        43,\n        1,\n        0,\n        0,\n        0,\n        46,\n        47,\n        5,\n        39,\n        0,\n        0,\n        47,\n        16,\n        1,\n        0,\n        0,\n        0,\n        3,\n        0,\n        30,\n        43,\n        1,\n        1,\n        4,\n        0\n    ];\n    static __ATN;\n    static get _ATN() {\n        if (!_XPathLexer.__ATN) _XPathLexer.__ATN = new $c1efbdb2cbf46748$export$8d551c119323a3a7().deserialize(_XPathLexer._serializedATN);\n        return _XPathLexer.__ATN;\n    }\n    static vocabulary = new $c1efbdb2cbf46748$export$6fe78fc0b86aec88(_XPathLexer.literalNames, _XPathLexer.symbolicNames, []);\n    get vocabulary() {\n        return _XPathLexer.vocabulary;\n    }\n    static decisionsToDFA = _XPathLexer._ATN.decisionToState.map((ds, index)=>{\n        return new $c1efbdb2cbf46748$export$d210bcfe90c75f0(ds, index);\n    });\n};\n// src/tree/xpath/XPathLexerErrorListener.ts\nvar $c1efbdb2cbf46748$export$73e018a229fb3ec2 = class extends $c1efbdb2cbf46748$export$2746258315f6b7a5 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathLexerErrorListener\");\n    }\n    syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {}\n};\n// src/tree/xpath/XPathElement.ts\nvar $c1efbdb2cbf46748$export$1c34f17cc753a4b3 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathElement\");\n    }\n    invert;\n    nodeName;\n    /**\n   * Construct element like `/ID` or `ID` or `/*` etc... `nodeName` is undefined if just node\n   *\n   * @param nodeName The name of the node; may be undefined for any node.\n   */ constructor(nodeName){\n        this.nodeName = nodeName;\n        this.invert = false;\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathRuleAnywhereElement.ts\nvar $c1efbdb2cbf46748$export$799f9af540cf584c = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathRuleAnywhereElement\");\n    }\n    ruleIndex;\n    constructor(ruleName, ruleIndex){\n        super(ruleName);\n        this.ruleIndex = ruleIndex;\n    }\n    evaluate(t) {\n        return $c1efbdb2cbf46748$export$18233453f5804371.findAllRuleNodes(t, this.ruleIndex);\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathRuleAnywhereElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathRuleElement.ts\nvar $c1efbdb2cbf46748$export$98cb6373280e2e5e = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathRuleElement\");\n    }\n    ruleIndex;\n    constructor(ruleName, ruleIndex){\n        super(ruleName);\n        this.ruleIndex = ruleIndex;\n    }\n    evaluate(t) {\n        const nodes = [];\n        for (const c of $c1efbdb2cbf46748$export$18233453f5804371.getChildren(t)){\n            if (c instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n                if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) nodes.push(c);\n            }\n        }\n        return nodes;\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathRuleElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathTokenAnywhereElement.ts\nvar $c1efbdb2cbf46748$export$f55fe643209e0e5 = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathTokenAnywhereElement\");\n    }\n    tokenType;\n    constructor(tokenName, tokenType){\n        super(tokenName);\n        this.tokenType = tokenType;\n    }\n    evaluate(t) {\n        return $c1efbdb2cbf46748$export$18233453f5804371.findAllTokenNodes(t, this.tokenType);\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathTokenAnywhereElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathTokenElement.ts\nvar $c1efbdb2cbf46748$export$836948de4f287b87 = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathTokenElement\");\n    }\n    tokenType;\n    constructor(tokenName, tokenType){\n        super(tokenName);\n        this.tokenType = tokenType;\n    }\n    evaluate(t) {\n        const nodes = [];\n        for (const c of $c1efbdb2cbf46748$export$18233453f5804371.getChildren(t)){\n            if (c instanceof $c1efbdb2cbf46748$export$f6a002739fa43001 && c.symbol) {\n                if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) nodes.push(c);\n            }\n        }\n        return nodes;\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathTokenElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathWildcardAnywhereElement.ts\nvar $c1efbdb2cbf46748$export$c74723909eb3fe20 = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathWildcardAnywhereElement\");\n    }\n    constructor(){\n        super($c1efbdb2cbf46748$export$5aad3c96ca5049d2.WILDCARD);\n    }\n    evaluate(t) {\n        if (this.invert) return [];\n        return $c1efbdb2cbf46748$export$18233453f5804371.descendants(t);\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathWildcardAnywhereElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPathWildcardElement.ts\nvar $c1efbdb2cbf46748$export$7a9cd09469f0bdd4 = class extends $c1efbdb2cbf46748$export$1c34f17cc753a4b3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPathWildcardElement\");\n    }\n    constructor(){\n        super($c1efbdb2cbf46748$export$5aad3c96ca5049d2.WILDCARD);\n    }\n    evaluate(t) {\n        const kids = [];\n        if (this.invert) return kids;\n        for (const c of $c1efbdb2cbf46748$export$18233453f5804371.getChildren(t))kids.push(c);\n        return kids;\n    }\n    toString() {\n        const inv = this.invert ? \"!\" : \"\";\n        return \"XPathWildcardElement[\" + inv + this.nodeName + \"]\";\n    }\n};\n// src/tree/xpath/XPath.ts\nvar $c1efbdb2cbf46748$export$5aad3c96ca5049d2 = class _XPath {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"XPath\");\n    }\n    static WILDCARD = \"*\";\n    // word not operator/separator\n    static NOT = \"!\";\n    // word for invert operator\n    path;\n    elements;\n    parser;\n    constructor(parser, path){\n        this.parser = parser;\n        this.path = path;\n        this.elements = this.split(path);\n    }\n    static findAll(tree, xpath, parser) {\n        const p = new _XPath(parser, xpath);\n        return p.evaluate(tree);\n    }\n    // TODO: check for invalid token/rule names, bad syntax\n    split(path) {\n        const lexer = new $c1efbdb2cbf46748$export$5b42d76e23d5259b($c1efbdb2cbf46748$export$7bbbaf2220a3f180.fromString(path));\n        lexer.recover = (e)=>{\n            throw e;\n        };\n        lexer.removeErrorListeners();\n        lexer.addErrorListener(new $c1efbdb2cbf46748$export$73e018a229fb3ec2());\n        const tokenStream = new $c1efbdb2cbf46748$export$3b6c0b5bd4a5b0b9(lexer);\n        try {\n            tokenStream.fill();\n        } catch (e) {\n            if (e instanceof $c1efbdb2cbf46748$export$b0273c9bf9a740df) {\n                const pos = lexer.column;\n                const msg = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\n                throw new RangeError(msg);\n            }\n            throw e;\n        }\n        const tokens = tokenStream.getTokens();\n        const elements = [];\n        const n2 = tokens.length;\n        let i = 0;\n        loop: while(i < n2){\n            const el = tokens[i];\n            let next;\n            switch(el.type){\n                case $c1efbdb2cbf46748$export$5b42d76e23d5259b.ROOT:\n                case $c1efbdb2cbf46748$export$5b42d76e23d5259b.ANYWHERE:\n                    const anywhere = el.type === $c1efbdb2cbf46748$export$5b42d76e23d5259b.ANYWHERE;\n                    i++;\n                    next = tokens[i];\n                    const invert = next.type === $c1efbdb2cbf46748$export$5b42d76e23d5259b.BANG;\n                    if (invert) {\n                        i++;\n                        next = tokens[i];\n                    }\n                    const pathElement = this.getXPathElement(next, anywhere);\n                    pathElement.invert = invert;\n                    elements.push(pathElement);\n                    i++;\n                    break;\n                case $c1efbdb2cbf46748$export$5b42d76e23d5259b.TOKEN_REF:\n                case $c1efbdb2cbf46748$export$5b42d76e23d5259b.RULE_REF:\n                case $c1efbdb2cbf46748$export$5b42d76e23d5259b.WILDCARD:\n                    elements.push(this.getXPathElement(el, false));\n                    ++i;\n                    break;\n                case $c1efbdb2cbf46748$export$50792b0e93539fde.EOF:\n                    break loop;\n                default:\n                    throw new Error(\"Unknown path element \" + el);\n            }\n        }\n        return elements;\n    }\n    /**\n   * Return a list of all nodes starting at `t` as root that satisfy the\n   * path. The root `/` is relative to the node passed to {@link evaluate}.\n   */ evaluate(t) {\n        const dummyRoot = new $c1efbdb2cbf46748$export$1198dca6f94b6253(null);\n        dummyRoot.addChild(t);\n        let work = /* @__PURE__ */ new Set([\n            dummyRoot\n        ]);\n        let i = 0;\n        while(i < this.elements.length){\n            const next = /* @__PURE__ */ new Set();\n            for (const node of work)if (node.getChildCount() > 0) {\n                const matching = this.elements[i].evaluate(node);\n                matching.forEach((tree)=>{\n                    next.add(tree);\n                }, next);\n            }\n            i++;\n            work = next;\n        }\n        return work;\n    }\n    /**\n   * Convert word like `*` or `ID` or `expr` to a path\n   * element. `anywhere` is `true` if `//` precedes the\n   * word.\n   */ getXPathElement(wordToken, anywhere) {\n        if (wordToken.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) throw new Error(\"Missing path element at end of path\");\n        const word = wordToken.text;\n        if (word == null) throw new Error(\"Expected wordToken to have text content.\");\n        const ttype = this.parser.getTokenType(word);\n        const ruleIndex = this.parser.getRuleIndex(word);\n        switch(wordToken.type){\n            case $c1efbdb2cbf46748$export$5b42d76e23d5259b.WILDCARD:\n                return anywhere ? new $c1efbdb2cbf46748$export$c74723909eb3fe20() : new $c1efbdb2cbf46748$export$7a9cd09469f0bdd4();\n            case $c1efbdb2cbf46748$export$5b42d76e23d5259b.TOKEN_REF:\n            case $c1efbdb2cbf46748$export$5b42d76e23d5259b.STRING:\n                if (ttype === $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE) throw new Error(word + \" at index \" + wordToken.start + \" isn't a valid token name\");\n                return anywhere ? new $c1efbdb2cbf46748$export$f55fe643209e0e5(word, ttype) : new $c1efbdb2cbf46748$export$836948de4f287b87(word, ttype);\n            default:\n                if (ruleIndex === -1) throw new Error(word + \" at index \" + wordToken.start + \" isn't a valid rule name\");\n                return anywhere ? new $c1efbdb2cbf46748$export$799f9af540cf584c(word, ruleIndex) : new $c1efbdb2cbf46748$export$98cb6373280e2e5e(word, ruleIndex);\n        }\n    }\n};\n// src/tree/pattern/Chunk.ts\nvar $c1efbdb2cbf46748$export$5a0870a55ad02f1a = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Chunk\");\n    }\n};\n// src/tree/pattern/ParseTreeMatch.ts\nvar $c1efbdb2cbf46748$export$81a18305c772520b = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseTreeMatch\");\n    }\n    /**\n   * This is the backing field for {@link #getTree()}.\n   */ tree;\n    /**\n   * This is the backing field for {@link #getPattern()}.\n   */ pattern;\n    /**\n   * This is the backing field for {@link #getLabels()}.\n   */ labels;\n    /**\n   * This is the backing field for {@link #getMismatchedNode()}.\n   */ mismatchedNode;\n    /**\n   * Constructs a new instance of {@link ParseTreeMatch} from the specified\n   * parse tree and pattern.\n   *\n   * @param tree The parse tree to match against the pattern.\n   * @param pattern The parse tree pattern.\n   * @param labels A mapping from label names to collections of\n   * {@link ParseTree} objects located by the tree pattern matching process.\n   * @param mismatchedNode The first node which failed to match the tree\n   * pattern during the matching process.\n   */ constructor(tree, pattern, labels, mismatchedNode){\n        this.tree = tree;\n        this.pattern = pattern;\n        this.labels = labels;\n        this.mismatchedNode = mismatchedNode;\n    }\n    /**\n   * Get the last node associated with a specific `label`.\n   *\n   * For example, for pattern `<id:ID>`, `get(\"id\")` returns the\n   * node matched for that `ID`. If more than one node\n   * matched the specified label, only the last is returned. If there is\n   * no node associated with the label, this returns `null`.\n   *\n   * Pattern tags like `<ID>` and `<expr>` without labels are\n   * considered to be labeled with `ID` and `expr`, respectively.\n   *\n   * @param label The label to check.\n   *\n   * @returns The last {@link ParseTree} to match a tag with the specified\n   * label, or `null` if no parse tree matched a tag with the label.\n   */ get(label) {\n        const parseTrees = this.labels.get(label);\n        if (!parseTrees || parseTrees.length === 0) return null;\n        return parseTrees[parseTrees.length - 1];\n    }\n    /**\n   * Return all nodes matching a rule or token tag with the specified label.\n   *\n   * If the `label` is the name of a parser rule or token in the\n   * grammar, the resulting list will contain both the parse trees matching\n   * rule or tags explicitly labeled with the label and the complete set of\n   * parse trees matching the labeled and unlabeled tags in the pattern for\n   * the parser rule or token. For example, if `label` is `\"foo\"`,\n   * the result will contain *all* of the following.\n   *\n   * - Parse tree nodes matching tags of the form `<foo:anyRuleName>` and\n   * `<foo:AnyTokenName>`.\n   * - Parse tree nodes matching tags of the form `<anyLabel:foo>`.\n   * - Parse tree nodes matching tags of the form `<foo>`.\n   *\n   * @param label The label.\n   *\n   * @returns A collection of all {@link ParseTree} nodes matching tags with\n   * the specified `label`. If no nodes matched the label, an empty list\n   * is returned.\n   */ getAll(label) {\n        const nodes = this.labels.get(label);\n        return nodes ?? [];\n    }\n    /**\n   * Return a mapping from label -> [list of nodes].\n   *\n   * The map includes special entries corresponding to the names of rules and\n   * tokens referenced in tags in the original pattern. For additional\n   * information, see the description of {@link getAll(String)}.\n   *\n   * @returns A mapping from labels to parse tree nodes. If the parse tree\n   * pattern did not contain any rule or token tags, this map will be empty.\n   */ getLabels() {\n        return this.labels;\n    }\n    /**\n   * Get the node at which we first detected a mismatch.\n   *\n   * @returns the node at which we first detected a mismatch, or `null`\n   * if the match was successful.\n   */ getMismatchedNode() {\n        return this.mismatchedNode;\n    }\n    /**\n   * Gets a value indicating whether the match operation succeeded.\n   *\n   * @returns `true` if the match operation succeeded; otherwise, `false`.\n   */ succeeded() {\n        return !this.mismatchedNode;\n    }\n    /**\n   * Get the tree pattern we are matching against.\n   *\n   * @returns The tree pattern we are matching against.\n   */ getPattern() {\n        return this.pattern;\n    }\n    /**\n   * Get the parse tree we are trying to match to a pattern.\n   *\n   * @returns The {@link ParseTree} we are trying to match to a pattern.\n   */ getTree() {\n        return this.tree;\n    }\n    toString() {\n        return `Match ${this.succeeded() ? \"succeeded\" : \"failed\"}; found ${this.getLabels().size} labels`;\n    }\n};\n// src/tree/pattern/ParseTreePattern.ts\nvar $c1efbdb2cbf46748$export$4644540f3a71357c = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseTreePattern\");\n    }\n    /**\n   * This is the backing field for {@link #getPatternRuleIndex()}.\n   */ patternRuleIndex;\n    /**\n   * This is the backing field for {@link #getPattern()}.\n   */ pattern;\n    /**\n   * This is the backing field for {@link #getPatternTree()}.\n   */ patternTree;\n    /**\n   * This is the backing field for {@link #getMatcher()}.\n   */ matcher;\n    /**\n   * Construct a new instance of the {@link ParseTreePattern} class.\n   *\n   * @param matcher The {@link ParseTreePatternMatcher} which created this\n   * tree pattern.\n   * @param pattern The tree pattern in concrete syntax form.\n   * @param patternRuleIndex The parser rule which serves as the root of the\n   * tree pattern.\n   * @param patternTree The tree pattern in {@link ParseTree} form.\n   */ constructor(matcher, pattern, patternRuleIndex, patternTree){\n        this.matcher = matcher;\n        this.patternRuleIndex = patternRuleIndex;\n        this.pattern = pattern;\n        this.patternTree = patternTree;\n    }\n    /**\n   * Match a specific parse tree against this tree pattern.\n   *\n   * @param tree The parse tree to match against this tree pattern.\n   * @returns A {@link ParseTreeMatch} object describing the result of the\n   * match operation. The {@link ParseTreeMatch#succeeded()} method can be\n   * used to determine whether or not the match was successful.\n   */ match(tree) {\n        return this.matcher.match(tree, this);\n    }\n    /**\n   * Determine whether or not a parse tree matches this tree pattern.\n   *\n   * @param tree The parse tree to match against this tree pattern.\n   * @returns `true` if `tree` is a match for the current tree\n   * pattern; otherwise, `false`.\n   */ matches(tree) {\n        return this.matcher.match(tree, this).succeeded();\n    }\n    /**\n   * Find all nodes using XPath and then try to match those subtrees against\n   * this tree pattern.\n   *\n   * @param tree The {@link ParseTree} to match against this pattern.\n   * @param xpath An expression matching the nodes\n   *\n   * @returns A collection of {@link ParseTreeMatch} objects describing the\n   * successful matches. Unsuccessful matches are omitted from the result,\n   * regardless of the reason for the failure.\n   */ findAll(tree, xpath) {\n        const subtrees = $c1efbdb2cbf46748$export$5aad3c96ca5049d2.findAll(tree, xpath, this.matcher.getParser());\n        const matches = new Array();\n        for (const t of subtrees){\n            const match = this.match(t);\n            if (match.succeeded()) matches.push(match);\n        }\n        return matches;\n    }\n    /**\n   * Get the {@link ParseTreePatternMatcher} which created this tree pattern.\n   *\n   * @returns The {@link ParseTreePatternMatcher} which created this tree\n   * pattern.\n   */ getMatcher() {\n        return this.matcher;\n    }\n    /**\n   * Get the tree pattern in concrete syntax form.\n   *\n   * @returns The tree pattern in concrete syntax form.\n   */ getPattern() {\n        return this.pattern;\n    }\n    /**\n   * Get the parser rule which serves as the outermost rule for the tree\n   * pattern.\n   *\n   * @returns The parser rule which serves as the outermost rule for the tree\n   * pattern.\n   */ getPatternRuleIndex() {\n        return this.patternRuleIndex;\n    }\n    /**\n   * Get the tree pattern as a {@link ParseTree}. The rule and token tags from\n   * the pattern are present in the parse tree as terminal nodes with a symbol\n   * of type {@link RuleTagToken} or {@link TokenTagToken}.\n   *\n   * @returns The tree pattern as a {@link ParseTree}.\n   */ getPatternTree() {\n        return this.patternTree;\n    }\n};\n// src/InputMismatchException.ts\nvar $c1efbdb2cbf46748$export$d9ee09ac275d2b50 = class extends $c1efbdb2cbf46748$export$c1c401305ad687ac {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"InputMismatchException\");\n    }\n    constructor(recognizer){\n        super({\n            message: \"\",\n            recognizer: recognizer,\n            input: recognizer.inputStream,\n            ctx: recognizer.context\n        });\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n};\n// src/FailedPredicateException.ts\nvar $c1efbdb2cbf46748$export$30ec716fb19257aa = class extends $c1efbdb2cbf46748$export$c1c401305ad687ac {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"FailedPredicateException\");\n    }\n    ruleIndex = 0;\n    predicateIndex = 0;\n    predicate;\n    constructor(recognizer, predicate, message = null){\n        super({\n            message: $c1efbdb2cbf46748$var$formatMessage(predicate ?? \"no predicate\", message ?? null),\n            recognizer: recognizer,\n            input: recognizer.inputStream,\n            ctx: recognizer.context\n        });\n        const s = recognizer.atn.states[recognizer.state];\n        const trans = s.transitions[0];\n        if (trans instanceof $c1efbdb2cbf46748$export$5cb5e35f9f7e22cb) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n};\nvar $c1efbdb2cbf46748$var$formatMessage = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((predicate, message)=>{\n    if (message !== null) return message;\n    return \"failed predicate: {\" + predicate + \"}?\";\n}, \"formatMessage\");\n// src/DefaultErrorStrategy.ts\nvar $c1efbdb2cbf46748$export$adb4ae595794600e = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DefaultErrorStrategy\");\n    }\n    /**\n   * Indicates whether the error strategy is currently \"recovering from an\n   * error\". This is used to suppress reporting multiple error messages while\n   * attempting to recover from a detected syntax error.\n   *\n   * @see #inErrorRecoveryMode\n   */ errorRecoveryMode = false;\n    /**\n   * The index into the input stream where the last error occurred.\n   * \tThis is used to prevent infinite loops where an error is found\n   *  but no token is consumed during recovery...another error is found,\n   *  ad nauseam.  This is a failsafe mechanism to guarantee that at least\n   *  one token/tree node is consumed for two errors.\n   */ lastErrorIndex = -1;\n    lastErrorStates = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n    /**\n   * This field is used to propagate information about the lookahead following\n   * the previous match. Since prediction prefers completing the current rule\n   * to error recovery efforts, error reporting may occur later than the\n   * original point where it was discoverable. The original context is used to\n   * compute the true expected sets as though the reporting occurred as early\n   * as possible.\n   */ nextTokensContext = null;\n    nextTokenState = 0;\n    /**\n   * The default implementation simply calls {@link endErrorCondition} to\n   * ensure that the handler is not in error recovery mode.\n   */ reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n    /**\n   * This method is called to enter error recovery mode when a recognition\n   * exception is reported.\n   *\n   * @param _recognizer the parser instance\n   */ beginErrorCondition(_recognizer) {\n        this.errorRecoveryMode = true;\n    }\n    inErrorRecoveryMode(_recognizer) {\n        return this.errorRecoveryMode;\n    }\n    /**\n   * This method is called to leave error recovery mode after recovering from\n   * a recognition exception.\n   */ endErrorCondition(_recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n        this.lastErrorIndex = -1;\n    }\n    /**\n   * The default implementation simply calls {@link endErrorCondition}.\n   */ reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n    /**\n   * The default implementation returns immediately if the handler is already\n   * in error recovery mode. Otherwise, it calls {@link beginErrorCondition}\n   * and dispatches the reporting task based on the runtime type of `e`\n   * according to the following table.\n   *\n   * - {@link NoViableAltException}: Dispatches the call to {@link reportNoViableAlternative}\n   * - {@link InputMismatchException}: Dispatches the call to {@link reportInputMismatch}\n   * - {@link FailedPredicateException}: Dispatches the call to {@link reportFailedPredicate}\n   * - All other types: calls {@link Parser.notifyErrorListeners} to report the exception\n   */ reportError(recognizer, e) {\n        if (this.inErrorRecoveryMode(recognizer)) return;\n        this.beginErrorCondition(recognizer);\n        if (e instanceof $c1efbdb2cbf46748$export$24170894ee7a3e61) this.reportNoViableAlternative(recognizer, e);\n        else if (e instanceof $c1efbdb2cbf46748$export$d9ee09ac275d2b50) this.reportInputMismatch(recognizer, e);\n        else if (e instanceof $c1efbdb2cbf46748$export$30ec716fb19257aa) this.reportFailedPredicate(recognizer, e);\n        else recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n    }\n    /**\n   * The default implementation resynchronizes the parser by consuming tokens\n   * until we find one in the resynchronization set--loosely the set of tokens\n   * that can follow the current rule.\n   *\n   */ recover(recognizer, _e) {\n        if (this.lastErrorIndex === recognizer.inputStream?.index && this.lastErrorStates.contains(recognizer.state)) recognizer.consume();\n        this.lastErrorIndex = recognizer.inputStream?.index ?? 0;\n        this.lastErrorStates.addOne(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer);\n        this.consumeUntil(recognizer, followSet);\n    }\n    /**\n   * The default implementation of {@link ANTLRErrorStrategy.sync} makes sure\n   * that the current lookahead symbol is consistent with what were expecting\n   * at this point in the ATN. You can call this anytime but ANTLR only\n   * generates code to check before subrules/loops and each iteration.\n   *\n   * Implements Jim Idle's magic sync mechanism in closures and optional\n   * subrules. E.g.,\n   *\n   * ```\n   * a : sync ( stuff sync )* ;\n   * sync : {consume to what can follow sync} ;\n   * ```\n   *\n   * At the start of a sub rule upon error, {@link sync} performs single\n   * token deletion, if possible. If it can't do that, it bails on the current\n   * rule and uses the default error recovery, which consumes until the\n   * resynchronization set of the current rule.\n   *\n   * If the sub rule is optional (`(...)?`, `(...)*`, or block\n   * with an empty alternative), then the expected set includes what follows\n   * the subrule.\n   *\n   * During loop iteration, it consumes until it sees a token that can start a\n   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n   * stay in the loop as long as possible.\n   *\n   * **ORIGINS**\n   *\n   * Previous versions of ANTLR did a poor job of their recovery within loops.\n   * A single mismatch token or missing token would force the parser to bail\n   * out of the entire rules surrounding the loop. So, for rule\n   *\n   * ```\n   * classDef : 'class' ID '{' member* '}'\n   * ```\n   *\n   * input with an extra token between members would force the parser to\n   * consume until it found the next class definition rather than the next\n   * member definition of the current class.\n   *\n   * This functionality cost a little bit of effort because the parser has to\n   * compare token set at the start of the loop and at each iteration. If for\n   * some reason speed is suffering for you, you can turn off this\n   * functionality by simply overriding this method as a blank { }.\n   *\n   */ sync(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) return;\n        const s = recognizer.atn.states[recognizer.state];\n        const la = recognizer.tokenStream.LA(1);\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if (nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = $c1efbdb2cbf46748$export$21a6260de0fddd55.INVALID_STATE_NUMBER;\n            return;\n        }\n        if (nextTokens.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)) {\n            if (this.nextTokensContext === null) {\n                this.nextTokensContext = recognizer.context;\n                this.nextTokenState = recognizer.state;\n            }\n            return;\n        }\n        switch(s.constructor.stateType){\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.BLOCK_START:\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_BLOCK_START:\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_BLOCK_START:\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_ENTRY:\n                if (this.singleTokenDeletion(recognizer) !== null) return;\n                throw new $c1efbdb2cbf46748$export$d9ee09ac275d2b50(recognizer);\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.PLUS_LOOP_BACK:\n            case $c1efbdb2cbf46748$export$21a6260de0fddd55.STAR_LOOP_BACK:\n                {\n                    this.reportUnwantedToken(recognizer);\n                    const expecting = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n                    expecting.addSet(recognizer.getExpectedTokens());\n                    const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n                    this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n                    break;\n                }\n            default:\n        }\n    }\n    /**\n   * This is called by {@link reportError} when the exception is a\n   * {@link NoViableAltException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */ reportNoViableAlternative(recognizer, e) {\n        if (e.message.length > 0) {\n            recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n            return;\n        }\n        const tokens = recognizer.tokenStream;\n        let input;\n        if (tokens !== null && e.startToken) {\n            if (e.startToken.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) input = \"<EOF>\";\n            else input = tokens.getTextFromRange(e.startToken, e.offendingToken);\n        } else input = \"<unknown input>\";\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    /**\n   * This is called by {@link reportError} when the exception is an {@link InputMismatchException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */ reportInputMismatch(recognizer, e) {\n        if (e.message.length > 0) {\n            recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n            return;\n        }\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) + \" expecting \" + e.getExpectedTokens().toStringWithVocabulary(recognizer.vocabulary);\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    /**\n   * This is called by {@link reportError} when the exception is a\n   * {@link FailedPredicateException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */ reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];\n        const msg = \"rule \" + ruleName + \" \" + e.message;\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n    /**\n   * This method is called to report a syntax error which requires the removal\n   * of a token from the input stream. At the time this method is called, the\n   * erroneous symbol is current `LT(1)` symbol and has not yet been\n   * removed from the input stream. When this method returns,\n   * `recognizer` is in error recovery mode.\n   *\n   * This method is called when {@link singleTokenDeletion} identifies\n   * single-token deletion as a viable recovery strategy for a mismatched\n   * input error.\n   *\n   * The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser.notifyErrorListeners}.\n   *\n   * @param recognizer the parser instance\n   */ reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) return;\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken();\n        const tokenName = this.getTokenErrorDisplay(t);\n        const expecting = this.getExpectedTokens(recognizer);\n        const msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toStringWithVocabulary(recognizer.vocabulary);\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n    /**\n   * This method is called to report a syntax error which requires the\n   * insertion of a missing token into the input stream. At the time this\n   * method is called, the missing token has not yet been inserted. When this\n   * method returns, `recognizer` is in error recovery mode.\n   *\n   * This method is called when {@link singleTokenInsertion} identifies\n   * single-token insertion as a viable recovery strategy for a mismatched\n   * input error.\n   *\n   * The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser.notifyErrorListeners}.\n   *\n   * @param recognizer the parser instance\n   */ reportMissingToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) return;\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken();\n        const expecting = this.getExpectedTokens(recognizer);\n        const msg = \"missing \" + expecting.toStringWithVocabulary(recognizer.vocabulary) + \" at \" + this.getTokenErrorDisplay(t);\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n    /**\n   * The default implementation attempts to recover from the mismatched input\n   * by using single token insertion and deletion as described below. If the\n   * recovery attempt fails, this method throws an\n   * {@link InputMismatchException}.\n   *\n   * **EXTRA TOKEN** (single token deletion)\n   *\n   * `LA(1)` is not what we are looking for. If `LA(2)` has the\n   * right token, however, then assume `LA(1)` is some extra spurious\n   * token and delete it. Then consume and return the next token (which was\n   * the `LA(2)` token) as the successful result of the match operation.\n   *\n   * This recovery strategy is implemented by {@link singleTokenDeletion}.\n   *\n   * **MISSING TOKEN** (single token insertion)\n   *\n   * If current token (at `LA(1)`) is consistent with what could come\n   * after the expected `LA(1)` token, then assume the token is missing\n   * and use the parser's {@link TokenFactory} to create it on the fly. The\n   * \"insertion\" is performed by returning the created token as the successful\n   * result of the match operation.\n   *\n   * This recovery strategy is implemented by {@link singleTokenInsertion}.\n   *\n   * **EXAMPLE**\n   *\n   * For example, Input `i=(3;` is clearly missing the `')'`. When\n   * the parser returns from the nested call to `expr`, it will have\n   * call chain:\n   *\n   * ```\n   * stat -> expr -> atom\n   * ```\n   *\n   * and it will be trying to match the `')'` at this point in the\n   * derivation:\n   *\n   * ```\n   * => ID '=' '(' INT ')' ('+' atom)* ';'\n   * ^\n   * ```\n   *\n   * The attempt to match `')'` will fail when it sees `';'` and\n   * call {@link recoverInline}. To recover, it sees that `LA(1)==';'`\n   * is in the set of tokens that can follow the `')'` token reference\n   * in rule `atom`. It can assume that you forgot the `')'`.\n   */ recoverInline(recognizer) {\n        const matchedSymbol = this.singleTokenDeletion(recognizer);\n        if (matchedSymbol) {\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        if (this.singleTokenInsertion(recognizer)) return this.getMissingSymbol(recognizer);\n        throw new $c1efbdb2cbf46748$export$d9ee09ac275d2b50(recognizer);\n    }\n    /**\n   * This method implements the single-token insertion inline error recovery\n   * strategy. It is called by {@link recoverInline} if the single-token\n   * deletion strategy fails to recover from the mismatched input. If this\n   * method returns `true`, `recognizer` will be in error recovery\n   * mode.\n   *\n   * This method determines whether or not single-token insertion is viable by\n   * checking if the `LA(1)` input symbol could be successfully matched\n   * if it were instead the `LA(2)` symbol. If this method returns\n   * `true`, the caller is responsible for creating and inserting a\n   * token with the correct type to produce this behavior.\n   *\n   * @param recognizer the parser instance\n   * @returns `true` if single-token insertion is a viable recovery\n   * strategy for the current mismatched input, otherwise `false`\n   */ singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.tokenStream?.LA(1) ?? -1;\n        const atn = recognizer.atn;\n        const currentState = atn.states[recognizer.state];\n        const next = currentState.transitions[0].target;\n        const expectingAtLL2 = atn.nextTokens(next, recognizer.context ?? void 0);\n        if (expectingAtLL2.contains(currentSymbolType)) {\n            this.reportMissingToken(recognizer);\n            return true;\n        }\n        return false;\n    }\n    /**\n   * This method implements the single-token deletion inline error recovery\n   * strategy. It is called by {@link recoverInline} to attempt to recover\n   * from mismatched input. If this method returns null, the parser and error\n   * handler state will not have changed. If this method returns non-null,\n   * `recognizer` will *not* be in error recovery mode since the\n   * returned token was a successful match.\n   *\n   * If the single-token deletion is successful, this method calls\n   * {@link reportUnwantedToken} to report the error, followed by\n   * {@link Parser.consume} to actually \"delete\" the extraneous token. Then,\n   * before returning {@link reportMatch} is called to signal a successful\n   * match.\n   *\n   * @param recognizer the parser instance\n   * @returns the successfully matched {@link Token} instance if single-token\n   * deletion successfully recovers from the mismatched input, otherwise\n   * `null`\n   */ singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.tokenStream?.LA(2) ?? -1;\n        const expecting = this.getExpectedTokens(recognizer);\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            recognizer.consume();\n            const matchedSymbol = recognizer.getCurrentToken();\n            this.reportMatch(recognizer);\n            return matchedSymbol;\n        }\n        return null;\n    }\n    /**\n   * Conjure up a missing token during error recovery.\n   *\n   * The recognizer attempts to recover from single missing\n   * symbols. But, actions might refer to that missing symbol.\n   * For example, x=ID {f($x);}. The action clearly assumes\n   * that there has been an identifier matched previously and that\n   * $x points at that token. If that token is missing, but\n   * the next token in the stream is what we want we assume that\n   * this token is missing and we keep going. Because we\n   * have to return some token to replace the missing token,\n   * we have to conjure one up. This method gives the user control\n   * over the tokens returned for missing tokens. Mostly,\n   * you will want to create something special for identifier\n   * tokens. For literals such as '{' and ',', the default\n   * action in the parser or tree parser works. It simply creates\n   * a CommonToken of the appropriate type. The text will be the token.\n   * If you change what tokens must be created by the lexer,\n   * override this method to create the appropriate tokens.\n   */ getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken();\n        const expecting = this.getExpectedTokens(recognizer);\n        let expectedTokenType = $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n        if (expecting.length !== 0) expectedTokenType = expecting.minElement;\n        let tokenText;\n        if (expectedTokenType === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) tokenText = \"<missing EOF>\";\n        else tokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\n        let current = currentSymbol;\n        const lookBack = recognizer.tokenStream?.LT(-1);\n        if (current.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF && lookBack !== null) current = lookBack;\n        return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL, -1, -1, current.line, current.column);\n    }\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n    /**\n   * How should a token be displayed in an error message? The default\n   * is to display just the text, but during development you might\n   * want to have a lot of information spit out. Override in that case\n   * to use t.toString() (which, for CommonToken, dumps everything about\n   * the token). This is better than forcing you to override a method in\n   * your token objects because you don't have to go modify your lexer\n   * so that it creates a new Java type.\n   */ getTokenErrorDisplay(t) {\n        if (t === null) return \"<no token>\";\n        let s = t.text;\n        if (!s) {\n            if (t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) s = \"<EOF>\";\n            else s = \"<\" + t.type + \">\";\n        }\n        return this.escapeWSAndQuote(s);\n    }\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g, \"\\\\n\");\n        s = s.replace(/\\r/g, \"\\\\r\");\n        s = s.replace(/\\t/g, \"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n    /**\n   * Compute the error recovery set for the current rule. During\n   * rule invocation, the parser pushes the set of tokens that can\n   * follow that rule reference on the stack; this amounts to\n   * computing FIRST of what follows the rule reference in the\n   * enclosing rule. See LinearApproximator.FIRST().\n   * This local follow set only includes tokens\n   * from within the rule; i.e., the FIRST computation done by\n   * ANTLR stops at the end of a rule.\n   *\n   * EXAMPLE\n   *\n   * When you find a \"no viable alt exception\", the input is not\n   * consistent with any of the alternatives for rule r. The best\n   * thing to do is to consume tokens until you see something that\n   * can legally follow a call to r//or* any rule that called r.\n   * You don't want the exact set of viable next tokens because the\n   * input might just be missing a token--you might consume the\n   * rest of the input looking for one of the missing tokens.\n   *\n   * Consider grammar:\n   *\n   * a : '[' b ']'\n   * | '(' b ')'\n   * ;\n   * b : c '^' INT ;\n   * c : ID\n   * | INT\n   * ;\n   *\n   * At each rule invocation, the set of tokens that could follow\n   * that rule is pushed on a stack. Here are the various\n   * context-sensitive follow sets:\n   *\n   * FOLLOW(b1_in_a) = FIRST(']') = ']'\n   * FOLLOW(b2_in_a) = FIRST(')') = ')'\n   * FOLLOW(c_in_b) = FIRST('^') = '^'\n   *\n   * Upon erroneous input \"[]\", the call chain is\n   *\n   * a -> b -> c\n   *\n   * and, hence, the follow context stack is:\n   *\n   * depth follow set start of rule execution\n   * 0 <EOF> a (from main())\n   * 1 ']' b\n   * 2 '^' c\n   *\n   * Notice that ')' is not included, because b would have to have\n   * been called from a different context in rule a for ')' to be\n   * included.\n   *\n   * For error recovery, we cannot consider FOLLOW(c)\n   * (context-sensitive or otherwise). We need the combined set of\n   * all context-sensitive FOLLOW sets--the set of all tokens that\n   * could follow any reference in the call chain. We need to\n   * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n   * we resync'd to that token, we'd consume until EOF. We need to\n   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n   * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n   * not consume anything. After printing an error, rule c would\n   * return normally. Rule b would not find the required '^' though.\n   * At this point, it gets a mismatched token error and throws an\n   * exception (since LA(1) is not in the viable following token\n   * set). The rule exception handler tries to recover, but finds\n   * the same recovery set and doesn't consume anything. Rule b\n   * exits normally returning to rule a. Now it finds the ']' (and\n   * with the successful match exits errorRecovery mode).\n   *\n   * So, you can see that the parser walks up the call chain looking\n   * for the token that was a member of the recovery set.\n   *\n   * Errors are not generated in errorRecovery mode.\n   *\n   * ANTLR's error recovery mechanism is based upon original ideas:\n   *\n   * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n   *\n   * and\n   *\n   * \"A note on error recovery in recursive descent parsers\":\n   * http://portal.acm.org/citation.cfm?id=947902.947905\n   *\n   * Later, Josef Grosch had some good ideas:\n   *\n   * \"Efficient and Comfortable Error Recovery in Recursive Descent\n   * Parsers\":\n   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n   *\n   * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n   * at run-time upon error to avoid overhead during parsing.\n   */ getErrorRecoverySet(recognizer) {\n        const atn = recognizer.atn;\n        let ctx = recognizer.context;\n        const recoverSet = new $c1efbdb2cbf46748$export$9aa814bfdfb30f8f();\n        while(ctx !== null && ctx.invokingState >= 0){\n            const invokingState = atn.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            const follow = atn.nextTokens(rt.followState);\n            recoverSet.addSet(follow);\n            ctx = ctx.parent;\n        }\n        recoverSet.removeOne($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON);\n        return recoverSet;\n    }\n    /** Consume tokens until one matches the given token set. */ consumeUntil(recognizer, set) {\n        let ttype = recognizer.tokenStream?.LA(1) ?? -1;\n        while(ttype !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF && !set.contains(ttype)){\n            recognizer.consume();\n            ttype = recognizer.tokenStream?.LA(1) ?? -1;\n        }\n    }\n};\n// src/BailErrorStrategy.ts\nvar $c1efbdb2cbf46748$export$cabbde8fee9a839f = class extends $c1efbdb2cbf46748$export$adb4ae595794600e {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"BailErrorStrategy\");\n    }\n    /**\n   * Instead of recovering from exception `e`, re-throw it wrapped\n   * in a {@link ParseCancellationException} so it is not caught by the\n   * rule function catches. Use {@link Exception//getCause()} to get the\n   * original {@link RecognitionException}.\n   */ recover(recognizer, e) {\n        throw new $c1efbdb2cbf46748$export$6b89c498ba520494(e);\n    }\n    /**\n   * Make sure we don't attempt to recover inline; if the parser\n   * successfully recovers, it won't throw an exception.\n   */ recoverInline(recognizer) {\n        const exception = new $c1efbdb2cbf46748$export$d9ee09ac275d2b50(recognizer);\n        throw new $c1efbdb2cbf46748$export$6b89c498ba520494(exception);\n    }\n    // Make sure we don't attempt to recover from problems in subrules.\n    sync(_recognizer) {}\n};\n// src/ListTokenSource.ts\nvar $c1efbdb2cbf46748$export$e0b3f8bf1c84aaf0 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ListTokenSource\");\n    }\n    /**\n   * The name of the input source. If this value is `null`, a call to\n   * {@link #getSourceName} should return the source name used to create the\n   * the next token in {@link #tokens} (or the previous token if the end of\n   * the input has been reached).\n   */ sourceName;\n    tokenFactory = $c1efbdb2cbf46748$export$37f5fb6f74ae1f7.DEFAULT;\n    /**\n   * The wrapped collection of {@link Token} objects to return.\n   */ tokens = [];\n    /**\n   * The index into {@link tokens} of token to return by the next call to\n   * {@link #nextToken}. The end of the input is indicated by this value\n   * being greater than or equal to the number of items in {@link #tokens}.\n   */ i = 0;\n    /**\n   * This field caches the EOF token for the token source.\n   */ eofToken = null;\n    constructor(tokens, sourceName){\n        this.tokens = tokens;\n        this.sourceName = sourceName ?? \"\";\n    }\n    get column() {\n        if (this.i < this.tokens.length) return this.tokens[this.i].column;\n        if (this.eofToken !== null) return this.eofToken.column;\n        if (this.tokens.length > 0) {\n            const lastToken = this.tokens[this.tokens.length - 1];\n            const tokenText = lastToken.text;\n            if (tokenText) {\n                const lastNewLine = tokenText.lastIndexOf(\"\\n\");\n                if (lastNewLine >= 0) return tokenText.length - lastNewLine - 1;\n            }\n            return lastToken.column + lastToken.stop - lastToken.start + 1;\n        }\n        return 0;\n    }\n    nextToken() {\n        if (this.i >= this.tokens.length) {\n            if (this.eofToken === null) {\n                let start = -1;\n                if (this.tokens.length > 0) {\n                    const previousStop = this.tokens[this.tokens.length - 1].stop;\n                    if (previousStop !== -1) start = previousStop + 1;\n                }\n                const stop = Math.max(-1, start - 1);\n                this.eofToken = this.tokenFactory.create([\n                    this,\n                    this.inputStream\n                ], $c1efbdb2cbf46748$export$50792b0e93539fde.EOF, \"EOF\", $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL, start, stop, this.line, this.column);\n            }\n            return this.eofToken;\n        }\n        const t = this.tokens[this.i];\n        if (this.i === this.tokens.length - 1 && t.type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) this.eofToken = t;\n        this.i++;\n        return t;\n    }\n    get line() {\n        if (this.i < this.tokens.length) return this.tokens[this.i].line;\n        if (this.eofToken !== null) return this.eofToken.line;\n        if (this.tokens.length > 0) {\n            const lastToken = this.tokens[this.tokens.length - 1];\n            let line = lastToken.line;\n            const tokenText = lastToken.text;\n            if (tokenText) {\n                for (const char of tokenText)if (char === \"\\n\") line++;\n            }\n            return line;\n        }\n        return 1;\n    }\n    get inputStream() {\n        if (this.i < this.tokens.length) return this.tokens[this.i].inputStream;\n        if (this.eofToken !== null) return this.eofToken.inputStream;\n        if (this.tokens.length > 0) return this.tokens[this.tokens.length - 1].inputStream;\n        return null;\n    }\n    getSourceName() {\n        if (this.sourceName !== null) return this.sourceName;\n        const inputStream = this.inputStream;\n        if (inputStream !== null) return inputStream.getSourceName();\n        return \"List\";\n    }\n};\n// src/InterpreterRuleContext.ts\nvar $c1efbdb2cbf46748$export$c0116ce21f634f83 = class extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"InterpreterRuleContext\");\n    }\n    /** This is the backing field for {@link #getRuleIndex}. */ #ruleIndex;\n    constructor(ruleIndex, parent, invokingStateNumber){\n        super(parent, invokingStateNumber);\n        this.#ruleIndex = ruleIndex;\n    }\n    get ruleIndex() {\n        return this.#ruleIndex;\n    }\n};\n// src/TraceListener.ts\nvar $c1efbdb2cbf46748$export$4f4d5f744a81e34d = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TraceListener\");\n    }\n    parser;\n    constructor(parser){\n        this.parser = parser;\n    }\n    enterEveryRule(ctx) {\n        console.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser.inputStream?.LT(1)?.text);\n    }\n    visitTerminal(node) {\n        console.log(\"consume \" + node.getSymbol() + \" rule \" + this.parser.ruleNames[this.parser.context.ruleIndex]);\n    }\n    exitEveryRule(ctx) {\n        console.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser.inputStream?.LT(1)?.text);\n    }\n    visitErrorNode(_node) {}\n};\n// src/Parser.ts\nvar $c1efbdb2cbf46748$export$7acfa6ed01010e37 = class extends $c1efbdb2cbf46748$export$d051b53981c4a264 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"Parser\");\n    }\n    /** For testing only. */ printer = null;\n    /**\n   * Specifies whether or not the parser should construct a parse tree during\n   * the parsing process. The default value is `true`.\n   *\n   * @see #getBuildParseTree\n   * @see #setBuildParseTree\n   */ buildParseTrees = true;\n    /**\n   * The error handling strategy for the parser. The default value is a new\n   * instance of {@link DefaultErrorStrategy}.\n   *\n   * @see #getErrorHandler\n   * @see #setErrorHandler\n   */ errorHandler = new $c1efbdb2cbf46748$export$adb4ae595794600e();\n    /**\n   * The {@link ParserRuleContext} object for the currently executing rule.\n   * This is always non-null during the parsing process.\n   */ // TODO: make private\n    context = null;\n    precedenceStack = [];\n    /**\n   * The list of {@link ParseTreeListener} listeners registered to receive\n   * events during the parse.\n   *\n   * @see #addParseListener\n   */ parseListeners = null;\n    /**\n   * The number of syntax errors reported during parsing. This value is\n   * incremented each time {@link #notifyErrorListeners} is called.\n   */ syntaxErrors = 0;\n    /** Indicates parser has matched EOF token. See {@link #exitRule()}. */ matchedEOF = false;\n    /**\n   * When {@link #setTrace}`(true)` is called, a reference to the\n   * {@link TraceListener} is stored here so it can be easily removed in a\n   * later call to {@link #setTrace}`(false)`. The listener itself is\n   * implemented as a parser listener so this field is not directly used by\n   * other parser methods.\n   */ tracer = null;\n    /**\n   * This field holds the deserialized {@link ATN} with bypass alternatives, created\n   * lazily upon first demand. In 4.10 I changed from map<serializedATNString, ATN>\n   * since we only need one per parser object and also it complicates other targets\n   * that don't use ATN strings.\n   *\n   * @see ATNDeserializationOptions#isGenerateRuleBypassTransitions()\n   */ bypassAltsAtnCache = null;\n    #inputStream;\n    /**\n   * This is all the parsing support code essentially. Most of it is error recovery stuff.\n   */ constructor(input){\n        super();\n        this.precedenceStack.push(0);\n        this.syntaxErrors = 0;\n        this.#inputStream = input;\n    }\n    /** reset the parser's state */ reset(rewindInputStream = true) {\n        if (rewindInputStream) this.inputStream.seek(0);\n        this.errorHandler.reset(this);\n        this.context = null;\n        this.syntaxErrors = 0;\n        this.matchedEOF = false;\n        this.setTrace(false);\n        this.precedenceStack = [];\n        this.precedenceStack.push(0);\n        if (this.interpreter) this.interpreter.reset();\n    }\n    /**\n   * Match current input symbol against `ttype`. If the symbol type\n   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link consume} are\n   * called to complete the match process.\n   *\n   * If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link buildParseTree} is\n   * `true` and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.\n   *\n   * @param ttype the token type to match\n   * @returns the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * `ttype` and the error strategy could not recover from the\n   * mismatched symbol\n   */ match(ttype) {\n        let t = this.getCurrentToken();\n        if (t.type === ttype) {\n            if (ttype === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) this.matchedEOF = true;\n            this.errorHandler.reportMatch(this);\n            this.consume();\n        } else {\n            t = this.errorHandler.recoverInline(this);\n            if (this.buildParseTrees && t.tokenIndex === -1) this.context.addErrorNode(this.createErrorNode(this.context, t));\n        }\n        return t;\n    }\n    /**\n   * Match current input symbol as a wildcard. If the symbol type matches\n   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n   * and {@link consume} are called to complete the match process.\n   *\n   * If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link buildParseTree} is\n   * `true` and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.\n   *\n   * @returns the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * a wildcard and the error strategy could not recover from the mismatched\n   * symbol\n   */ matchWildcard() {\n        let t = this.getCurrentToken();\n        if (t.type > 0) {\n            this.errorHandler.reportMatch(this);\n            this.consume();\n        } else {\n            t = this.errorHandler.recoverInline(this);\n            if (this.buildParseTrees && t.tokenIndex === -1) this.context.addErrorNode(this.createErrorNode(this.context, t));\n        }\n        return t;\n    }\n    getParseListeners() {\n        return this.parseListeners ?? [];\n    }\n    /**\n   * Registers `listener` to receive events during the parsing process.\n   *\n   * To support output-preserving grammar transformations (including but not\n   * limited to left-recursion removal, automated left-factoring, and\n   * optimized code generation), calls to listener methods during the parse\n   * may differ substantially from calls made by\n   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n   * particular, rule entry and exit events may occur in a different order\n   * during the parse than after the parser. In addition, calls to certain\n   * rule entry methods may be omitted.\n   *\n   * With the following specific exceptions, calls to listener events are\n   * deterministic*, i.e. for identical input the calls to listener\n   * methods will be the same.\n   *\n   * - Alterations to the grammar used to generate code may change the\n   * behavior of the listener calls.\n   * - Alterations to the command line options passed to ANTLR 4 when\n   * generating the parser may change the behavior of the listener calls.\n   * - Changing the version of the ANTLR Tool used to generate the parser\n   * may change the behavior of the listener calls.\n   *\n   * @param listener the listener to add\n   *\n   * @throws NullPointerException if {@code} listener is `null`\n   */ addParseListener(listener) {\n        if (listener === null) throw new Error(\"listener\");\n        if (this.parseListeners === null) this.parseListeners = [];\n        this.parseListeners.push(listener);\n    }\n    /**\n   * Remove `listener` from the list of parse listeners.\n   *\n   * If `listener` is `null` or has not been added as a parse\n   * listener, this method does nothing.\n   *\n   * @param listener the listener to remove\n   */ removeParseListener(listener) {\n        if (this.parseListeners !== null && listener !== null) {\n            const idx = this.parseListeners.indexOf(listener);\n            if (idx >= 0) this.parseListeners.splice(idx, 1);\n            if (this.parseListeners.length === 0) this.parseListeners = null;\n        }\n    }\n    // Remove all parse listeners.\n    removeParseListeners() {\n        this.parseListeners = null;\n    }\n    // Notify any parse listeners of an enter rule event.\n    triggerEnterRuleEvent() {\n        if (this.parseListeners !== null) {\n            const ctx = this.context;\n            this.parseListeners.forEach((listener)=>{\n                listener.enterEveryRule(ctx);\n                ctx.enterRule(listener);\n            });\n        }\n    }\n    /**\n   * Notify any parse listeners of an exit rule event.\n   *\n   * @see //addParseListener\n   */ triggerExitRuleEvent() {\n        if (this.parseListeners !== null) {\n            const ctx = this.context;\n            this.parseListeners.slice(0).reverse().forEach((listener)=>{\n                ctx.exitRule(listener);\n                listener.exitEveryRule(ctx);\n            });\n        }\n    }\n    getTokenFactory() {\n        return this.inputStream.tokenSource.tokenFactory;\n    }\n    // Tell our token source and error strategy about a new way to create tokens.\n    setTokenFactory(factory) {\n        this.inputStream.tokenSource.tokenFactory = factory;\n    }\n    /**\n   * The preferred method of getting a tree pattern. For example, here's a\n   * sample use:\n   *\n   * ```\n   * const t = parser.expr();\n   * const p = parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\n   * const m = p.match(t);\n   * const id = m.get(\"ID\");\n   * ```\n   */ compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n        if (!lexer) {\n            if (this.tokenStream !== null) {\n                const tokenSource = this.tokenStream.tokenSource;\n                if (tokenSource instanceof $c1efbdb2cbf46748$export$6168dc8908a6c652) lexer = tokenSource;\n            }\n        }\n        if (!lexer) throw new Error(\"Parser can't discover a lexer to use\");\n        const m2 = new $c1efbdb2cbf46748$export$d74d529f6cce9c80(lexer, this);\n        return m2.compile(pattern, patternRuleIndex);\n    }\n    /**\n   * The ATN with bypass alternatives is expensive to create so we create it\n   * lazily.\n   *\n   * @throws UnsupportedOperationException if the current parser does not\n   * implement the {@link getSerializedATN()} method.\n   */ getATNWithBypassAlts() {\n        const serializedAtn = this.serializedATN;\n        if (serializedAtn === null) throw new Error(\"The current parser does not support an ATN with bypass alternatives.\");\n        if (this.bypassAltsAtnCache !== null) return this.bypassAltsAtnCache;\n        const deserializationOptions = {\n            readOnly: false,\n            verifyATN: true,\n            generateRuleBypassTransitions: true\n        };\n        this.bypassAltsAtnCache = new $c1efbdb2cbf46748$export$8d551c119323a3a7(deserializationOptions).deserialize(serializedAtn);\n        return this.bypassAltsAtnCache;\n    }\n    /**\n   * Gets the number of syntax errors reported during parsing. This value is\n   * incremented each time {@link notifyErrorListeners} is called.\n   */ get numberOfSyntaxErrors() {\n        return this.syntaxErrors;\n    }\n    get inputStream() {\n        return this.#inputStream;\n    }\n    set inputStream(input) {\n        this.tokenStream = input;\n    }\n    get tokenStream() {\n        return this.#inputStream;\n    }\n    /** Set the token stream and reset the parser. */ set tokenStream(input) {\n        this.reset(false);\n        this.#inputStream = input;\n    }\n    /**\n   * Match needs to return the current input symbol, which gets put\n   * into the label for the associated token ref; e.g., x=ID.\n   */ getCurrentToken() {\n        return this.inputStream.LT(1);\n    }\n    notifyErrorListeners(msg, offendingToken, err) {\n        offendingToken = offendingToken ?? null;\n        err = err ?? null;\n        if (offendingToken === null) offendingToken = this.getCurrentToken();\n        this.syntaxErrors += 1;\n        const line = offendingToken.line;\n        const column = offendingToken.column;\n        this.errorListenerDispatch.syntaxError(this, offendingToken, line, column, msg, err);\n    }\n    /**\n   * Consume and return the {@link getCurrentToken current symbol}.\n   *\n   * E.g., given the following input with `A` being the current\n   * lookahead symbol, this function moves the cursor to `B` and returns\n   * `A`.\n   *\n   * ```\n   * A B\n   * ^\n   * ```\n   *\n   * If the parser is not in error recovery mode, the consumed symbol is added\n   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n   * If the parser *is* in error recovery mode, the consumed symbol is\n   * added to the parse tree using\n   * {@link ParserRuleContext//addErrorNode(Token)}, and\n   * {@link ParseTreeListener//visitErrorNode} is called on any parse\n   * listeners.\n   */ consume() {\n        const o = this.getCurrentToken();\n        if (o.type !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) this.tokenStream.consume();\n        const hasListener = this.parseListeners !== null && this.parseListeners.length > 0;\n        if (this.buildParseTrees || hasListener) {\n            let node;\n            if (this.errorHandler.inErrorRecoveryMode(this)) node = this.context.addErrorNode(this.createErrorNode(this.context, o));\n            else node = this.context.addTokenNode(o);\n            if (hasListener) this.parseListeners.forEach((listener)=>{\n                if (node instanceof $c1efbdb2cbf46748$export$d3ee467d32253151) listener.visitErrorNode(node);\n                else listener.visitTerminal(node);\n            });\n        }\n        return o;\n    }\n    addContextToParseTree() {\n        if (this.context?.parent) this.context.parent.addChild(this.context);\n    }\n    /**\n   * Always called by generated parsers upon entry to a rule. Access field\n   * {@link context} get the current context.\n   */ enterRule(localctx, state, _ruleIndex) {\n        this.state = state;\n        this.context = localctx;\n        this.context.start = this.inputStream.LT(1);\n        if (this.buildParseTrees) this.addContextToParseTree();\n        this.triggerEnterRuleEvent();\n    }\n    exitRule() {\n        if (this.matchedEOF) this.context.stop = this.inputStream.LT(1);\n        else this.context.stop = this.inputStream.LT(-1);\n        this.triggerExitRuleEvent();\n        this.state = this.context.invokingState;\n        this.context = this.context.parent;\n    }\n    enterOuterAlt(localctx, altNum) {\n        localctx.setAltNumber(altNum);\n        if (this.buildParseTrees && this.context !== localctx) {\n            if (this.context?.parent) {\n                this.context.parent.removeLastChild();\n                this.context.parent.addChild(localctx);\n            }\n        }\n        this.context = localctx;\n    }\n    /**\n   * Get the precedence level for the top-most precedence rule.\n   *\n   * @returns The precedence level for the top-most precedence rule, or -1 if\n   * the parser context is not nested within a precedence rule.\n   */ getPrecedence() {\n        if (this.precedenceStack.length === 0) return -1;\n        return this.precedenceStack[this.precedenceStack.length - 1];\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n        this.state = state;\n        this.precedenceStack.push(precedence);\n        this.context = localctx;\n        this.context.start = this.inputStream.LT(1);\n        this.triggerEnterRuleEvent();\n    }\n    /** Like {@link enterRule} but for recursive rules. */ pushNewRecursionContext(localctx, state, _ruleIndex) {\n        const previous = this.context;\n        previous.parent = localctx;\n        previous.invokingState = state;\n        previous.stop = this.inputStream.LT(-1);\n        this.context = localctx;\n        this.context.start = previous.start;\n        if (this.buildParseTrees) this.context.addChild(previous);\n        this.triggerEnterRuleEvent();\n    }\n    unrollRecursionContexts(parent) {\n        this.precedenceStack.pop();\n        this.context.stop = this.inputStream.LT(-1);\n        const retCtx = this.context;\n        const parseListeners = this.getParseListeners();\n        if (parseListeners !== null && parseListeners.length > 0) while(this.context !== parent){\n            this.triggerExitRuleEvent();\n            this.context = this.context.parent;\n        }\n        else this.context = parent;\n        retCtx.parent = parent;\n        if (this.buildParseTrees && parent !== null) parent.addChild(retCtx);\n    }\n    getInvokingContext(ruleIndex) {\n        let ctx = this.context;\n        while(ctx !== null){\n            if (ctx.ruleIndex === ruleIndex) return ctx;\n            ctx = ctx.parent;\n        }\n        return null;\n    }\n    precpred(_localctx, precedence) {\n        return precedence >= this.precedenceStack[this.precedenceStack.length - 1];\n    }\n    /**\n   * Checks whether or not `symbol` can follow the current state in the\n   * ATN. The behavior of this method is equivalent to the following, but is\n   * implemented such that the complete context-sensitive follow set does not\n   * need to be explicitly constructed.\n   *\n   * ```\n   * return getExpectedTokens().contains(symbol);\n   * ```\n   *\n   * @param symbol the symbol type to check\n   * @returns `true` if `symbol` can follow the current state in\n   * the ATN, otherwise `false`.\n   */ isExpectedToken(symbol) {\n        const atn = this.interpreter.atn;\n        let ctx = this.context;\n        const s = atn.states[this.state];\n        let following = atn.nextTokens(s);\n        if (following.contains(symbol)) return true;\n        if (!following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)) return false;\n        while(ctx !== null && ctx.invokingState >= 0 && following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON)){\n            const invokingState = atn.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = atn.nextTokens(rt.followState);\n            if (following.contains(symbol)) return true;\n            ctx = ctx.parent;\n        }\n        if (following.contains($c1efbdb2cbf46748$export$50792b0e93539fde.EPSILON) && symbol === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return true;\n        else return false;\n    }\n    /**\n   * Computes the set of input symbols which could follow the current parser\n   * state and context, as given by {@link getState} and {@link getContext},\n   * respectively.\n   *\n   * {@link ATN.getExpectedTokens ATN.getExpectedTokens(int, RuleContext)}\n   */ getExpectedTokens() {\n        return this.interpreter.atn.getExpectedTokens(this.state, this.context);\n    }\n    getExpectedTokensWithinCurrentRule() {\n        const atn = this.interpreter.atn;\n        const s = atn.states[this.state];\n        return atn.nextTokens(s);\n    }\n    /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */ getRuleIndex(ruleName) {\n        return this.getRuleIndexMap().get(ruleName) ?? -1;\n    }\n    /**\n   * @returns an array of string of the rule names in your parser instance\n   * leading up to a call to the current rule. You could override if\n   * you want more details such as the file/line info of where\n   * in the ATN a rule is invoked.\n   *\n   * this is very useful for error messages.\n   */ getRuleInvocationStack(p) {\n        p = p ?? null;\n        if (p === null) p = this.context;\n        const stack = [];\n        while(p !== null){\n            const ruleIndex = p.ruleIndex;\n            if (ruleIndex < 0) stack.push(\"n/a\");\n            else stack.push(this.ruleNames[ruleIndex]);\n            p = p.parent;\n        }\n        return stack;\n    }\n    /**\n   * For debugging and other purposes.\n   *\n   * TODO: this differs from the Java version. Change it.\n   */ getDFAStrings() {\n        return this.interpreter.decisionToDFA.toString();\n    }\n    /** For debugging and other purposes. */ dumpDFA() {\n        let seenOne = false;\n        for (const dfa of this.interpreter.decisionToDFA)if (dfa.length > 0) {\n            if (seenOne) console.log();\n            if (this.printer) {\n                this.printer.println(\"Decision \" + dfa.decision + \":\");\n                this.printer.print(dfa.toString(this.vocabulary));\n            }\n            seenOne = true;\n        }\n    }\n    getSourceName() {\n        return this.inputStream.getSourceName();\n    }\n    getParseInfo() {\n        const interp = this.interpreter;\n        if (interp instanceof $c1efbdb2cbf46748$export$82d303abae5db5e0) return new $c1efbdb2cbf46748$export$3d86ef9f5652e0c2(interp);\n        return void 0;\n    }\n    setProfile(profile) {\n        const interp = this.interpreter;\n        const saveMode = interp.predictionMode;\n        if (profile) {\n            if (!(interp instanceof $c1efbdb2cbf46748$export$82d303abae5db5e0)) this.interpreter = new $c1efbdb2cbf46748$export$82d303abae5db5e0(this);\n        } else if (interp instanceof $c1efbdb2cbf46748$export$82d303abae5db5e0) {\n            const sharedContextCache = interp.sharedContextCache;\n            if (sharedContextCache) {\n                const sim = new $c1efbdb2cbf46748$export$7baac15c7bd92e00(this, this.atn, interp.decisionToDFA, sharedContextCache);\n                this.interpreter = sim;\n            }\n        }\n        this.interpreter.predictionMode = saveMode;\n    }\n    /**\n   * During a parse is sometimes useful to listen in on the rule entry and exit\n   * events as well as token matches. this is for quick and dirty debugging.\n   */ setTrace(trace) {\n        if (!trace) {\n            this.removeParseListener(this.tracer);\n            this.tracer = null;\n        } else {\n            if (this.tracer !== null) this.removeParseListener(this.tracer);\n            this.tracer = new $c1efbdb2cbf46748$export$4f4d5f744a81e34d(this);\n            this.addParseListener(this.tracer);\n        }\n    }\n    createTerminalNode(parent, t) {\n        return new $c1efbdb2cbf46748$export$f6a002739fa43001(t);\n    }\n    createErrorNode(parent, t) {\n        return new $c1efbdb2cbf46748$export$d3ee467d32253151(t);\n    }\n};\n// src/ParserInterpreter.ts\nvar $c1efbdb2cbf46748$export$a5c3073794ecd4fa = class extends $c1efbdb2cbf46748$export$7acfa6ed01010e37 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParserInterpreter\");\n    }\n    rootContext;\n    overrideDecisionRoot = null;\n    parentContextStack = [];\n    overrideDecisionAlt = -1;\n    overrideDecisionReached = false;\n    decisionToDFA;\n    sharedContextCache = new $c1efbdb2cbf46748$export$5afaa830ff2e40ab();\n    pushRecursionContextStates;\n    #overrideDecision = -1;\n    #overrideDecisionInputIndex = -1;\n    #grammarFileName;\n    #atn;\n    #ruleNames;\n    #vocabulary;\n    constructor(grammarFileName, vocabulary, ruleNames, atn, input){\n        super(input);\n        this.#grammarFileName = grammarFileName;\n        this.#atn = atn;\n        this.#ruleNames = ruleNames.slice(0);\n        this.#vocabulary = vocabulary;\n        this.pushRecursionContextStates = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n        for (const state of atn.states)if (state instanceof $c1efbdb2cbf46748$export$d8a6440f35eed376 && state.precedenceRuleDecision) this.pushRecursionContextStates.set(state.stateNumber);\n        this.decisionToDFA = atn.decisionToState.map((ds, i)=>{\n            return new $c1efbdb2cbf46748$export$d210bcfe90c75f0(ds, i);\n        });\n        this.interpreter = new $c1efbdb2cbf46748$export$7baac15c7bd92e00(this, atn, this.decisionToDFA, this.sharedContextCache);\n    }\n    reset() {\n        super.reset();\n        this.overrideDecisionReached = false;\n        this.overrideDecisionRoot = null;\n    }\n    get atn() {\n        return this.#atn;\n    }\n    get vocabulary() {\n        return this.#vocabulary;\n    }\n    get ruleNames() {\n        return this.#ruleNames;\n    }\n    get grammarFileName() {\n        return this.#grammarFileName;\n    }\n    get atnState() {\n        return this.#atn.states[this.state];\n    }\n    parse(startRuleIndex) {\n        const startRuleStartState = this.#atn.ruleToStartState[startRuleIndex];\n        this.rootContext = this.createInterpreterRuleContext(null, $c1efbdb2cbf46748$export$21a6260de0fddd55.INVALID_STATE_NUMBER, startRuleIndex);\n        if (startRuleStartState.isLeftRecursiveRule) this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n        else this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);\n        while(true){\n            const p = this.atnState;\n            switch(p.constructor.stateType){\n                case $c1efbdb2cbf46748$export$21a6260de0fddd55.RULE_STOP:\n                    if (this.context?.isEmpty()) {\n                        if (startRuleStartState.isLeftRecursiveRule) {\n                            const result = this.context;\n                            const parentContext = this.parentContextStack.pop();\n                            this.unrollRecursionContexts(parentContext[0]);\n                            return result;\n                        } else {\n                            this.exitRule();\n                            return this.rootContext;\n                        }\n                    }\n                    this.visitRuleStopState(p);\n                    break;\n                default:\n                    try {\n                        this.visitState(p);\n                    } catch (e) {\n                        if (e instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                            this.state = this.#atn.ruleToStopState[p.ruleIndex].stateNumber;\n                            this.errorHandler.reportError(this, e);\n                            this.recover(e);\n                        } else throw e;\n                    }\n                    break;\n            }\n        }\n    }\n    addDecisionOverride(decision, tokenIndex, forcedAlt) {\n        this.#overrideDecision = decision;\n        this.#overrideDecisionInputIndex = tokenIndex;\n        this.overrideDecisionAlt = forcedAlt;\n    }\n    get overrideDecision() {\n        return this.#overrideDecision;\n    }\n    get overrideDecisionInputIndex() {\n        return this.#overrideDecisionInputIndex;\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n        this.parentContextStack.push([\n            this.context,\n            localctx.invokingState\n        ]);\n        super.enterRecursionRule(localctx, state, ruleIndex, precedence);\n    }\n    get serializedATN() {\n        throw new Error(\"The ParserInterpreter does not support the serializedATN property.\");\n    }\n    visitState(p) {\n        let predictedAlt = 1;\n        if (p instanceof $c1efbdb2cbf46748$export$546c00a8fe1b4d1a) predictedAlt = this.visitDecisionState(p);\n        const transition = p.transitions[predictedAlt - 1];\n        switch(transition.transitionType){\n            case $c1efbdb2cbf46748$export$be58926105124dd4.EPSILON:\n                if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target.constructor.stateType === $c1efbdb2cbf46748$export$21a6260de0fddd55.LOOP_END)) {\n                    const parentContext = this.parentContextStack[this.parentContextStack.length - 1];\n                    const localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this.context.ruleIndex);\n                    this.pushNewRecursionContext(localctx, this.#atn.ruleToStartState[p.ruleIndex].stateNumber, this.context.ruleIndex);\n                }\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ATOM:\n                this.match(transition.label.minElement);\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RANGE:\n            case $c1efbdb2cbf46748$export$be58926105124dd4.SET:\n            case $c1efbdb2cbf46748$export$be58926105124dd4.NOT_SET:\n                if (!transition.matches(this.inputStream.LA(1), $c1efbdb2cbf46748$export$50792b0e93539fde.MIN_USER_TOKEN_TYPE, 65535)) this.recoverInline();\n                this.matchWildcard();\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.WILDCARD:\n                this.matchWildcard();\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.RULE:\n                const ruleStartState = transition.target;\n                const ruleIndex = ruleStartState.ruleIndex;\n                const newContext = this.createInterpreterRuleContext(this.context, p.stateNumber, ruleIndex);\n                if (ruleStartState.isLeftRecursiveRule) this.enterRecursionRule(newContext, ruleStartState.stateNumber, ruleIndex, transition.precedence);\n                else this.enterRule(newContext, transition.target.stateNumber, ruleIndex);\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PREDICATE:\n                const predicateTransition = transition;\n                if (!this.sempred(this.context, predicateTransition.ruleIndex, predicateTransition.predIndex)) throw new $c1efbdb2cbf46748$export$30ec716fb19257aa(this);\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.ACTION:\n                const actionTransition = transition;\n                this.action(this.context, actionTransition.ruleIndex, actionTransition.actionIndex);\n                break;\n            case $c1efbdb2cbf46748$export$be58926105124dd4.PRECEDENCE:\n                if (!this.precpred(this.context, transition.precedence)) {\n                    const precedence = transition.precedence;\n                    throw new $c1efbdb2cbf46748$export$30ec716fb19257aa(this, `precpred(_ctx, ${precedence})`);\n                }\n                break;\n            default:\n                throw new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n        }\n        this.state = transition.target.stateNumber;\n    }\n    visitDecisionState(p) {\n        let predictedAlt = 1;\n        if (p.transitions.length > 1) {\n            this.errorHandler.sync(this);\n            const decision = p.decision;\n            if (decision === this.#overrideDecision && this.inputStream.index === this.#overrideDecisionInputIndex && !this.overrideDecisionReached) {\n                predictedAlt = this.overrideDecisionAlt;\n                this.overrideDecisionReached = true;\n            } else predictedAlt = this.interpreter.adaptivePredict(this.inputStream, decision, this.context);\n        }\n        return predictedAlt;\n    }\n    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n        return new $c1efbdb2cbf46748$export$c0116ce21f634f83(ruleIndex, parent, invokingStateNumber);\n    }\n    visitRuleStopState(p) {\n        const ruleStartState = this.#atn.ruleToStartState[p.ruleIndex];\n        if (ruleStartState.isLeftRecursiveRule) {\n            const [parentContext, state] = this.parentContextStack.pop();\n            this.unrollRecursionContexts(parentContext);\n            this.state = state;\n        } else this.exitRule();\n        const ruleTransition = this.#atn.states[this.state].transitions[0];\n        this.state = ruleTransition.followState.stateNumber;\n    }\n    recover(e) {\n        const i = this.inputStream.index;\n        this.errorHandler.recover(this, e);\n        if (this.inputStream.index === i) {\n            const tok = e.offendingToken;\n            if (!tok) throw new Error(\"Expected exception to have an offending token\");\n            const source = tok.tokenSource;\n            const stream = source?.inputStream ?? null;\n            const sourcePair = [\n                source,\n                stream\n            ];\n            if (e instanceof $c1efbdb2cbf46748$export$d9ee09ac275d2b50) {\n                const expectedTokens = e.getExpectedTokens();\n                if (!expectedTokens) throw new Error(\"Expected the exception to provide expected tokens\");\n                let expectedTokenType = $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE;\n                if (expectedTokens.length !== 0) expectedTokenType = expectedTokens.minElement;\n                const errToken = this.getTokenFactory().create(sourcePair, expectedTokenType, tok.text, $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL, -1, -1, tok.line, tok.column);\n                this.context.addErrorNode(this.createErrorNode(this.context, errToken));\n            } else {\n                const errToken = this.getTokenFactory().create(sourcePair, $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE, tok.text, $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL, -1, -1, tok.line, tok.column);\n                this.context.addErrorNode(this.createErrorNode(this.context, errToken));\n            }\n        }\n    }\n    recoverInline() {\n        return this.errorHandler.recoverInline(this);\n    }\n};\n// src/misc/MultiMap.ts\nvar $c1efbdb2cbf46748$var$MultiMap = class extends Map {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"MultiMap\");\n    }\n    map(key, value) {\n        let elementsForKey = this.get(key);\n        if (!elementsForKey) {\n            elementsForKey = new Array();\n            this.set(key, elementsForKey);\n        }\n        elementsForKey.push(value);\n    }\n    getPairs() {\n        const pairs = new Array();\n        for (const key of this.keys()){\n            const keys = this.get(key) ?? [];\n            for (const value of keys)pairs.push([\n                key,\n                value\n            ]);\n        }\n        return pairs;\n    }\n    toString() {\n        const entries = [];\n        this.forEach((value, key)=>{\n            entries.push(`${key}=[${value.join(\", \")}]`);\n        });\n        return `{${entries.join(\", \")}}`;\n    }\n};\n// src/tree/pattern/CannotInvokeStartRuleError.ts\nvar $c1efbdb2cbf46748$export$344d2676d4b1c4b8 = class extends Error {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"CannotInvokeStartRuleError\");\n    }\n    constructor(e){\n        super();\n        this.cause = e;\n    }\n};\n// src/tree/pattern/RuleTagToken.ts\nvar $c1efbdb2cbf46748$export$5306700912446622 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RuleTagToken\");\n    }\n    /** The name of the label associated with the rule tag. */ label;\n    /** The name of the parser rule associated with this rule tag. */ ruleName;\n    /**\n   * The token type for the current token. This is the token type assigned to\n   * the bypass alternative for the rule during ATN deserialization.\n   */ bypassTokenType;\n    constructor(ruleName, bypassTokenType, label){\n        this.ruleName = ruleName;\n        this.bypassTokenType = bypassTokenType;\n        this.label = label;\n    }\n    /**\n   * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.\n   */ get channel() {\n        return $c1efbdb2cbf46748$export$50792b0e93539fde.DEFAULT_CHANNEL;\n    }\n    /**\n   * This method returns the rule tag formatted with `<` and `>`\n   * delimiters.\n   */ get text() {\n        if (this.label !== void 0) return \"<\" + this.label + \":\" + this.ruleName + \">\";\n        return \"<\" + this.ruleName + \">\";\n    }\n    /**\n   * Rule tag tokens have types assigned according to the rule bypass\n   * transitions created during ATN deserialization.\n   */ get type() {\n        return this.bypassTokenType;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns 0.\n   */ get line() {\n        return 0;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */ get column() {\n        return -1;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */ get tokenIndex() {\n        return -1;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */ get start() {\n        return -1;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */ get stop() {\n        return -1;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns `null`.\n   */ get tokenSource() {\n        return null;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} always returns `null`.\n   */ get inputStream() {\n        return null;\n    }\n    /**\n   * The implementation for {@link RuleTagToken} returns a string of the form\n   * `ruleName:bypassTokenType`.\n   */ toString() {\n        return this.ruleName + \":\" + this.bypassTokenType;\n    }\n};\n// src/tree/pattern/StartRuleDoesNotConsumeFullPatternError.ts\nvar $c1efbdb2cbf46748$export$5c9cf7350b941248 = class extends Error {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"StartRuleDoesNotConsumeFullPatternError\");\n    }\n};\n// src/tree/pattern/TagChunk.ts\nvar $c1efbdb2cbf46748$export$ca0041efa08e2ccb = class extends $c1efbdb2cbf46748$export$5a0870a55ad02f1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TagChunk\");\n    }\n    tag;\n    label;\n    constructor(...args){\n        let label;\n        let tag;\n        if (args.length === 1) tag = args[0];\n        else {\n            label = args[0];\n            tag = args[1];\n        }\n        super();\n        if (!tag) throw new Error(\"tag cannot be null or empty\");\n        this.label = label;\n        this.tag = tag;\n    }\n    /**\n   * @returns a text representation of the tag chunk. Labeled tags\n   * are returned in the form `label:tag`, and unlabeled tags are\n   * returned as just the tag name.\n   */ toString() {\n        if (this.label !== void 0) return this.label + \":\" + this.tag;\n        return this.tag;\n    }\n};\n// src/tree/pattern/TextChunk.ts\nvar $c1efbdb2cbf46748$export$f51fbcdb08f0da87 = class extends $c1efbdb2cbf46748$export$5a0870a55ad02f1a {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TextChunk\");\n    }\n    text;\n    /**\n   * Constructs a new instance of {@link TextChunk} with the specified text.\n   *\n   * @param text The text of this chunk.\n   */ constructor(text){\n        super();\n        this.text = text;\n    }\n    /**\n   * @returns the result of {@link #getText()} in single quotes.\n   */ toString() {\n        return \"'\" + this.text + \"'\";\n    }\n};\n// src/tree/pattern/TokenTagToken.ts\nvar $c1efbdb2cbf46748$export$e379f163e8412270 = class extends $c1efbdb2cbf46748$export$c9b1d0b06becfda3 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TokenTagToken\");\n    }\n    tokenName;\n    /**\n   * The name of the label associated with the rule tag, or undefined if this is an unlabeled rule tag.\n   */ label;\n    constructor(tokenName, type, label){\n        super({\n            type: type,\n            source: $c1efbdb2cbf46748$export$c9b1d0b06becfda3.EMPTY_SOURCE\n        });\n        this.tokenName = tokenName;\n        this.label = label;\n    }\n    /**\n   *\n   * @returns the token tag formatted with `<` and `>` delimiters.\n   */ get text() {\n        if (this.label !== void 0) return \"<\" + this.label + \":\" + this.tokenName + \">\";\n        return \"<\" + this.tokenName + \">\";\n    }\n    /**\n   * @returns a string of the form `tokenName:type`.\n   */ toString() {\n        return this.tokenName + \":\" + this.type;\n    }\n};\n// src/tree/pattern/ParseTreePatternMatcher.ts\nvar $c1efbdb2cbf46748$export$d74d529f6cce9c80 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ParseTreePatternMatcher\");\n    }\n    start = \"<\";\n    stop = \">\";\n    escape = \"\\\\\";\n    // e.g., \\< and \\> must escape BOTH!\n    /**\n   * This is the backing field for {@link #getLexer()}.\n   */ lexer;\n    /**\n   * This is the backing field for {@link #getParser()}.\n   */ parser;\n    /**\n   * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and\n   * {@link Parser} object. The lexer input stream is altered for tokenizing\n   * the tree patterns. The parser is used as a convenient mechanism to get\n   * the grammar name, plus token, rule names.\n   */ constructor(lexer, parser){\n        this.lexer = lexer;\n        this.parser = parser;\n    }\n    /**\n   * Set the delimiters used for marking rule and token tags within concrete\n   * syntax used by the tree pattern parser.\n   *\n   * @param start The start delimiter.\n   * @param stop The stop delimiter.\n   * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.\n   *\n   * @throws Error if `start` is `null` or empty.\n   * @throws Error if `stop` is `null` or empty.\n   */ setDelimiters(start, stop, escapeLeft) {\n        if (start === null || start.length === 0) throw new Error(\"start cannot be null or empty\");\n        if (stop === null || stop.length === 0) throw new Error(\"stop cannot be null or empty\");\n        this.start = start;\n        this.stop = stop;\n        this.escape = escapeLeft;\n    }\n    matches(...args) {\n        switch(args.length){\n            case 2:\n                {\n                    const [tree, pattern] = args;\n                    const labels = new $c1efbdb2cbf46748$var$MultiMap();\n                    const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);\n                    return mismatchedNode === null;\n                }\n            case 3:\n                {\n                    const [tree, pattern, patternRuleIndex] = args;\n                    const p = this.compile(pattern, patternRuleIndex);\n                    return this.matches(tree, p);\n                }\n            default:\n                throw new Error(\"Invalid number of arguments\");\n        }\n    }\n    match(...args) {\n        switch(args.length){\n            case 2:\n                {\n                    const [tree, pattern] = args;\n                    const labels = new $c1efbdb2cbf46748$var$MultiMap();\n                    const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);\n                    return new $c1efbdb2cbf46748$export$81a18305c772520b(tree, pattern, labels, mismatchedNode);\n                }\n            case 3:\n                {\n                    const [tree, pattern, patternRuleIndex] = args;\n                    const p = this.compile(pattern, patternRuleIndex);\n                    return this.match(tree, p);\n                }\n            default:\n                throw new Error(\"Invalid number of arguments\");\n        }\n    }\n    /**\n   * For repeated use of a tree pattern, compile it to a\n   * {@link ParseTreePattern} using this method.\n   */ compile(pattern, patternRuleIndex) {\n        const tokenList = this.tokenize(pattern);\n        const tokenSrc = new $c1efbdb2cbf46748$export$e0b3f8bf1c84aaf0(tokenList);\n        const tokens = new $c1efbdb2cbf46748$export$3b6c0b5bd4a5b0b9(tokenSrc);\n        const parserInterp = new $c1efbdb2cbf46748$export$a5c3073794ecd4fa(this.parser.grammarFileName, this.parser.vocabulary, this.parser.ruleNames, this.parser.getATNWithBypassAlts(), tokens);\n        parserInterp.removeErrorListeners();\n        let tree = null;\n        try {\n            parserInterp.errorHandler = new $c1efbdb2cbf46748$export$cabbde8fee9a839f();\n            tree = parserInterp.parse(patternRuleIndex);\n        } catch (error) {\n            if (error instanceof $c1efbdb2cbf46748$export$6b89c498ba520494) throw error.cause;\n            else if (error instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) throw error;\n            else if (error instanceof Error) throw new $c1efbdb2cbf46748$export$344d2676d4b1c4b8(error);\n            else throw error;\n        }\n        if (tokens.LA(1) !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) throw new $c1efbdb2cbf46748$export$5c9cf7350b941248();\n        return new $c1efbdb2cbf46748$export$4644540f3a71357c(this, pattern, patternRuleIndex, tree);\n    }\n    /**\n   * Used to convert the tree pattern string into a series of tokens. The\n   * input stream is reset.\n   */ getLexer() {\n        return this.lexer;\n    }\n    /**\n   * Used to collect to the grammar file name, token names, rule names for\n   * used to parse the pattern into a parse tree.\n   */ getParser() {\n        return this.parser;\n    }\n    // ---- SUPPORT CODE ----\n    tokenize(pattern) {\n        const chunks = this.split(pattern);\n        const tokens = new Array();\n        for (const chunk of chunks)if (chunk instanceof $c1efbdb2cbf46748$export$ca0041efa08e2ccb) {\n            const tagChunk = chunk;\n            const char = tagChunk.tag[0];\n            if (char === char.toUpperCase()) {\n                const ttype = this.parser.getTokenType(tagChunk.tag);\n                if (ttype === $c1efbdb2cbf46748$export$50792b0e93539fde.INVALID_TYPE) throw new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\n                const t = new $c1efbdb2cbf46748$export$e379f163e8412270(tagChunk.tag, ttype, tagChunk.label);\n                tokens.push(t);\n            } else {\n                if (char === char.toLowerCase()) {\n                    const ruleIndex = this.parser.getRuleIndex(tagChunk.tag);\n                    if (ruleIndex === -1) throw new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\n                    const ruleImaginaryTokenType = this.parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\n                    tokens.push(new $c1efbdb2cbf46748$export$5306700912446622(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\n                } else throw new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\n            }\n        } else {\n            const textChunk = chunk;\n            const input = $c1efbdb2cbf46748$export$7bbbaf2220a3f180.fromString(textChunk.text);\n            this.lexer.inputStream = input;\n            let t = this.lexer.nextToken();\n            while(t.type !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF){\n                tokens.push(t);\n                t = this.lexer.nextToken();\n            }\n        }\n        return tokens;\n    }\n    /**\n   * Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}.\n   */ split(pattern) {\n        let p = 0;\n        const n2 = pattern.length;\n        const chunks = new Array();\n        const starts = new Array();\n        const stops = new Array();\n        while(p < n2){\n            if (p === pattern.indexOf(this.escape + this.start, p)) p += this.escape.length + this.start.length;\n            else if (p === pattern.indexOf(this.escape + this.stop, p)) p += this.escape.length + this.stop.length;\n            else {\n                if (p === pattern.indexOf(this.start, p)) {\n                    starts.push(p);\n                    p += this.start.length;\n                } else if (p === pattern.indexOf(this.stop, p)) {\n                    stops.push(p);\n                    p += this.stop.length;\n                } else p++;\n            }\n        }\n        if (starts.length > stops.length) throw new Error(\"unterminated tag in pattern: \" + pattern);\n        if (starts.length < stops.length) throw new Error(\"missing start tag in pattern: \" + pattern);\n        const tagCount = starts.length;\n        for(let i = 0; i < tagCount; i++){\n            if (starts[i] >= stops[i]) throw new Error(\"tag delimiters out of order in pattern: \" + pattern);\n        }\n        if (tagCount === 0) {\n            const text = pattern.substring(0, n2);\n            chunks.push(new $c1efbdb2cbf46748$export$f51fbcdb08f0da87(text));\n        }\n        if (tagCount > 0 && starts[0] > 0) {\n            const text = pattern.substring(0, starts[0]);\n            chunks.push(new $c1efbdb2cbf46748$export$f51fbcdb08f0da87(text));\n        }\n        for(let i = 0; i < tagCount; i++){\n            const tag = pattern.substring(starts[i] + this.start.length, stops[i]);\n            let ruleOrToken = tag;\n            let label;\n            const colon = tag.indexOf(\":\");\n            if (colon >= 0) {\n                label = tag.substring(0, colon);\n                ruleOrToken = tag.substring(colon + 1, tag.length);\n            }\n            chunks.push(new $c1efbdb2cbf46748$export$ca0041efa08e2ccb(label, ruleOrToken));\n            if (i + 1 < tagCount) {\n                const text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\n                chunks.push(new $c1efbdb2cbf46748$export$f51fbcdb08f0da87(text));\n            }\n        }\n        if (tagCount > 0) {\n            const afterLastTag = stops[tagCount - 1] + this.stop.length;\n            if (afterLastTag < n2) {\n                const text = pattern.substring(afterLastTag, n2);\n                chunks.push(new $c1efbdb2cbf46748$export$f51fbcdb08f0da87(text));\n            }\n        }\n        for(let i = 0; i < chunks.length; i++){\n            const c = chunks[i];\n            if (c instanceof $c1efbdb2cbf46748$export$f51fbcdb08f0da87) {\n                const tc = c;\n                const unescaped = tc.text.replaceAll(this.escape, \"\");\n                if (unescaped.length < tc.text.length) chunks[i] = new $c1efbdb2cbf46748$export$f51fbcdb08f0da87(unescaped);\n            }\n        }\n        return chunks;\n    }\n    /**\n   * Recursively walk `tree` against `patternTree`, filling\n   * `match.`{@link ParseTreeMatch#labels labels}.\n   *\n   * @returns the first node encountered in `tree` which does not match\n   * a corresponding node in `patternTree`, or `null` if the match\n   * was successful. The specific node returned depends on the matching\n   * algorithm used by the implementation, and may be overridden.\n   */ matchImpl(tree, patternTree, labels) {\n        if (tree instanceof $c1efbdb2cbf46748$export$f6a002739fa43001 && patternTree instanceof $c1efbdb2cbf46748$export$f6a002739fa43001) {\n            const t1 = tree;\n            const t2 = patternTree;\n            let mismatchedNode;\n            if (t1.getSymbol().type === t2.getSymbol().type) {\n                if (t2.getSymbol() instanceof $c1efbdb2cbf46748$export$e379f163e8412270) {\n                    const tokenTagToken = t2.getSymbol();\n                    labels.map(tokenTagToken.tokenName, tree);\n                    if (tokenTagToken.label !== void 0) labels.map(tokenTagToken.label, tree);\n                } else {\n                    if (t1.getText() === t2.getText()) ;\n                    else if (!mismatchedNode) mismatchedNode = t1;\n                }\n            } else if (!mismatchedNode) mismatchedNode = t1;\n            return mismatchedNode;\n        }\n        if (tree instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253 && patternTree instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n            let mismatchedNode;\n            const ruleTagToken = this.getRuleTagToken(patternTree);\n            if (ruleTagToken) {\n                if (tree.ruleIndex === patternTree.ruleIndex) {\n                    labels.map(ruleTagToken.ruleName, tree);\n                    if (ruleTagToken.label) labels.map(ruleTagToken.label, tree);\n                } else if (!mismatchedNode) mismatchedNode = tree;\n                return mismatchedNode;\n            }\n            if (tree.getChildCount() !== patternTree.getChildCount()) {\n                if (!mismatchedNode) mismatchedNode = tree;\n                return mismatchedNode;\n            }\n            const n2 = tree.getChildCount();\n            for(let i = 0; i < n2; i++){\n                const childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\n                if (childMatch) return childMatch;\n            }\n            return mismatchedNode;\n        }\n        return tree;\n    }\n    /**\n   * Is `t` `(expr <expr>)` subtree?\n   */ getRuleTagToken(t) {\n        if (t instanceof $c1efbdb2cbf46748$export$1198dca6f94b6253) {\n            if (t.getChildCount() === 1 && t.getChild(0) instanceof $c1efbdb2cbf46748$export$f6a002739fa43001) {\n                const c = t.getChild(0);\n                if (c.getSymbol() instanceof $c1efbdb2cbf46748$export$5306700912446622) return c.getSymbol();\n            }\n        }\n        return void 0;\n    }\n};\n// src/DiagnosticErrorListener.ts\nvar $c1efbdb2cbf46748$export$d9c19258867070e7 = class extends $c1efbdb2cbf46748$export$2746258315f6b7a5 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"DiagnosticErrorListener\");\n    }\n    /**\n   * When `true`, only exactly known ambiguities are reported.\n   */ exactOnly;\n    constructor(exactOnly){\n        super();\n        this.exactOnly = exactOnly ?? true;\n    }\n    reportAmbiguity = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs)=>{\n        if (this.exactOnly && !exact) return;\n        const decision = this.getDecisionDescription(recognizer, dfa);\n        const conflictingAlts = this.getConflictingAlts(ambigAlts, configs);\n        const text = recognizer.tokenStream?.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(startIndex, stopIndex));\n        const message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n        recognizer.notifyErrorListeners(message, null, null);\n    }, \"reportAmbiguity\");\n    reportAttemptingFullContext = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((recognizer, dfa, startIndex, stopIndex, _conflictingAlts, _configs)=>{\n        const decision = this.getDecisionDescription(recognizer, dfa);\n        const text = recognizer.tokenStream?.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(startIndex, stopIndex));\n        const message = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n        recognizer.notifyErrorListeners(message, null, null);\n    }, \"reportAttemptingFullContext\");\n    reportContextSensitivity = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((recognizer, dfa, startIndex, stopIndex, _prediction, _configs)=>{\n        const decision = this.getDecisionDescription(recognizer, dfa);\n        const text = recognizer.tokenStream?.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(startIndex, stopIndex));\n        const message = `reportContextSensitivity d=${decision}, input='${text}'`;\n        recognizer.notifyErrorListeners(message, null, null);\n    }, \"reportContextSensitivity\");\n    getDecisionDescription = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((recognizer, dfa)=>{\n        const decision = dfa.decision;\n        const ruleIndex = dfa.atnStartState.ruleIndex;\n        const ruleNames = recognizer.ruleNames;\n        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) return decision.toString();\n        const ruleName = ruleNames[ruleIndex];\n        if (ruleName.length === 0) return decision.toString();\n        return `${decision} (${ruleName})`;\n    }, \"getDecisionDescription\");\n    /**\n   * Computes the set of conflicting or ambiguous alternatives from a\n   * configuration set, if that information was not already provided by the\n   * parser.\n   *\n   * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n   * reported by the parser.\n   * @param configs The conflicting or ambiguous configuration set.\n   * @returns Returns `reportedAlts` if it is not `null`, otherwise\n   * returns the set of alternatives represented in `configs`.\n   */ getConflictingAlts = /* @__PURE__ */ $c1efbdb2cbf46748$var$__name((reportedAlts, configs)=>{\n        if (reportedAlts) return reportedAlts;\n        const result = new $c1efbdb2cbf46748$export$33dc8f3f7b9e35df();\n        for(let i = 0; i < configs.configs.length; i++)result.set(configs.configs[i].alt);\n        return result;\n    }, \"getConflictingAlts\");\n};\n// src/LexerInterpreter.ts\nvar $c1efbdb2cbf46748$export$4188c7fc7e669270 = class extends $c1efbdb2cbf46748$export$6168dc8908a6c652 {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"LexerInterpreter\");\n    }\n    decisionToDFA;\n    sharedContextCache = new $c1efbdb2cbf46748$export$5afaa830ff2e40ab();\n    #grammarFileName;\n    #atn;\n    #ruleNames;\n    #channelNames;\n    #modeNames;\n    #vocabulary;\n    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input){\n        super(input);\n        if (atn.grammarType !== $c1efbdb2cbf46748$export$ffe90c5f202db011.LEXER) throw new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\n        this.#grammarFileName = grammarFileName;\n        this.#atn = atn;\n        this.#ruleNames = ruleNames.slice(0);\n        this.#channelNames = channelNames.slice(0);\n        this.#modeNames = modeNames.slice(0);\n        this.#vocabulary = vocabulary;\n        this.decisionToDFA = atn.decisionToState.map((ds, i)=>{\n            return new $c1efbdb2cbf46748$export$d210bcfe90c75f0(ds, i);\n        });\n        this.interpreter = new $c1efbdb2cbf46748$export$e2b3d84d700fff0a(this, atn, this.decisionToDFA, this.sharedContextCache);\n    }\n    get atn() {\n        return this.#atn;\n    }\n    get grammarFileName() {\n        return this.#grammarFileName;\n    }\n    get ruleNames() {\n        return this.#ruleNames;\n    }\n    get channelNames() {\n        return this.#channelNames;\n    }\n    get modeNames() {\n        return this.#modeNames;\n    }\n    get vocabulary() {\n        return this.#vocabulary;\n    }\n    get serializedATN() {\n        throw new Error(\"The LexerInterpreter does not support the serializedATN property.\");\n    }\n};\n// src/RuntimeMetaData.ts\nvar $c1efbdb2cbf46748$export$585a7ef2031abab5 = class _RuntimeMetaData {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RuntimeMetaData\");\n    }\n    /**\n   * A compile-time constant containing the current version of the ANTLR 4\n   * runtime library.\n   *\n   * This compile-time constant value allows generated parsers and other\n   * libraries to include a literal reference to the version of the ANTLR 4\n   * runtime library the code was compiled against. At each release, we\n   * change this value.\n   *\n   * Version numbers are assumed to have the form\n   *\n   * major.minor.patch.revision-suffix,\n   *\n   * with the individual components defined as follows.\n   *\n   * - major is a required non-negative integer, and is equal to `4` for ANTLR 4.\n   * - minor is a required non-negative integer.\n   * - patch is an optional non-negative integer. When patch is omitted, the `.` (dot) appearing before it is\n   *   also omitted.\n   * - revision is an optional non-negative integer, and may only be included when patch is also included.\n   *   When revision is omitted, the `.` (dot) appearing before it is also omitted.\n   * - suffix is an optional string. When suffix is omitted, the `-` (hyphen-minus) appearing before it is also\n   *   omitted.\n   */ static VERSION = \"4.13.1\";\n    /**\n   * Gets the currently executing version of the ANTLR 4 runtime library.\n   *\n   * This method provides runtime access to the {@link VERSION} field, as\n   * opposed to directly referencing the field as a compile-time constant.\n   *\n   * @returns The currently executing version of the ANTLR 4 library\n   */ static getRuntimeVersion() {\n        return _RuntimeMetaData.VERSION;\n    }\n    /**\n   * This method provides the ability to detect mismatches between the version\n   * of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a\n   * parser was compiled against, and the version of the ANTLR runtime which\n   * is currently executing.\n   *\n   * The version check is designed to detect the following two specific\n   * scenarios.\n   *\n   * - The ANTLR Tool version used for code generation does not match the\n   * currently executing runtime version.\n   * - The ANTLR Runtime version referenced at the time a parser was\n   * compiled does not match the currently executing runtime version.\n   *\n   *\n   * Starting with ANTLR 4.3, the code generator emits a call to this method\n   * using two constants in each generated lexer and parser: a hard-coded\n   * constant indicating the version of the tool used to generate the parser\n   * and a reference to the compile-time constant {@link VERSION}. At\n   * runtime, this method is called during the initialization of the generated\n   * parser to detect mismatched versions, and notify the registered listeners\n   * prior to creating instances of the parser.\n   *\n   *\n   * This method does not perform any detection or filtering of semantic\n   * changes between tool and runtime versions. It simply checks for a\n   * version match and emits an error to stderr if a difference\n   * is detected.\n   *\n   *\n   * Note that some breaking changes between releases could result in other\n   * types of runtime exceptions, such as a {@link LinkageError}, prior to\n   * calling this method. In these cases, the underlying version mismatch will\n   * not be reported here. This method is primarily intended to\n   * notify users of potential semantic changes between releases that do not\n   * result in binary compatibility problems which would be detected by the\n   * class loader. As with semantic changes, changes that break binary\n   * compatibility between releases are mentioned in the release notes\n   * accompanying the affected release.\n   *\n   *\n   * **Additional note for target developers:** The version check\n   * implemented by this class is designed to address specific compatibility\n   * concerns that may arise during the execution of Java applications. Other\n   * targets should consider the implementation of this method in the context\n   * of that target's known execution environment, which may or may not\n   * resemble the design provided for the Java target.\n   *\n   * @param generatingToolVersion The version of the tool used to generate a parser.\n   * This value may be null when called from user code that was not generated\n   * by, and does not reference, the ANTLR 4 Tool itself.\n   * @param compileTimeVersion The version of the runtime the parser was\n   * compiled against. This should always be passed using a direct reference\n   * to {@link VERSION}.\n   */ static checkVersion(generatingToolVersion, compileTimeVersion) {\n        const runtimeVersion = _RuntimeMetaData.VERSION;\n        let runtimeConflictsWithGeneratingTool = false;\n        let runtimeConflictsWithCompileTimeTool = false;\n        runtimeConflictsWithGeneratingTool = runtimeVersion !== generatingToolVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(generatingToolVersion);\n        runtimeConflictsWithCompileTimeTool = runtimeVersion !== compileTimeVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(compileTimeVersion);\n        if (runtimeConflictsWithGeneratingTool) console.error(`ANTLR Tool version ${generatingToolVersion} used for code generation does not match the current runtime version ${runtimeVersion}`);\n        if (runtimeConflictsWithCompileTimeTool) console.error(`ANTLR Runtime version ${compileTimeVersion} used for parser compilation does not match the current runtime version ${runtimeVersion}`);\n    }\n    /**\n   * Gets the major and minor version numbers from a version string. For\n   * details about the syntax of the input `version`.\n   * E.g., from x.y.z return x.y.\n   *\n   * @param version The complete version string.\n   * @returns A string of the form *major*.*minor* containing\n   * only the major and minor components of the version string.\n   */ static getMajorMinorVersion(version) {\n        const firstDot = version.indexOf(\".\");\n        const secondDot = firstDot >= 0 ? version.indexOf(\".\", firstDot + 1) : -1;\n        const firstDash = version.indexOf(\"-\");\n        let referenceLength = version.length;\n        if (secondDot >= 0) referenceLength = Math.min(referenceLength, secondDot);\n        if (firstDash >= 0) referenceLength = Math.min(referenceLength, firstDash);\n        return version.substring(0, referenceLength);\n    }\n};\n// src/TokenStreamRewriter.ts\nvar $c1efbdb2cbf46748$export$ba2374957bcb952c = class _TokenStreamRewriter {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"TokenStreamRewriter\");\n    }\n    static DEFAULT_PROGRAM_NAME = \"default\";\n    static PROGRAM_INIT_SIZE = 100;\n    static MIN_TOKEN_INDEX = 0;\n    /** Our source stream */ tokens;\n    /**\n   * You may have multiple, named streams of rewrite operations.\n   *  I'm calling these things \"programs.\"\n   *  Maps String (name) -> rewrite (List)\n   */ programs = /* @__PURE__ */ new Map();\n    /** Map String (program name) -> Integer index */ lastRewriteTokenIndexes;\n    /**\n   * @param tokens The token stream to modify\n   */ constructor(tokens){\n        this.tokens = tokens;\n    }\n    getTokenStream() {\n        return this.tokens;\n    }\n    /**\n   * Insert the supplied text after the specified token (or token index)\n   */ insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let index;\n        if (typeof tokenOrIndex === \"number\") index = tokenOrIndex;\n        else index = tokenOrIndex.tokenIndex;\n        const rewrites = this.getProgram(programName);\n        const op = new $c1efbdb2cbf46748$var$InsertAfterOp(this.tokens, index, rewrites.length, text);\n        rewrites.push(op);\n    }\n    /**\n   * Insert the supplied text before the specified token (or token index)\n   */ insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let index;\n        if (typeof tokenOrIndex === \"number\") index = tokenOrIndex;\n        else index = tokenOrIndex.tokenIndex;\n        const rewrites = this.getProgram(programName);\n        const op = new $c1efbdb2cbf46748$var$InsertBeforeOp(this.tokens, index, rewrites.length, text);\n        rewrites.push(op);\n    }\n    /**\n   * Replace the specified token with the supplied text\n   */ replaceSingle(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        this.replace(tokenOrIndex, tokenOrIndex, text, programName);\n    }\n    /**\n   * Replace the specified range of tokens with the supplied text.\n   */ replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        if (typeof from !== \"number\") from = from.tokenIndex;\n        if (typeof to !== \"number\") to = to.tokenIndex;\n        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n        const rewrites = this.getProgram(programName);\n        const op = new $c1efbdb2cbf46748$var$ReplaceOp(this.tokens, from, to, rewrites.length, text);\n        rewrites.push(op);\n    }\n    /**\n   * Delete the specified range of tokens\n   */ delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        if (to == null) to = from;\n        this.replace(from, to, null, programName);\n    }\n    getProgram(name) {\n        let is = this.programs.get(name);\n        if (is == null) is = this.initializeProgram(name);\n        return is;\n    }\n    initializeProgram(name) {\n        const is = [];\n        this.programs.set(name, is);\n        return is;\n    }\n    /**\n   * @returns the text from the original tokens altered per the instructions given to this rewriter\n   */ getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let interval;\n        if (intervalOrProgram instanceof $c1efbdb2cbf46748$export$e659c2681d58d45b) interval = intervalOrProgram;\n        else interval = new $c1efbdb2cbf46748$export$e659c2681d58d45b(0, this.tokens.size - 1);\n        if (typeof intervalOrProgram === \"string\") programName = intervalOrProgram;\n        const rewrites = this.programs.get(programName);\n        let start = interval.start;\n        let stop = interval.stop;\n        if (stop > this.tokens.size - 1) stop = this.tokens.size - 1;\n        if (start < 0) start = 0;\n        if (rewrites == null || rewrites.length === 0) return this.tokens.getTextFromInterval(new $c1efbdb2cbf46748$export$e659c2681d58d45b(start, stop));\n        const buf = [];\n        const indexToOp = this.reduceToSingleOperationPerIndex(rewrites);\n        let i = start;\n        while(i <= stop && i < this.tokens.size){\n            const op = indexToOp.get(i);\n            indexToOp.delete(i);\n            const t = this.tokens.get(i);\n            if (op == null) {\n                if (t.type !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) buf.push(String(t.text));\n                i++;\n            } else i = op.execute(buf);\n        }\n        if (stop === this.tokens.size - 1) {\n            for (const op of indexToOp.values())if (op && op.index >= this.tokens.size - 1) buf.push(String(op.text));\n        }\n        return buf.join(\"\");\n    }\n    /**\n   * @returns a map from token index to operation\n   */ reduceToSingleOperationPerIndex(rewrites) {\n        for(let i = 0; i < rewrites.length; i++){\n            const op = rewrites[i];\n            if (op == null) continue;\n            if (!(op instanceof $c1efbdb2cbf46748$var$ReplaceOp)) continue;\n            const rop = op;\n            const inserts = this.getKindOfOps(rewrites, $c1efbdb2cbf46748$var$InsertBeforeOp, i);\n            for (const iop of inserts){\n                if (iop.index === rop.index) {\n                    rewrites[iop.instructionIndex] = null;\n                    rop.text = String(iop.text) + (rop.text != null ? rop.text.toString() : \"\");\n                } else if (iop.index > rop.index && iop.index <= rop.lastIndex) rewrites[iop.instructionIndex] = null;\n            }\n            const prevReplaces = this.getKindOfOps(rewrites, $c1efbdb2cbf46748$var$ReplaceOp, i);\n            for (const prevRop of prevReplaces){\n                if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n                    rewrites[prevRop.instructionIndex] = null;\n                    continue;\n                }\n                const disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n                if (prevRop.text == null && rop.text == null && !disjoint) {\n                    rewrites[prevRop.instructionIndex] = null;\n                    rop.index = Math.min(prevRop.index, rop.index);\n                    rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n                } else if (!disjoint) throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n            }\n        }\n        for(let i = 0; i < rewrites.length; i++){\n            const op = rewrites[i];\n            if (op == null) continue;\n            if (!(op instanceof $c1efbdb2cbf46748$var$InsertBeforeOp)) continue;\n            const iop = op;\n            const prevInserts = this.getKindOfOps(rewrites, $c1efbdb2cbf46748$var$InsertBeforeOp, i);\n            for (const prevIop of prevInserts)if (prevIop.index === iop.index) {\n                if (prevIop instanceof $c1efbdb2cbf46748$var$InsertAfterOp) {\n                    iop.text = this.catOpText(prevIop.text, iop.text);\n                    rewrites[prevIop.instructionIndex] = null;\n                } else if (prevIop instanceof $c1efbdb2cbf46748$var$InsertBeforeOp) {\n                    iop.text = this.catOpText(iop.text, prevIop.text);\n                    rewrites[prevIop.instructionIndex] = null;\n                }\n            }\n            const prevReplaces = this.getKindOfOps(rewrites, $c1efbdb2cbf46748$var$ReplaceOp, i);\n            for (const rop of prevReplaces){\n                if (iop.index === rop.index) {\n                    rop.text = this.catOpText(iop.text, rop.text);\n                    rewrites[i] = null;\n                    continue;\n                }\n                if (iop.index >= rop.index && iop.index <= rop.lastIndex) throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n            }\n        }\n        const m2 = /* @__PURE__ */ new Map();\n        for (const op of rewrites){\n            if (op == null) continue;\n            if (m2.get(op.index) != null) throw new Error(\"should only be one op per index\");\n            m2.set(op.index, op);\n        }\n        return m2;\n    }\n    catOpText(a, b) {\n        let x = \"\";\n        let y = \"\";\n        if (a != null) x = a.toString();\n        if (b != null) y = b.toString();\n        return x + y;\n    }\n    /**\n   * Get all operations before an index of a particular kind\n   */ getKindOfOps(rewrites, kind, before) {\n        return rewrites.slice(0, before).filter((op)=>{\n            return op && op instanceof kind;\n        });\n    }\n};\nvar $c1efbdb2cbf46748$var$RewriteOperation = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"RewriteOperation\");\n    }\n    /** What index into rewrites List are we? */ instructionIndex;\n    /** Token buffer index. */ index;\n    text;\n    tokens;\n    constructor(tokens, index, instructionIndex, text){\n        this.tokens = tokens;\n        this.instructionIndex = instructionIndex;\n        this.index = index;\n        this.text = text === void 0 ? \"\" : text;\n    }\n    execute(_buf) {\n        return this.index;\n    }\n    toString() {\n        return \"<RewriteOperation@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n    }\n};\nvar $c1efbdb2cbf46748$var$InsertBeforeOp = class extends $c1efbdb2cbf46748$var$RewriteOperation {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"InsertBeforeOp\");\n    }\n    constructor(tokens, index, instructionIndex, text){\n        super(tokens, index, instructionIndex, text);\n    }\n    /**\n   * @returns the index of the next token to operate on\n   */ execute(buf) {\n        if (this.text) buf.push(this.text.toString());\n        if (this.tokens.get(this.index).type !== $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) buf.push(String(this.tokens.get(this.index).text));\n        return this.index + 1;\n    }\n    toString() {\n        return \"<InsertBeforeOp@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n    }\n};\nvar $c1efbdb2cbf46748$var$InsertAfterOp = class extends $c1efbdb2cbf46748$var$InsertBeforeOp {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"InsertAfterOp\");\n    }\n    constructor(tokens, index, instructionIndex, text){\n        super(tokens, index + 1, instructionIndex, text);\n    }\n    toString() {\n        return \"<InsertAfterOp@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n    }\n};\nvar $c1efbdb2cbf46748$var$ReplaceOp = class extends $c1efbdb2cbf46748$var$RewriteOperation {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"ReplaceOp\");\n    }\n    lastIndex;\n    constructor(tokens, from, to, instructionIndex, text){\n        super(tokens, from, instructionIndex, text);\n        this.lastIndex = to;\n    }\n    /**\n   * @returns the index of the next token to operate on\n   */ execute(buf) {\n        if (this.text) buf.push(this.text.toString());\n        return this.lastIndex + 1;\n    }\n    toString() {\n        if (this.text == null) return \"<DeleteOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + \">\";\n        return \"<ReplaceOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + ':\"' + this.text + '\">';\n    }\n};\n// src/UnbufferedTokenStream.ts\nvar $c1efbdb2cbf46748$export$4fca6276427d5366 = class {\n    static{\n        $c1efbdb2cbf46748$var$__name(this, \"UnbufferedTokenStream\");\n    }\n    tokenSource;\n    /**\n   * A moving window buffer of the data being scanned. While there's a marker,\n   * we keep adding to buffer. Otherwise, {@link #consume consume()} resets so\n   * we start filling at index 0 again.\n   */ tokens;\n    /**\n   * The number of tokens currently in {@link #tokens tokens}.\n   *\n   * This is not the buffer capacity, that's `tokens.length`.\n   */ n;\n    /**\n   * 0..n-1 index into {@link #tokens tokens} of next token.\n   *\n   * The `LT(1)` token is `tokens[p]`. If `p == n`, we are\n   * out of buffered tokens.\n   */ p = 0;\n    /**\n   * Count up with {@link #mark mark()} and down with\n   * {@link #release release()}. When we `release()` the last mark,\n   * `numMarkers` reaches 0 and we reset the buffer. Copy\n   * `tokens[p]..tokens[n-1]` to `tokens[0]..tokens[(n-1)-p]`.\n   */ numMarkers = 0;\n    /**\n   * This is the `LT(-1)` token for the current position.\n   */ lastToken;\n    /**\n   * When `numMarkers > 0`, this is the `LT(-1)` token for the\n   * first token in {@link #tokens}. Otherwise, this is `null`.\n   */ lastTokenBufferStart;\n    /**\n   * Absolute token index. It's the index of the token about to be read via\n   * `LT(1)`. Goes from 0 to the number of tokens in the entire stream,\n   * although the stream size is unknown before the end is reached.\n   *\n   * This value is used to set the token indexes if the stream provides tokens\n   * that implement {@link WritableToken}.\n   */ currentTokenIndex = 0;\n    constructor(tokenSource, bufferSize){\n        this.tokenSource = tokenSource;\n        bufferSize = bufferSize ?? 256;\n        this.tokens = new Array(bufferSize);\n        this.n = 0;\n        this.fill(1);\n    }\n    get(i) {\n        const bufferStartIndex = this.getBufferStartIndex();\n        if (i < bufferStartIndex || i >= bufferStartIndex + this.n) throw new Error(\"get(\" + i + \") outside buffer: \" + bufferStartIndex + \"..\" + (bufferStartIndex + this.n));\n        return this.tokens[i - bufferStartIndex];\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LT(i) {\n        if (i === -1) return this.lastToken;\n        this.sync(i);\n        const index = this.p + i - 1;\n        if (index < 0) throw new Error(\"LT(\" + i + \") gives negative index\");\n        if (index >= this.n) return this.tokens[this.n - 1];\n        return this.tokens[index];\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LA(i) {\n        return this.LT(i).type;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromContext(ctx) {\n        return this.getTextFromInterval(ctx.getSourceInterval());\n    }\n    getTextFromInterval(interval) {\n        const bufferStartIndex = this.getBufferStartIndex();\n        const bufferStopIndex = bufferStartIndex + this.tokens.length - 1;\n        const start = interval.start;\n        const stop = interval.stop;\n        if (start < bufferStartIndex || stop > bufferStopIndex) throw new Error(\"interval \" + interval + \" not in token buffer window: \" + bufferStartIndex + \"..\" + bufferStopIndex);\n        const a = start - bufferStartIndex;\n        const b = stop - bufferStartIndex;\n        let result = \"\";\n        for(let i = a; i <= b; i++){\n            const t = this.tokens[i];\n            result += t.text;\n        }\n        return result;\n    }\n    getTextFromRange(start, stop) {\n        return this.getTextFromInterval($c1efbdb2cbf46748$export$e659c2681d58d45b.of(start.tokenIndex, stop.tokenIndex));\n    }\n    consume() {\n        if (this.LA(1) === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) throw new Error(\"cannot consume EOF\");\n        this.lastToken = this.tokens[this.p];\n        if (this.p === this.n - 1 && this.numMarkers === 0) {\n            this.n = 0;\n            this.p = -1;\n            this.lastTokenBufferStart = this.lastToken;\n        }\n        this.p++;\n        this.currentTokenIndex++;\n        this.sync(1);\n    }\n    /**\n   * Return a marker that we can release later.\n   *\n   * The specific marker value used for this class allows for some level of\n   * protection against misuse where `seek()` is called on a mark or\n   * `release()` is called in the wrong order.\n   */ mark() {\n        if (this.numMarkers === 0) this.lastTokenBufferStart = this.lastToken;\n        const mark = -this.numMarkers - 1;\n        this.numMarkers++;\n        return mark;\n    }\n    release(marker) {\n        const expectedMark = -this.numMarkers;\n        if (marker !== expectedMark) throw new Error(\"release() called with an invalid marker.\");\n        this.numMarkers--;\n        if (this.numMarkers === 0) {\n            if (this.p > 0) {\n                this.tokens.copyWithin(0, this.p, this.n);\n                this.n = this.n - this.p;\n                this.p = 0;\n            }\n            this.lastTokenBufferStart = this.lastToken;\n        }\n    }\n    get index() {\n        return this.currentTokenIndex;\n    }\n    seek(index) {\n        if (index === this.currentTokenIndex) return;\n        if (index > this.currentTokenIndex) {\n            this.sync(index - this.currentTokenIndex);\n            index = Math.min(index, this.getBufferStartIndex() + this.n - 1);\n        }\n        const bufferStartIndex = this.getBufferStartIndex();\n        const i = index - bufferStartIndex;\n        if (i < 0) throw new Error(\"cannot seek to negative index \" + index);\n        else {\n            if (i >= this.n) throw new Error(\"seek to index outside buffer: \" + index + \" not in \" + bufferStartIndex + \"..\" + (bufferStartIndex + this.n));\n        }\n        this.p = i;\n        this.currentTokenIndex = index;\n        if (this.p === 0) this.lastToken = this.lastTokenBufferStart;\n        else this.lastToken = this.tokens[this.p - 1];\n    }\n    get size() {\n        throw new Error(\"Unbuffered stream cannot know its size\");\n    }\n    getSourceName() {\n        return this.tokenSource.sourceName;\n    }\n    setLine(line) {\n        this.tokenSource.line = line;\n    }\n    setColumn(column) {\n        this.tokenSource.column = column;\n    }\n    /**\n   * Make sure we have 'need' elements from current position {@link #p p}. Last valid\n   * `p` index is `tokens.length-1`.  `p+need-1` is the tokens index 'need' elements\n   * ahead.  If we need 1 element, `(p+1-1)==p` must be less than `tokens.length`.\n   */ sync(want) {\n        const need = this.p + want - 1 - this.n + 1;\n        if (need > 0) this.fill(need);\n    }\n    /**\n   * Add `n` elements to the buffer. Returns the number of tokens\n   * actually added to the buffer. If the return value is less than `n`,\n   * then EOF was reached before `n` tokens could be added.\n   */ fill(n2) {\n        for(let i = 0; i < n2; i++){\n            if (this.n > 0 && this.tokens[this.n - 1].type === $c1efbdb2cbf46748$export$50792b0e93539fde.EOF) return i;\n            const t = this.tokenSource.nextToken();\n            this.add(t);\n        }\n        return n2;\n    }\n    add(t) {\n        if (this.n >= this.tokens.length) this.tokens.length = this.tokens.length * 2;\n        if ($c1efbdb2cbf46748$export$fc9236fcd9399ac6(t)) t.setTokenIndex(this.getBufferStartIndex() + this.n);\n        this.tokens[this.n++] = t;\n    }\n    getBufferStartIndex() {\n        return this.currentTokenIndex - this.p;\n    }\n};\n\n\n// Generated from c:/Users/minip/source/repos/ahk2-antlr4-demo/src/grammar/MainGrammar.g4 by ANTLR 4.13.1\n\nclass $abcf7a628702571d$export$93e3b1450253a6f7 extends $c1efbdb2cbf46748$export$6168dc8908a6c652 {\n    static{\n        this.AND = 1;\n    }\n    static{\n        this.OR = 2;\n    }\n    static{\n        this.NOT = 3;\n    }\n    static{\n        this.EQ = 4;\n    }\n    static{\n        this.COMMA = 5;\n    }\n    static{\n        this.SEMI = 6;\n    }\n    static{\n        this.LPAREN = 7;\n    }\n    static{\n        this.RPAREN = 8;\n    }\n    static{\n        this.LCURLY = 9;\n    }\n    static{\n        this.RCURLY = 10;\n    }\n    static{\n        this.INT = 11;\n    }\n    static{\n        this.ID = 12;\n    }\n    static{\n        this.WS = 13;\n    }\n    static{\n        this.channelNames = [\n            \"DEFAULT_TOKEN_CHANNEL\",\n            \"HIDDEN\"\n        ];\n    }\n    static{\n        this.literalNames = [\n            null,\n            \"'and'\",\n            \"'or'\",\n            \"'not'\",\n            \"'='\",\n            \"','\",\n            \"';'\",\n            \"'('\",\n            \"')'\",\n            \"'{'\",\n            \"'}'\"\n        ];\n    }\n    static{\n        this.symbolicNames = [\n            null,\n            \"AND\",\n            \"OR\",\n            \"NOT\",\n            \"EQ\",\n            \"COMMA\",\n            \"SEMI\",\n            \"LPAREN\",\n            \"RPAREN\",\n            \"LCURLY\",\n            \"RCURLY\",\n            \"INT\",\n            \"ID\",\n            \"WS\"\n        ];\n    }\n    static{\n        this.modeNames = [\n            \"DEFAULT_MODE\"\n        ];\n    }\n    static{\n        this.ruleNames = [\n            \"AND\",\n            \"OR\",\n            \"NOT\",\n            \"EQ\",\n            \"COMMA\",\n            \"SEMI\",\n            \"LPAREN\",\n            \"RPAREN\",\n            \"LCURLY\",\n            \"RCURLY\",\n            \"INT\",\n            \"ID\",\n            \"WS\"\n        ];\n    }\n    constructor(input){\n        super(input);\n        this.interpreter = new $c1efbdb2cbf46748$export$e2b3d84d700fff0a(this, $abcf7a628702571d$export$93e3b1450253a6f7._ATN, $abcf7a628702571d$export$93e3b1450253a6f7.decisionsToDFA, new $c1efbdb2cbf46748$export$5afaa830ff2e40ab());\n    }\n    get grammarFileName() {\n        return \"MainGrammar.g4\";\n    }\n    get literalNames() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.literalNames;\n    }\n    get symbolicNames() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.symbolicNames;\n    }\n    get ruleNames() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.ruleNames;\n    }\n    get serializedATN() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7._serializedATN;\n    }\n    get channelNames() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.channelNames;\n    }\n    get modeNames() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.modeNames;\n    }\n    static{\n        this._serializedATN = [\n            4,\n            0,\n            13,\n            71,\n            6,\n            -1,\n            2,\n            0,\n            7,\n            0,\n            2,\n            1,\n            7,\n            1,\n            2,\n            2,\n            7,\n            2,\n            2,\n            3,\n            7,\n            3,\n            2,\n            4,\n            7,\n            4,\n            2,\n            5,\n            7,\n            5,\n            2,\n            6,\n            7,\n            6,\n            2,\n            7,\n            7,\n            7,\n            2,\n            8,\n            7,\n            8,\n            2,\n            9,\n            7,\n            9,\n            2,\n            10,\n            7,\n            10,\n            2,\n            11,\n            7,\n            11,\n            2,\n            12,\n            7,\n            12,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            3,\n            1,\n            3,\n            1,\n            4,\n            1,\n            4,\n            1,\n            5,\n            1,\n            5,\n            1,\n            6,\n            1,\n            6,\n            1,\n            7,\n            1,\n            7,\n            1,\n            8,\n            1,\n            8,\n            1,\n            9,\n            1,\n            9,\n            1,\n            10,\n            4,\n            10,\n            54,\n            8,\n            10,\n            11,\n            10,\n            12,\n            10,\n            55,\n            1,\n            11,\n            1,\n            11,\n            5,\n            11,\n            60,\n            8,\n            11,\n            10,\n            11,\n            12,\n            11,\n            63,\n            9,\n            11,\n            1,\n            12,\n            4,\n            12,\n            66,\n            8,\n            12,\n            11,\n            12,\n            12,\n            12,\n            67,\n            1,\n            12,\n            1,\n            12,\n            0,\n            0,\n            13,\n            1,\n            1,\n            3,\n            2,\n            5,\n            3,\n            7,\n            4,\n            9,\n            5,\n            11,\n            6,\n            13,\n            7,\n            15,\n            8,\n            17,\n            9,\n            19,\n            10,\n            21,\n            11,\n            23,\n            12,\n            25,\n            13,\n            1,\n            0,\n            4,\n            1,\n            0,\n            48,\n            57,\n            3,\n            0,\n            65,\n            90,\n            95,\n            95,\n            97,\n            122,\n            4,\n            0,\n            48,\n            57,\n            65,\n            90,\n            95,\n            95,\n            97,\n            122,\n            3,\n            0,\n            9,\n            10,\n            12,\n            13,\n            32,\n            32,\n            73,\n            0,\n            1,\n            1,\n            0,\n            0,\n            0,\n            0,\n            3,\n            1,\n            0,\n            0,\n            0,\n            0,\n            5,\n            1,\n            0,\n            0,\n            0,\n            0,\n            7,\n            1,\n            0,\n            0,\n            0,\n            0,\n            9,\n            1,\n            0,\n            0,\n            0,\n            0,\n            11,\n            1,\n            0,\n            0,\n            0,\n            0,\n            13,\n            1,\n            0,\n            0,\n            0,\n            0,\n            15,\n            1,\n            0,\n            0,\n            0,\n            0,\n            17,\n            1,\n            0,\n            0,\n            0,\n            0,\n            19,\n            1,\n            0,\n            0,\n            0,\n            0,\n            21,\n            1,\n            0,\n            0,\n            0,\n            0,\n            23,\n            1,\n            0,\n            0,\n            0,\n            0,\n            25,\n            1,\n            0,\n            0,\n            0,\n            1,\n            27,\n            1,\n            0,\n            0,\n            0,\n            3,\n            31,\n            1,\n            0,\n            0,\n            0,\n            5,\n            34,\n            1,\n            0,\n            0,\n            0,\n            7,\n            38,\n            1,\n            0,\n            0,\n            0,\n            9,\n            40,\n            1,\n            0,\n            0,\n            0,\n            11,\n            42,\n            1,\n            0,\n            0,\n            0,\n            13,\n            44,\n            1,\n            0,\n            0,\n            0,\n            15,\n            46,\n            1,\n            0,\n            0,\n            0,\n            17,\n            48,\n            1,\n            0,\n            0,\n            0,\n            19,\n            50,\n            1,\n            0,\n            0,\n            0,\n            21,\n            53,\n            1,\n            0,\n            0,\n            0,\n            23,\n            57,\n            1,\n            0,\n            0,\n            0,\n            25,\n            65,\n            1,\n            0,\n            0,\n            0,\n            27,\n            28,\n            5,\n            97,\n            0,\n            0,\n            28,\n            29,\n            5,\n            110,\n            0,\n            0,\n            29,\n            30,\n            5,\n            100,\n            0,\n            0,\n            30,\n            2,\n            1,\n            0,\n            0,\n            0,\n            31,\n            32,\n            5,\n            111,\n            0,\n            0,\n            32,\n            33,\n            5,\n            114,\n            0,\n            0,\n            33,\n            4,\n            1,\n            0,\n            0,\n            0,\n            34,\n            35,\n            5,\n            110,\n            0,\n            0,\n            35,\n            36,\n            5,\n            111,\n            0,\n            0,\n            36,\n            37,\n            5,\n            116,\n            0,\n            0,\n            37,\n            6,\n            1,\n            0,\n            0,\n            0,\n            38,\n            39,\n            5,\n            61,\n            0,\n            0,\n            39,\n            8,\n            1,\n            0,\n            0,\n            0,\n            40,\n            41,\n            5,\n            44,\n            0,\n            0,\n            41,\n            10,\n            1,\n            0,\n            0,\n            0,\n            42,\n            43,\n            5,\n            59,\n            0,\n            0,\n            43,\n            12,\n            1,\n            0,\n            0,\n            0,\n            44,\n            45,\n            5,\n            40,\n            0,\n            0,\n            45,\n            14,\n            1,\n            0,\n            0,\n            0,\n            46,\n            47,\n            5,\n            41,\n            0,\n            0,\n            47,\n            16,\n            1,\n            0,\n            0,\n            0,\n            48,\n            49,\n            5,\n            123,\n            0,\n            0,\n            49,\n            18,\n            1,\n            0,\n            0,\n            0,\n            50,\n            51,\n            5,\n            125,\n            0,\n            0,\n            51,\n            20,\n            1,\n            0,\n            0,\n            0,\n            52,\n            54,\n            7,\n            0,\n            0,\n            0,\n            53,\n            52,\n            1,\n            0,\n            0,\n            0,\n            54,\n            55,\n            1,\n            0,\n            0,\n            0,\n            55,\n            53,\n            1,\n            0,\n            0,\n            0,\n            55,\n            56,\n            1,\n            0,\n            0,\n            0,\n            56,\n            22,\n            1,\n            0,\n            0,\n            0,\n            57,\n            61,\n            7,\n            1,\n            0,\n            0,\n            58,\n            60,\n            7,\n            2,\n            0,\n            0,\n            59,\n            58,\n            1,\n            0,\n            0,\n            0,\n            60,\n            63,\n            1,\n            0,\n            0,\n            0,\n            61,\n            59,\n            1,\n            0,\n            0,\n            0,\n            61,\n            62,\n            1,\n            0,\n            0,\n            0,\n            62,\n            24,\n            1,\n            0,\n            0,\n            0,\n            63,\n            61,\n            1,\n            0,\n            0,\n            0,\n            64,\n            66,\n            7,\n            3,\n            0,\n            0,\n            65,\n            64,\n            1,\n            0,\n            0,\n            0,\n            66,\n            67,\n            1,\n            0,\n            0,\n            0,\n            67,\n            65,\n            1,\n            0,\n            0,\n            0,\n            67,\n            68,\n            1,\n            0,\n            0,\n            0,\n            68,\n            69,\n            1,\n            0,\n            0,\n            0,\n            69,\n            70,\n            6,\n            12,\n            0,\n            0,\n            70,\n            26,\n            1,\n            0,\n            0,\n            0,\n            4,\n            0,\n            55,\n            61,\n            67,\n            1,\n            6,\n            0,\n            0\n        ];\n    }\n    static get _ATN() {\n        if (!$abcf7a628702571d$export$93e3b1450253a6f7.__ATN) $abcf7a628702571d$export$93e3b1450253a6f7.__ATN = new $c1efbdb2cbf46748$export$8d551c119323a3a7().deserialize($abcf7a628702571d$export$93e3b1450253a6f7._serializedATN);\n        return $abcf7a628702571d$export$93e3b1450253a6f7.__ATN;\n    }\n    static{\n        this.vocabulary = new $c1efbdb2cbf46748$export$6fe78fc0b86aec88($abcf7a628702571d$export$93e3b1450253a6f7.literalNames, $abcf7a628702571d$export$93e3b1450253a6f7.symbolicNames, []);\n    }\n    get vocabulary() {\n        return $abcf7a628702571d$export$93e3b1450253a6f7.vocabulary;\n    }\n    static{\n        this.decisionsToDFA = $abcf7a628702571d$export$93e3b1450253a6f7._ATN.decisionToState.map((ds, index)=>new $c1efbdb2cbf46748$export$d210bcfe90c75f0(ds, index));\n    }\n}\n\n\n// Generated from c:/Users/minip/source/repos/ahk2-antlr4-demo/src/grammar/MainGrammar.g4 by ANTLR 4.13.1\n\nclass $2e334593fe001b5e$export$800110701abe823 extends $c1efbdb2cbf46748$export$7acfa6ed01010e37 {\n    static{\n        this.AND = 1;\n    }\n    static{\n        this.OR = 2;\n    }\n    static{\n        this.NOT = 3;\n    }\n    static{\n        this.EQ = 4;\n    }\n    static{\n        this.COMMA = 5;\n    }\n    static{\n        this.SEMI = 6;\n    }\n    static{\n        this.LPAREN = 7;\n    }\n    static{\n        this.RPAREN = 8;\n    }\n    static{\n        this.LCURLY = 9;\n    }\n    static{\n        this.RCURLY = 10;\n    }\n    static{\n        this.INT = 11;\n    }\n    static{\n        this.ID = 12;\n    }\n    static{\n        this.WS = 13;\n    }\n    static{\n        this.RULE_program = 0;\n    }\n    static{\n        this.RULE_stat = 1;\n    }\n    static{\n        this.RULE_def = 2;\n    }\n    static{\n        this.RULE_expr = 3;\n    }\n    static{\n        this.RULE_func = 4;\n    }\n    static{\n        this.literalNames = [\n            null,\n            \"'and'\",\n            \"'or'\",\n            \"'not'\",\n            \"'='\",\n            \"','\",\n            \"';'\",\n            \"'('\",\n            \"')'\",\n            \"'{'\",\n            \"'}'\"\n        ];\n    }\n    static{\n        this.symbolicNames = [\n            null,\n            \"AND\",\n            \"OR\",\n            \"NOT\",\n            \"EQ\",\n            \"COMMA\",\n            \"SEMI\",\n            \"LPAREN\",\n            \"RPAREN\",\n            \"LCURLY\",\n            \"RCURLY\",\n            \"INT\",\n            \"ID\",\n            \"WS\"\n        ];\n    }\n    static{\n        this.ruleNames = [\n            \"program\",\n            \"stat\",\n            \"def\",\n            \"expr\",\n            \"func\"\n        ];\n    }\n    get grammarFileName() {\n        return \"MainGrammar.g4\";\n    }\n    get literalNames() {\n        return $2e334593fe001b5e$export$800110701abe823.literalNames;\n    }\n    get symbolicNames() {\n        return $2e334593fe001b5e$export$800110701abe823.symbolicNames;\n    }\n    get ruleNames() {\n        return $2e334593fe001b5e$export$800110701abe823.ruleNames;\n    }\n    get serializedATN() {\n        return $2e334593fe001b5e$export$800110701abe823._serializedATN;\n    }\n    createFailedPredicateException(predicate, message) {\n        return new $c1efbdb2cbf46748$export$30ec716fb19257aa(this, predicate, message);\n    }\n    constructor(input){\n        super(input);\n        this.interpreter = new $c1efbdb2cbf46748$export$7baac15c7bd92e00(this, $2e334593fe001b5e$export$800110701abe823._ATN, $2e334593fe001b5e$export$800110701abe823.decisionsToDFA, new $c1efbdb2cbf46748$export$5afaa830ff2e40ab());\n    }\n    program() {\n        let localContext = new $2e334593fe001b5e$export$eb6fef7b613a504d(this.context, this.state);\n        this.enterRule(localContext, 0, $2e334593fe001b5e$export$800110701abe823.RULE_program);\n        try {\n            this.state = 16;\n            this.errorHandler.sync(this);\n            switch(this.interpreter.adaptivePredict(this.tokenStream, 0, this.context)){\n                case 1:\n                    this.enterOuterAlt(localContext, 1);\n                    this.state = 10;\n                    this.stat();\n                    this.state = 11;\n                    this.match($2e334593fe001b5e$export$800110701abe823.EOF);\n                    break;\n                case 2:\n                    this.enterOuterAlt(localContext, 2);\n                    this.state = 13;\n                    this.def();\n                    this.state = 14;\n                    this.match($2e334593fe001b5e$export$800110701abe823.EOF);\n                    break;\n            }\n        } catch (re) {\n            if (re instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                this.errorHandler.reportError(this, re);\n                this.errorHandler.recover(this, re);\n            } else throw re;\n        } finally{\n            this.exitRule();\n        }\n        return localContext;\n    }\n    stat() {\n        let localContext = new $2e334593fe001b5e$export$375382d24fd8693f(this.context, this.state);\n        this.enterRule(localContext, 2, $2e334593fe001b5e$export$800110701abe823.RULE_stat);\n        try {\n            this.state = 26;\n            this.errorHandler.sync(this);\n            switch(this.interpreter.adaptivePredict(this.tokenStream, 1, this.context)){\n                case 1:\n                    this.enterOuterAlt(localContext, 1);\n                    this.state = 18;\n                    this.match($2e334593fe001b5e$export$800110701abe823.ID);\n                    this.state = 19;\n                    this.match($2e334593fe001b5e$export$800110701abe823.EQ);\n                    this.state = 20;\n                    this.expr(0);\n                    this.state = 21;\n                    this.match($2e334593fe001b5e$export$800110701abe823.SEMI);\n                    break;\n                case 2:\n                    this.enterOuterAlt(localContext, 2);\n                    this.state = 23;\n                    this.expr(0);\n                    this.state = 24;\n                    this.match($2e334593fe001b5e$export$800110701abe823.SEMI);\n                    break;\n            }\n        } catch (re) {\n            if (re instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                this.errorHandler.reportError(this, re);\n                this.errorHandler.recover(this, re);\n            } else throw re;\n        } finally{\n            this.exitRule();\n        }\n        return localContext;\n    }\n    def() {\n        let localContext = new $2e334593fe001b5e$export$5183956a3a58a148(this.context, this.state);\n        this.enterRule(localContext, 4, $2e334593fe001b5e$export$800110701abe823.RULE_def);\n        let _la;\n        try {\n            this.enterOuterAlt(localContext, 1);\n            this.state = 28;\n            this.match($2e334593fe001b5e$export$800110701abe823.ID);\n            this.state = 29;\n            this.match($2e334593fe001b5e$export$800110701abe823.LPAREN);\n            this.state = 30;\n            this.match($2e334593fe001b5e$export$800110701abe823.ID);\n            this.state = 35;\n            this.errorHandler.sync(this);\n            _la = this.tokenStream.LA(1);\n            while(_la === 5){\n                this.state = 31;\n                this.match($2e334593fe001b5e$export$800110701abe823.COMMA);\n                this.state = 32;\n                this.match($2e334593fe001b5e$export$800110701abe823.ID);\n                this.state = 37;\n                this.errorHandler.sync(this);\n                _la = this.tokenStream.LA(1);\n            }\n            this.state = 38;\n            this.match($2e334593fe001b5e$export$800110701abe823.RPAREN);\n            this.state = 39;\n            this.match($2e334593fe001b5e$export$800110701abe823.LCURLY);\n            this.state = 43;\n            this.errorHandler.sync(this);\n            _la = this.tokenStream.LA(1);\n            while((_la & -32) === 0 && (1 << _la & 6152) !== 0){\n                this.state = 40;\n                this.stat();\n                this.state = 45;\n                this.errorHandler.sync(this);\n                _la = this.tokenStream.LA(1);\n            }\n            this.state = 46;\n            this.match($2e334593fe001b5e$export$800110701abe823.RCURLY);\n        } catch (re) {\n            if (re instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                this.errorHandler.reportError(this, re);\n                this.errorHandler.recover(this, re);\n            } else throw re;\n        } finally{\n            this.exitRule();\n        }\n        return localContext;\n    }\n    expr(_p) {\n        if (_p === undefined) _p = 0;\n        let parentContext = this.context;\n        let parentState = this.state;\n        let localContext = new $2e334593fe001b5e$export$286a3f51a71cff58(this.context, parentState);\n        let previousContext = localContext;\n        let _startState = 6;\n        this.enterRecursionRule(localContext, 6, $2e334593fe001b5e$export$800110701abe823.RULE_expr, _p);\n        try {\n            let alternative;\n            this.enterOuterAlt(localContext, 1);\n            this.state = 54;\n            this.errorHandler.sync(this);\n            switch(this.interpreter.adaptivePredict(this.tokenStream, 4, this.context)){\n                case 1:\n                    this.state = 49;\n                    this.match($2e334593fe001b5e$export$800110701abe823.ID);\n                    break;\n                case 2:\n                    this.state = 50;\n                    this.match($2e334593fe001b5e$export$800110701abe823.INT);\n                    break;\n                case 3:\n                    this.state = 51;\n                    this.func();\n                    break;\n                case 4:\n                    this.state = 52;\n                    this.match($2e334593fe001b5e$export$800110701abe823.NOT);\n                    this.state = 53;\n                    this.expr(3);\n                    break;\n            }\n            this.context.stop = this.tokenStream.LT(-1);\n            this.state = 64;\n            this.errorHandler.sync(this);\n            alternative = this.interpreter.adaptivePredict(this.tokenStream, 6, this.context);\n            while(alternative !== 2 && alternative !== $c1efbdb2cbf46748$export$ffe90c5f202db011.INVALID_ALT_NUMBER){\n                if (alternative === 1) {\n                    if (this.parseListeners != null) this.triggerExitRuleEvent();\n                    previousContext = localContext;\n                    this.state = 62;\n                    this.errorHandler.sync(this);\n                    switch(this.interpreter.adaptivePredict(this.tokenStream, 5, this.context)){\n                        case 1:\n                            localContext = new $2e334593fe001b5e$export$286a3f51a71cff58(parentContext, parentState);\n                            this.pushNewRecursionContext(localContext, _startState, $2e334593fe001b5e$export$800110701abe823.RULE_expr);\n                            this.state = 56;\n                            if (!this.precpred(this.context, 2)) throw this.createFailedPredicateException(\"this.precpred(this.context, 2)\");\n                            this.state = 57;\n                            this.match($2e334593fe001b5e$export$800110701abe823.AND);\n                            this.state = 58;\n                            this.expr(3);\n                            break;\n                        case 2:\n                            localContext = new $2e334593fe001b5e$export$286a3f51a71cff58(parentContext, parentState);\n                            this.pushNewRecursionContext(localContext, _startState, $2e334593fe001b5e$export$800110701abe823.RULE_expr);\n                            this.state = 59;\n                            if (!this.precpred(this.context, 1)) throw this.createFailedPredicateException(\"this.precpred(this.context, 1)\");\n                            this.state = 60;\n                            this.match($2e334593fe001b5e$export$800110701abe823.OR);\n                            this.state = 61;\n                            this.expr(2);\n                            break;\n                    }\n                }\n                this.state = 66;\n                this.errorHandler.sync(this);\n                alternative = this.interpreter.adaptivePredict(this.tokenStream, 6, this.context);\n            }\n        } catch (re) {\n            if (re instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                this.errorHandler.reportError(this, re);\n                this.errorHandler.recover(this, re);\n            } else throw re;\n        } finally{\n            this.unrollRecursionContexts(parentContext);\n        }\n        return localContext;\n    }\n    func() {\n        let localContext = new $2e334593fe001b5e$export$6db68263558e628(this.context, this.state);\n        this.enterRule(localContext, 8, $2e334593fe001b5e$export$800110701abe823.RULE_func);\n        let _la;\n        try {\n            this.enterOuterAlt(localContext, 1);\n            this.state = 67;\n            this.match($2e334593fe001b5e$export$800110701abe823.ID);\n            this.state = 68;\n            this.match($2e334593fe001b5e$export$800110701abe823.LPAREN);\n            this.state = 69;\n            this.expr(0);\n            this.state = 74;\n            this.errorHandler.sync(this);\n            _la = this.tokenStream.LA(1);\n            while(_la === 5){\n                this.state = 70;\n                this.match($2e334593fe001b5e$export$800110701abe823.COMMA);\n                this.state = 71;\n                this.expr(0);\n                this.state = 76;\n                this.errorHandler.sync(this);\n                _la = this.tokenStream.LA(1);\n            }\n            this.state = 77;\n            this.match($2e334593fe001b5e$export$800110701abe823.RPAREN);\n        } catch (re) {\n            if (re instanceof $c1efbdb2cbf46748$export$c1c401305ad687ac) {\n                this.errorHandler.reportError(this, re);\n                this.errorHandler.recover(this, re);\n            } else throw re;\n        } finally{\n            this.exitRule();\n        }\n        return localContext;\n    }\n    sempred(localContext, ruleIndex, predIndex) {\n        switch(ruleIndex){\n            case 3:\n                return this.expr_sempred(localContext, predIndex);\n        }\n        return true;\n    }\n    expr_sempred(localContext, predIndex) {\n        switch(predIndex){\n            case 0:\n                return this.precpred(this.context, 2);\n            case 1:\n                return this.precpred(this.context, 1);\n        }\n        return true;\n    }\n    static{\n        this._serializedATN = [\n            4,\n            1,\n            13,\n            80,\n            2,\n            0,\n            7,\n            0,\n            2,\n            1,\n            7,\n            1,\n            2,\n            2,\n            7,\n            2,\n            2,\n            3,\n            7,\n            3,\n            2,\n            4,\n            7,\n            4,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            1,\n            0,\n            3,\n            0,\n            17,\n            8,\n            0,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            3,\n            1,\n            27,\n            8,\n            1,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            5,\n            2,\n            34,\n            8,\n            2,\n            10,\n            2,\n            12,\n            2,\n            37,\n            9,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            2,\n            5,\n            2,\n            42,\n            8,\n            2,\n            10,\n            2,\n            12,\n            2,\n            45,\n            9,\n            2,\n            1,\n            2,\n            1,\n            2,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            3,\n            3,\n            55,\n            8,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            1,\n            3,\n            5,\n            3,\n            63,\n            8,\n            3,\n            10,\n            3,\n            12,\n            3,\n            66,\n            9,\n            3,\n            1,\n            4,\n            1,\n            4,\n            1,\n            4,\n            1,\n            4,\n            1,\n            4,\n            5,\n            4,\n            73,\n            8,\n            4,\n            10,\n            4,\n            12,\n            4,\n            76,\n            9,\n            4,\n            1,\n            4,\n            1,\n            4,\n            1,\n            4,\n            0,\n            1,\n            6,\n            5,\n            0,\n            2,\n            4,\n            6,\n            8,\n            0,\n            0,\n            84,\n            0,\n            16,\n            1,\n            0,\n            0,\n            0,\n            2,\n            26,\n            1,\n            0,\n            0,\n            0,\n            4,\n            28,\n            1,\n            0,\n            0,\n            0,\n            6,\n            54,\n            1,\n            0,\n            0,\n            0,\n            8,\n            67,\n            1,\n            0,\n            0,\n            0,\n            10,\n            11,\n            3,\n            2,\n            1,\n            0,\n            11,\n            12,\n            5,\n            0,\n            0,\n            1,\n            12,\n            17,\n            1,\n            0,\n            0,\n            0,\n            13,\n            14,\n            3,\n            4,\n            2,\n            0,\n            14,\n            15,\n            5,\n            0,\n            0,\n            1,\n            15,\n            17,\n            1,\n            0,\n            0,\n            0,\n            16,\n            10,\n            1,\n            0,\n            0,\n            0,\n            16,\n            13,\n            1,\n            0,\n            0,\n            0,\n            17,\n            1,\n            1,\n            0,\n            0,\n            0,\n            18,\n            19,\n            5,\n            12,\n            0,\n            0,\n            19,\n            20,\n            5,\n            4,\n            0,\n            0,\n            20,\n            21,\n            3,\n            6,\n            3,\n            0,\n            21,\n            22,\n            5,\n            6,\n            0,\n            0,\n            22,\n            27,\n            1,\n            0,\n            0,\n            0,\n            23,\n            24,\n            3,\n            6,\n            3,\n            0,\n            24,\n            25,\n            5,\n            6,\n            0,\n            0,\n            25,\n            27,\n            1,\n            0,\n            0,\n            0,\n            26,\n            18,\n            1,\n            0,\n            0,\n            0,\n            26,\n            23,\n            1,\n            0,\n            0,\n            0,\n            27,\n            3,\n            1,\n            0,\n            0,\n            0,\n            28,\n            29,\n            5,\n            12,\n            0,\n            0,\n            29,\n            30,\n            5,\n            7,\n            0,\n            0,\n            30,\n            35,\n            5,\n            12,\n            0,\n            0,\n            31,\n            32,\n            5,\n            5,\n            0,\n            0,\n            32,\n            34,\n            5,\n            12,\n            0,\n            0,\n            33,\n            31,\n            1,\n            0,\n            0,\n            0,\n            34,\n            37,\n            1,\n            0,\n            0,\n            0,\n            35,\n            33,\n            1,\n            0,\n            0,\n            0,\n            35,\n            36,\n            1,\n            0,\n            0,\n            0,\n            36,\n            38,\n            1,\n            0,\n            0,\n            0,\n            37,\n            35,\n            1,\n            0,\n            0,\n            0,\n            38,\n            39,\n            5,\n            8,\n            0,\n            0,\n            39,\n            43,\n            5,\n            9,\n            0,\n            0,\n            40,\n            42,\n            3,\n            2,\n            1,\n            0,\n            41,\n            40,\n            1,\n            0,\n            0,\n            0,\n            42,\n            45,\n            1,\n            0,\n            0,\n            0,\n            43,\n            41,\n            1,\n            0,\n            0,\n            0,\n            43,\n            44,\n            1,\n            0,\n            0,\n            0,\n            44,\n            46,\n            1,\n            0,\n            0,\n            0,\n            45,\n            43,\n            1,\n            0,\n            0,\n            0,\n            46,\n            47,\n            5,\n            10,\n            0,\n            0,\n            47,\n            5,\n            1,\n            0,\n            0,\n            0,\n            48,\n            49,\n            6,\n            3,\n            -1,\n            0,\n            49,\n            55,\n            5,\n            12,\n            0,\n            0,\n            50,\n            55,\n            5,\n            11,\n            0,\n            0,\n            51,\n            55,\n            3,\n            8,\n            4,\n            0,\n            52,\n            53,\n            5,\n            3,\n            0,\n            0,\n            53,\n            55,\n            3,\n            6,\n            3,\n            3,\n            54,\n            48,\n            1,\n            0,\n            0,\n            0,\n            54,\n            50,\n            1,\n            0,\n            0,\n            0,\n            54,\n            51,\n            1,\n            0,\n            0,\n            0,\n            54,\n            52,\n            1,\n            0,\n            0,\n            0,\n            55,\n            64,\n            1,\n            0,\n            0,\n            0,\n            56,\n            57,\n            10,\n            2,\n            0,\n            0,\n            57,\n            58,\n            5,\n            1,\n            0,\n            0,\n            58,\n            63,\n            3,\n            6,\n            3,\n            3,\n            59,\n            60,\n            10,\n            1,\n            0,\n            0,\n            60,\n            61,\n            5,\n            2,\n            0,\n            0,\n            61,\n            63,\n            3,\n            6,\n            3,\n            2,\n            62,\n            56,\n            1,\n            0,\n            0,\n            0,\n            62,\n            59,\n            1,\n            0,\n            0,\n            0,\n            63,\n            66,\n            1,\n            0,\n            0,\n            0,\n            64,\n            62,\n            1,\n            0,\n            0,\n            0,\n            64,\n            65,\n            1,\n            0,\n            0,\n            0,\n            65,\n            7,\n            1,\n            0,\n            0,\n            0,\n            66,\n            64,\n            1,\n            0,\n            0,\n            0,\n            67,\n            68,\n            5,\n            12,\n            0,\n            0,\n            68,\n            69,\n            5,\n            7,\n            0,\n            0,\n            69,\n            74,\n            3,\n            6,\n            3,\n            0,\n            70,\n            71,\n            5,\n            5,\n            0,\n            0,\n            71,\n            73,\n            3,\n            6,\n            3,\n            0,\n            72,\n            70,\n            1,\n            0,\n            0,\n            0,\n            73,\n            76,\n            1,\n            0,\n            0,\n            0,\n            74,\n            72,\n            1,\n            0,\n            0,\n            0,\n            74,\n            75,\n            1,\n            0,\n            0,\n            0,\n            75,\n            77,\n            1,\n            0,\n            0,\n            0,\n            76,\n            74,\n            1,\n            0,\n            0,\n            0,\n            77,\n            78,\n            5,\n            8,\n            0,\n            0,\n            78,\n            9,\n            1,\n            0,\n            0,\n            0,\n            8,\n            16,\n            26,\n            35,\n            43,\n            54,\n            62,\n            64,\n            74\n        ];\n    }\n    static get _ATN() {\n        if (!$2e334593fe001b5e$export$800110701abe823.__ATN) $2e334593fe001b5e$export$800110701abe823.__ATN = new $c1efbdb2cbf46748$export$8d551c119323a3a7().deserialize($2e334593fe001b5e$export$800110701abe823._serializedATN);\n        return $2e334593fe001b5e$export$800110701abe823.__ATN;\n    }\n    static{\n        this.vocabulary = new $c1efbdb2cbf46748$export$6fe78fc0b86aec88($2e334593fe001b5e$export$800110701abe823.literalNames, $2e334593fe001b5e$export$800110701abe823.symbolicNames, []);\n    }\n    get vocabulary() {\n        return $2e334593fe001b5e$export$800110701abe823.vocabulary;\n    }\n    static{\n        this.decisionsToDFA = $2e334593fe001b5e$export$800110701abe823._ATN.decisionToState.map((ds, index)=>new $c1efbdb2cbf46748$export$d210bcfe90c75f0(ds, index));\n    }\n}\nclass $2e334593fe001b5e$export$eb6fef7b613a504d extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    constructor(parent, invokingState){\n        super(parent, invokingState);\n    }\n    stat() {\n        return this.getRuleContext(0, $2e334593fe001b5e$export$375382d24fd8693f);\n    }\n    EOF() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.EOF, 0);\n    }\n    def() {\n        return this.getRuleContext(0, $2e334593fe001b5e$export$5183956a3a58a148);\n    }\n    get ruleIndex() {\n        return $2e334593fe001b5e$export$800110701abe823.RULE_program;\n    }\n    enterRule(listener) {\n        if (listener.enterProgram) listener.enterProgram(this);\n    }\n    exitRule(listener) {\n        if (listener.exitProgram) listener.exitProgram(this);\n    }\n    accept(visitor) {\n        if (visitor.visitProgram) return visitor.visitProgram(this);\n        else return visitor.visitChildren(this);\n    }\n}\nclass $2e334593fe001b5e$export$375382d24fd8693f extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    constructor(parent, invokingState){\n        super(parent, invokingState);\n    }\n    ID() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.ID, 0);\n    }\n    EQ() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.EQ, 0);\n    }\n    expr() {\n        return this.getRuleContext(0, $2e334593fe001b5e$export$286a3f51a71cff58);\n    }\n    SEMI() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.SEMI, 0);\n    }\n    get ruleIndex() {\n        return $2e334593fe001b5e$export$800110701abe823.RULE_stat;\n    }\n    enterRule(listener) {\n        if (listener.enterStat) listener.enterStat(this);\n    }\n    exitRule(listener) {\n        if (listener.exitStat) listener.exitStat(this);\n    }\n    accept(visitor) {\n        if (visitor.visitStat) return visitor.visitStat(this);\n        else return visitor.visitChildren(this);\n    }\n}\nclass $2e334593fe001b5e$export$5183956a3a58a148 extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    constructor(parent, invokingState){\n        super(parent, invokingState);\n    }\n    ID(i) {\n        if (i === undefined) return this.getTokens($2e334593fe001b5e$export$800110701abe823.ID);\n        else return this.getToken($2e334593fe001b5e$export$800110701abe823.ID, i);\n    }\n    LPAREN() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.LPAREN, 0);\n    }\n    RPAREN() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.RPAREN, 0);\n    }\n    LCURLY() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.LCURLY, 0);\n    }\n    RCURLY() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.RCURLY, 0);\n    }\n    COMMA(i) {\n        if (i === undefined) return this.getTokens($2e334593fe001b5e$export$800110701abe823.COMMA);\n        else return this.getToken($2e334593fe001b5e$export$800110701abe823.COMMA, i);\n    }\n    stat(i) {\n        if (i === undefined) return this.getRuleContexts($2e334593fe001b5e$export$375382d24fd8693f);\n        return this.getRuleContext(i, $2e334593fe001b5e$export$375382d24fd8693f);\n    }\n    get ruleIndex() {\n        return $2e334593fe001b5e$export$800110701abe823.RULE_def;\n    }\n    enterRule(listener) {\n        if (listener.enterDef) listener.enterDef(this);\n    }\n    exitRule(listener) {\n        if (listener.exitDef) listener.exitDef(this);\n    }\n    accept(visitor) {\n        if (visitor.visitDef) return visitor.visitDef(this);\n        else return visitor.visitChildren(this);\n    }\n}\nclass $2e334593fe001b5e$export$286a3f51a71cff58 extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    constructor(parent, invokingState){\n        super(parent, invokingState);\n    }\n    ID() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.ID, 0);\n    }\n    INT() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.INT, 0);\n    }\n    func() {\n        return this.getRuleContext(0, $2e334593fe001b5e$export$6db68263558e628);\n    }\n    NOT() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.NOT, 0);\n    }\n    expr(i) {\n        if (i === undefined) return this.getRuleContexts($2e334593fe001b5e$export$286a3f51a71cff58);\n        return this.getRuleContext(i, $2e334593fe001b5e$export$286a3f51a71cff58);\n    }\n    AND() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.AND, 0);\n    }\n    OR() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.OR, 0);\n    }\n    get ruleIndex() {\n        return $2e334593fe001b5e$export$800110701abe823.RULE_expr;\n    }\n    enterRule(listener) {\n        if (listener.enterExpr) listener.enterExpr(this);\n    }\n    exitRule(listener) {\n        if (listener.exitExpr) listener.exitExpr(this);\n    }\n    accept(visitor) {\n        if (visitor.visitExpr) return visitor.visitExpr(this);\n        else return visitor.visitChildren(this);\n    }\n}\nclass $2e334593fe001b5e$export$6db68263558e628 extends $c1efbdb2cbf46748$export$1198dca6f94b6253 {\n    constructor(parent, invokingState){\n        super(parent, invokingState);\n    }\n    ID() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.ID, 0);\n    }\n    LPAREN() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.LPAREN, 0);\n    }\n    expr(i) {\n        if (i === undefined) return this.getRuleContexts($2e334593fe001b5e$export$286a3f51a71cff58);\n        return this.getRuleContext(i, $2e334593fe001b5e$export$286a3f51a71cff58);\n    }\n    RPAREN() {\n        return this.getToken($2e334593fe001b5e$export$800110701abe823.RPAREN, 0);\n    }\n    COMMA(i) {\n        if (i === undefined) return this.getTokens($2e334593fe001b5e$export$800110701abe823.COMMA);\n        else return this.getToken($2e334593fe001b5e$export$800110701abe823.COMMA, i);\n    }\n    get ruleIndex() {\n        return $2e334593fe001b5e$export$800110701abe823.RULE_func;\n    }\n    enterRule(listener) {\n        if (listener.enterFunc) listener.enterFunc(this);\n    }\n    exitRule(listener) {\n        if (listener.exitFunc) listener.exitFunc(this);\n    }\n    accept(visitor) {\n        if (visitor.visitFunc) return visitor.visitFunc(this);\n        else return visitor.visitChildren(this);\n    }\n}\n\n\n// Grab UI elements\nconst $b4e14b6b8da86996$var$inputEl = document.getElementById('input');\nconst $b4e14b6b8da86996$var$outputEl = document.getElementById('output');\nconst $b4e14b6b8da86996$var$btn = document.getElementById('go');\n$b4e14b6b8da86996$var$btn.addEventListener('click', ()=>{\n    const text = $b4e14b6b8da86996$var$inputEl.value;\n    const chars = (0, $c1efbdb2cbf46748$export$7bbbaf2220a3f180).fromString(text);\n    const lexer = new (0, $abcf7a628702571d$export$93e3b1450253a6f7)(chars);\n    const tokens = new (0, $c1efbdb2cbf46748$export$3b6c0b5bd4a5b0b9)(lexer);\n    const parser = new (0, $2e334593fe001b5e$export$800110701abe823)(tokens);\n    // entry rule  adjust to your grammars start symbol:\n    const tree = parser.program();\n    $b4e14b6b8da86996$var$outputEl.textContent = parser.ruleNames.toString();\n});\n\n\n//# sourceMappingURL=ahk2-antlr4-demo.6a4e3c52.js.map\n","import { CharStream, CommonTokenStream } from 'antlr4ng';\r\nimport { MainGrammarLexer }      from './parser/MainGrammarLexer';\r\nimport { MainGrammarParser }     from './parser/MainGrammarParser';\r\n\r\n// Grab UI elements\r\nconst inputEl  = document.getElementById('input')  as HTMLTextAreaElement;\r\nconst outputEl = document.getElementById('output') as HTMLPreElement;\r\nconst btn      = document.getElementById('go')     as HTMLButtonElement;\r\n\r\nbtn.addEventListener('click', () => {\r\n  const text = inputEl.value;\r\n  const chars = CharStream.fromString(text);\r\n  const lexer = new MainGrammarLexer(chars);\r\n  const tokens = new CommonTokenStream(lexer);\r\n  const parser = new MainGrammarParser(tokens);\r\n\r\n  // entry rule  adjust to your grammars start symbol:\r\n  const tree = parser.program();\r\n\r\n  outputEl.textContent = parser.ruleNames.toString();\r\n});","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/IntStream.ts\nvar IntStream;\n((IntStream2) => {\n  IntStream2.EOF = -1;\n  IntStream2.UNKNOWN_SOURCE_NAME = \"<unknown>\";\n})(IntStream || (IntStream = {}));\n\n// src/Token.ts\nvar Token;\n((Token2) => {\n  Token2.INVALID_TYPE = 0;\n  Token2.EPSILON = -2;\n  Token2.MIN_USER_TOKEN_TYPE = 1;\n  Token2.EOF = IntStream.EOF;\n  Token2.DEFAULT_CHANNEL = 0;\n  Token2.HIDDEN_CHANNEL = 1;\n  Token2.MIN_USER_CHANNEL_VALUE = 2;\n})(Token || (Token = {}));\nvar isToken = /* @__PURE__ */ __name((candidate) => {\n  const token = candidate;\n  return token.tokenSource !== void 0 && token.channel !== void 0;\n}, \"isToken\");\n\n// src/misc/BitSet.ts\nvar BitSet = class {\n  static {\n    __name(this, \"BitSet\");\n  }\n  data;\n  /**\n   * Creates a new bit set. All bits are initially `false`.\n   *\n   * @param data Optional initial data.\n   */\n  constructor(data) {\n    if (data) {\n      this.data = new Uint32Array(data.map((value) => {\n        return value >>> 0;\n      }));\n    } else {\n      this.data = new Uint32Array(1);\n    }\n  }\n  /**\n   * @returns an iterator over all set bits.\n   */\n  [Symbol.iterator]() {\n    const length = this.data.length;\n    let currentIndex = 0;\n    let currentWord = this.data[currentIndex];\n    const words = this.data;\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next: /* @__PURE__ */ __name(() => {\n        while (currentIndex < length) {\n          if (currentWord !== 0) {\n            const t = currentWord & -currentWord;\n            const value = (currentIndex << 5) + this.bitCount(t - 1);\n            currentWord ^= t;\n            return { done: false, value };\n          } else {\n            currentIndex++;\n            if (currentIndex < length) {\n              currentWord = words[currentIndex];\n            }\n          }\n        }\n        return { done: true, value: void 0 };\n      }, \"next\")\n    };\n  }\n  /**\n   * Sets a single bit or all of the bits in this `BitSet` to `false`.\n   *\n   * @param index the index of the bit to be cleared, or undefined to clear all bits.\n   */\n  clear(index) {\n    if (index === void 0) {\n      this.data = new Uint32Array();\n    } else {\n      this.resize(index);\n      this.data[index >>> 5] &= ~(1 << index);\n    }\n  }\n  /**\n   * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it\n   * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit\n   * set argument has the value `true`.\n   *\n   * @param set the bit set to be ORed with.\n   */\n  or(set) {\n    const minCount = Math.min(this.data.length, set.data.length);\n    for (let k = 0; k < minCount; ++k) {\n      this.data[k] |= set.data[k];\n    }\n    if (this.data.length < set.data.length) {\n      this.resize((set.data.length << 5) - 1);\n      const c = set.data.length;\n      for (let k = minCount; k < c; ++k) {\n        this.data[k] = set.data[k];\n      }\n    }\n  }\n  /**\n   * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`\n   * is currently set in this `BitSet`; otherwise, the result is `false`.\n   *\n   * @param index the bit index\n   *\n   * @returns the value of the bit with the specified index.\n   */\n  get(index) {\n    if (index < 0) {\n      throw new RangeError(\"index cannot be negative\");\n    }\n    const slot = index >>> 5;\n    if (slot >= this.data.length) {\n      return false;\n    }\n    return (this.data[slot] & 1 << index % 32) !== 0;\n  }\n  /**\n   * @returns the number of set bits.\n   */\n  get length() {\n    let result = 0;\n    const c = this.data.length;\n    const w = this.data;\n    for (let i = 0; i < c; i++) {\n      result += this.bitCount(w[i]);\n    }\n    return result;\n  }\n  /**\n   * @returns an array with indices of set bits.\n   */\n  values() {\n    const result = new Array(this.length);\n    let pos = 0;\n    const length = this.data.length;\n    for (let k = 0; k < length; ++k) {\n      let w = this.data[k];\n      while (w !== 0) {\n        const t = w & -w;\n        result[pos++] = (k << 5) + this.bitCount(t - 1);\n        w ^= t;\n      }\n    }\n    return result;\n  }\n  /**\n   * @returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.\n   * If no such bit exists then undefined is returned.\n   *\n   * @param fromIndex the index to start checking from (inclusive)\n   */\n  nextSetBit(fromIndex) {\n    if (fromIndex < 0) {\n      throw new RangeError(\"index cannot be negative\");\n    }\n    for (const index of this) {\n      if (index >= fromIndex) {\n        return index;\n      }\n    }\n    return void 0;\n  }\n  /**\n   * Sets the bit at the specified index to `true`.\n   *\n   * @param index a bit index\n   */\n  set(index) {\n    if (index < 0) {\n      throw new RangeError(\"index cannot be negative\");\n    }\n    this.resize(index);\n    this.data[index >>> 5] |= 1 << index % 32;\n  }\n  /**\n   * @returns a string representation of this bit set.\n   */\n  toString() {\n    return \"{\" + this.values().join(\", \") + \"}\";\n  }\n  resize(index) {\n    const count = index + 32 >>> 5;\n    if (count <= this.data.length) {\n      return;\n    }\n    const data = new Uint32Array(count);\n    data.set(this.data);\n    data.fill(0, this.data.length);\n    this.data = data;\n  }\n  bitCount(v) {\n    v = v - (v >> 1 & 1431655765);\n    v = (v & 858993459) + (v >> 2 & 858993459);\n    v = v + (v >> 4) & 252645135;\n    v = v + (v >> 8);\n    v = v + (v >> 16);\n    return v & 63;\n  }\n};\n\n// src/utils/MurmurHash.ts\nvar c1 = 3432918353;\nvar c2 = 461845907;\nvar r1 = 15;\nvar r2 = 13;\nvar m = 5;\nvar n = 3864292196;\nvar MurmurHash = class _MurmurHash {\n  static {\n    __name(this, \"MurmurHash\");\n  }\n  static defaultSeed = 701;\n  constructor() {\n  }\n  /**\n   * Initialize the hash using the specified {@code seed}.\n   *\n   * @param seed the seed\n   *\n   * @returns the intermediate hash value\n   */\n  static initialize(seed = _MurmurHash.defaultSeed) {\n    return seed;\n  }\n  static updateFromComparable(hash, value) {\n    return this.update(hash, value?.hashCode() ?? 0);\n  }\n  /**\n   * Update the intermediate hash value for the next input {@code value}.\n   *\n   * @param hash The intermediate hash value.\n   * @param value the value to add to the current hash.\n   *\n   * @returns the updated intermediate hash value\n   */\n  static update(hash, value) {\n    value = Math.imul(value, c1);\n    value = value << r1 | value >>> 32 - r1;\n    value = Math.imul(value, c2);\n    hash = hash ^ value;\n    hash = hash << r2 | hash >>> 32 - r2;\n    hash = Math.imul(hash, m) + n;\n    return hash;\n  }\n  /**\n   * Apply the final computation steps to the intermediate value {@code hash}\n   * to form the final result of the MurmurHash 3 hash function.\n   *\n   * @param hash The intermediate hash value.\n   * @param entryCount The number of values added to the hash.\n   *\n   * @returns the final hash result\n   */\n  static finish(hash, entryCount) {\n    hash ^= entryCount * 4;\n    hash ^= hash >>> 16;\n    hash = Math.imul(hash, 2246822507);\n    hash ^= hash >>> 13;\n    hash = Math.imul(hash, 3266489909);\n    hash ^= hash >>> 16;\n    return hash;\n  }\n  /**\n   * An all-in-one convenience method to compute a hash for a single value.\n   *\n   * @param value The value to hash.\n   * @param seed The seed for the hash value.\n   *\n   * @returns The computed hash.\n   */\n  static hashCode(value, seed) {\n    return _MurmurHash.finish(_MurmurHash.update(seed ?? _MurmurHash.defaultSeed, value), 1);\n  }\n};\n\n// src/misc/ObjectEqualityComparator.ts\nvar ObjectEqualityComparator = class _ObjectEqualityComparator {\n  static {\n    __name(this, \"ObjectEqualityComparator\");\n  }\n  static instance = new _ObjectEqualityComparator();\n  hashCode(obj) {\n    if (obj == null) {\n      return 0;\n    }\n    return obj.hashCode();\n  }\n  equals(a, b) {\n    if (a == null) {\n      return b == null;\n    }\n    return a.equals(b);\n  }\n};\n\n// src/misc/DefaultEqualityComparator.ts\nvar DefaultEqualityComparator = class _DefaultEqualityComparator {\n  static {\n    __name(this, \"DefaultEqualityComparator\");\n  }\n  static instance = new _DefaultEqualityComparator();\n  hashCode(obj) {\n    if (obj == null) {\n      return 0;\n    }\n    return ObjectEqualityComparator.instance.hashCode(obj);\n  }\n  equals(a, b) {\n    if (a == null) {\n      return b == null;\n    }\n    if (typeof a === \"string\" || typeof a === \"number\") {\n      return a === b;\n    }\n    return ObjectEqualityComparator.instance.equals(a, b);\n  }\n};\n\n// src/misc/HashSet.ts\nvar HashSet = class _HashSet {\n  static {\n    __name(this, \"HashSet\");\n  }\n  static defaultLoadFactor = 0.75;\n  static initialCapacity = 16;\n  // must be power of 2\n  comparator;\n  buckets;\n  threshold;\n  /** How many elements in set */\n  itemCount = 0;\n  constructor(comparatorOrSet, initialCapacity = _HashSet.initialCapacity) {\n    if (comparatorOrSet instanceof _HashSet) {\n      this.comparator = comparatorOrSet.comparator;\n      this.buckets = comparatorOrSet.buckets.slice(0);\n      for (let i = 0; i < this.buckets.length; i++) {\n        const bucket = this.buckets[i];\n        if (bucket) {\n          this.buckets[i] = bucket.slice(0);\n        }\n      }\n      this.itemCount = comparatorOrSet.itemCount;\n      this.threshold = comparatorOrSet.threshold;\n    } else {\n      this.comparator = comparatorOrSet ?? DefaultEqualityComparator.instance;\n      this.buckets = this.createBuckets(initialCapacity);\n      this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);\n    }\n  }\n  /**\n   * Add `o` to set if not there; return existing value if already\n   * there. This method performs the same operation as {@link #add} aside from\n   * the return value.\n   *\n   * @param o the object to add to the set.\n   *\n   * @returns An existing element that equals to `o` if already in set, otherwise `o`.\n   */\n  getOrAdd(o) {\n    if (this.itemCount > this.threshold) {\n      this.expand();\n    }\n    const b = this.getBucket(o);\n    let bucket = this.buckets[b];\n    if (!bucket) {\n      bucket = [o];\n      this.buckets[b] = bucket;\n      ++this.itemCount;\n      return o;\n    }\n    for (const existing of bucket) {\n      if (this.comparator.equals(existing, o)) {\n        return existing;\n      }\n    }\n    bucket.push(o);\n    ++this.itemCount;\n    return o;\n  }\n  get(o) {\n    if (o == null) {\n      return o;\n    }\n    const b = this.getBucket(o);\n    const bucket = this.buckets[b];\n    if (!bucket) {\n      return void 0;\n    }\n    for (const e of bucket) {\n      if (this.comparator.equals(e, o)) {\n        return e;\n      }\n    }\n    return void 0;\n  }\n  /**\n   * Removes the specified element from this set if it is present.\n   *\n   * @param o object to be removed from this set, if present.\n   *\n   * @returns `true` if the set contained the specified element.\n   */\n  remove(o) {\n    if (o == null) {\n      return false;\n    }\n    const b = this.getBucket(o);\n    const bucket = this.buckets[b];\n    if (!bucket) {\n      return false;\n    }\n    for (let i = 0; i < bucket.length; i++) {\n      const existing = bucket[i];\n      if (this.comparator.equals(existing, o)) {\n        bucket.splice(i, 1);\n        --this.itemCount;\n        return true;\n      }\n    }\n    return false;\n  }\n  hashCode() {\n    let hash = MurmurHash.initialize();\n    for (const bucket of this.buckets) {\n      if (bucket == null) {\n        continue;\n      }\n      for (const o of bucket) {\n        if (o == null) {\n          break;\n        }\n        hash = MurmurHash.update(hash, this.comparator.hashCode(o));\n      }\n    }\n    hash = MurmurHash.finish(hash, this.size);\n    return hash;\n  }\n  equals(o) {\n    if (o === this) {\n      return true;\n    }\n    if (!(o instanceof _HashSet)) {\n      return false;\n    }\n    if (o.size !== this.size) {\n      return false;\n    }\n    return this.containsAll(o);\n  }\n  add(t) {\n    const existing = this.getOrAdd(t);\n    return existing === t;\n  }\n  contains(o) {\n    return this.containsFast(o);\n  }\n  containsFast(obj) {\n    if (obj == null) {\n      return false;\n    }\n    return this.get(obj) !== void 0;\n  }\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n  toArray() {\n    const a = new Array(this.size);\n    let i = 0;\n    for (const bucket of this.buckets) {\n      if (bucket == null) {\n        continue;\n      }\n      for (const o of bucket) {\n        if (o == null) {\n          break;\n        }\n        a[i++] = o;\n      }\n    }\n    return a;\n  }\n  containsAll(collection) {\n    if (collection instanceof _HashSet) {\n      for (const bucket of collection.buckets) {\n        if (bucket == null) {\n          continue;\n        }\n        for (const o of bucket) {\n          if (o == null) {\n            break;\n          }\n          if (!this.containsFast(o)) {\n            return false;\n          }\n        }\n      }\n    } else {\n      for (const o of collection) {\n        if (!this.containsFast(o)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  addAll(c) {\n    let changed = false;\n    for (const o of c) {\n      const existing = this.getOrAdd(o);\n      if (existing !== o) {\n        changed = true;\n      }\n    }\n    return changed;\n  }\n  clear() {\n    this.buckets = this.createBuckets(_HashSet.initialCapacity);\n    this.itemCount = 0;\n    this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);\n  }\n  toString() {\n    if (this.size === 0) {\n      return \"{}\";\n    }\n    let buf = \"{\";\n    let first = true;\n    for (const bucket of this.buckets) {\n      if (bucket == null) {\n        continue;\n      }\n      for (const o of bucket) {\n        if (o == null) {\n          break;\n        }\n        if (first) {\n          first = false;\n        } else {\n          buf += \", \";\n        }\n        buf += o.toString();\n      }\n    }\n    buf += \"}\";\n    return buf;\n  }\n  toTableString() {\n    let buf = \"\";\n    for (const bucket of this.buckets) {\n      if (bucket == null) {\n        buf += \"null\\n\";\n        continue;\n      }\n      buf += \"[\";\n      let first = true;\n      for (const o of bucket) {\n        if (first) {\n          first = false;\n        } else {\n          buf += \" \";\n        }\n        if (o == null) {\n          buf += \"_\";\n        } else {\n          buf += o.toString();\n        }\n      }\n      buf += \"]\\n\";\n    }\n    return buf;\n  }\n  getBucket(o) {\n    const hash = this.comparator.hashCode(o);\n    const b = hash & this.buckets.length - 1;\n    return b;\n  }\n  expand() {\n    const old = this.buckets;\n    const newCapacity = this.buckets.length * 2;\n    const newTable = this.createBuckets(newCapacity);\n    this.buckets = newTable;\n    this.threshold = Math.floor(newCapacity * _HashSet.defaultLoadFactor);\n    for (const bucket of old) {\n      if (!bucket) {\n        continue;\n      }\n      for (const o of bucket) {\n        const b = this.getBucket(o);\n        let newBucket = this.buckets[b];\n        if (!newBucket) {\n          newBucket = [];\n          this.buckets[b] = newBucket;\n        }\n        newBucket.push(o);\n      }\n    }\n  }\n  get size() {\n    return this.itemCount;\n  }\n  get isEmpty() {\n    return this.itemCount === 0;\n  }\n  /**\n   * Return an array of `T[]` with length `capacity`.\n   *\n   * @param capacity the length of the array to return\n   * @returns the newly constructed array\n   */\n  createBuckets(capacity) {\n    return new Array(capacity);\n  }\n};\n\n// src/misc/Interval.ts\nvar Interval = class _Interval {\n  static {\n    __name(this, \"Interval\");\n  }\n  static INVALID_INTERVAL = new _Interval(-1, -2);\n  static INTERVAL_POOL_MAX_VALUE = 1e3;\n  static cache = [];\n  start;\n  stop;\n  cachedHashCode;\n  constructor(start, stop) {\n    this.start = start;\n    this.stop = stop;\n    this.cachedHashCode = Math.imul(651 + start, 31) + stop;\n  }\n  /**\n   * Creates a new interval from the given values.\n   *\n   * Interval objects are used readonly so share all with the\n   * same single value a==b up to some max size. Use an array as a perfect hash.\n   * Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new\n   * Interval object with a..a in it.  On Java.g4, 218623 IntervalSets\n   * have a..a (set with 1 element).\n   *\n   * @param a The start of the interval.\n   * @param b The end of the interval (inclusive).\n   *\n   * @returns A cached or new interval.\n   */\n  static of(a, b) {\n    if (a !== b || a < 0 || a > _Interval.INTERVAL_POOL_MAX_VALUE) {\n      return new _Interval(a, b);\n    }\n    if (!_Interval.cache[a]) {\n      _Interval.cache[a] = new _Interval(a, a);\n    }\n    return _Interval.cache[a];\n  }\n  equals(o) {\n    return this.start === o.start && this.stop === o.stop;\n  }\n  hashCode() {\n    return this.cachedHashCode;\n  }\n  /** Does this start completely before other? Disjoint */\n  startsBeforeDisjoint(other) {\n    return this.start < other.start && this.stop < other.start;\n  }\n  /** Does this start at or before other? Nondisjoint */\n  startsBeforeNonDisjoint(other) {\n    return this.start <= other.start && this.stop >= other.start;\n  }\n  /** Does this.start start after other.stop? May or may not be disjoint */\n  startsAfter(other) {\n    return this.start > other.start;\n  }\n  /** Does this start completely after other? Disjoint */\n  startsAfterDisjoint(other) {\n    return this.start > other.stop;\n  }\n  /** Does this start after other? NonDisjoint */\n  startsAfterNonDisjoint(other) {\n    return this.start > other.start && this.start <= other.stop;\n  }\n  /** Are both ranges disjoint? I.e., no overlap? */\n  disjoint(other) {\n    return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\n  }\n  /** Are two intervals adjacent such as 0..41 and 42..42? */\n  adjacent(other) {\n    return this.start === other.stop + 1 || this.stop === other.start - 1;\n  }\n  properlyContains(other) {\n    return other.start >= this.start && other.stop <= this.stop;\n  }\n  /** Return the interval computed from combining this and other */\n  union(other) {\n    return _Interval.of(Math.min(this.start, other.start), Math.max(this.stop, other.stop));\n  }\n  /** Return the interval in common between this and o */\n  intersection(other) {\n    return _Interval.of(Math.max(this.start, other.start), Math.min(this.stop, other.stop));\n  }\n  /**\n   * Return the interval with elements from this not in other;\n   *  other must not be totally enclosed (properly contained)\n   *  within this, which would result in two disjoint intervals\n   *  instead of the single one returned by this method.\n   */\n  differenceNotProperlyContained(other) {\n    let diff = null;\n    if (other.startsBeforeNonDisjoint(this)) {\n      diff = _Interval.of(Math.max(this.start, other.stop + 1), this.stop);\n    } else if (other.startsAfterNonDisjoint(this)) {\n      diff = _Interval.of(this.start, other.start - 1);\n    }\n    return diff;\n  }\n  toString() {\n    return `${this.start}..${this.stop}`;\n  }\n  get length() {\n    if (this.stop < this.start) {\n      return 0;\n    }\n    return this.stop - this.start + 1;\n  }\n};\n\n// src/Vocabulary.ts\nvar Vocabulary = class _Vocabulary {\n  static {\n    __name(this, \"Vocabulary\");\n  }\n  static EMPTY_NAMES = [];\n  /**\n   * Gets an empty {@link Vocabulary} instance.\n   *\n   *\n   * No literal or symbol names are assigned to token types, so\n   * {@link #getDisplayName(int)} returns the numeric value for all tokens\n   * except {@link Token#EOF}.\n   */\n  static EMPTY_VOCABULARY = new _Vocabulary(_Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES);\n  maxTokenType;\n  literalNames;\n  symbolicNames;\n  displayNames;\n  /**\n   * Constructs a new instance of {@link Vocabulary} from the specified\n   * literal, symbolic, and display token names.\n   *\n   * @param literalNames The literal names assigned to tokens, or `null`\n   * if no literal names are assigned.\n   * @param symbolicNames The symbolic names assigned to tokens, or\n   * `null` if no symbolic names are assigned.\n   * @param displayNames The display names assigned to tokens, or `null`\n   * to use the values in `literalNames` and `symbolicNames` as\n   * the source of display names, as described in\n   * {@link #getDisplayName(int)}.\n   */\n  constructor(literalNames, symbolicNames, displayNames) {\n    this.literalNames = literalNames ?? _Vocabulary.EMPTY_NAMES;\n    this.symbolicNames = symbolicNames ?? _Vocabulary.EMPTY_NAMES;\n    this.displayNames = displayNames ?? _Vocabulary.EMPTY_NAMES;\n    this.maxTokenType = Math.max(this.displayNames.length, Math.max(\n      this.literalNames.length,\n      this.symbolicNames.length\n    )) - 1;\n  }\n  /**\n   * Returns a {@link Vocabulary} instance from the specified set of token\n   * names. This method acts as a compatibility layer for the single\n   * `tokenNames` array generated by previous releases of ANTLR.\n   *\n   * The resulting vocabulary instance returns `null` for\n   * {@link getLiteralName getLiteralName(int)} and {@link getSymbolicName getSymbolicName(int)}, and the\n   * value from `tokenNames` for the display names.\n   *\n   * @param tokenNames The token names, or `null` if no token names are\n   * available.\n   * @returns A {@link Vocabulary} instance which uses `tokenNames` for\n   * the display names of tokens.\n   */\n  static fromTokenNames(tokenNames) {\n    if (tokenNames == null || tokenNames.length === 0) {\n      return _Vocabulary.EMPTY_VOCABULARY;\n    }\n    const literalNames = [...tokenNames];\n    const symbolicNames = [...tokenNames];\n    for (let i = 0; i < tokenNames.length; i++) {\n      const tokenName = tokenNames[i];\n      if (tokenName == null) {\n        continue;\n      }\n      if (tokenName.length > 0) {\n        const firstChar = tokenName.codePointAt(0);\n        if (firstChar === 39) {\n          symbolicNames[i] = null;\n          continue;\n        } else if (firstChar >= 65 && firstChar <= 90) {\n          literalNames[i] = null;\n          continue;\n        }\n      }\n      literalNames[i] = null;\n      symbolicNames[i] = null;\n    }\n    return new _Vocabulary(literalNames, symbolicNames, tokenNames);\n  }\n  getMaxTokenType() {\n    return this.maxTokenType;\n  }\n  getLiteralName(tokenType) {\n    if (tokenType >= 0 && tokenType < this.literalNames.length) {\n      return this.literalNames[tokenType];\n    }\n    return null;\n  }\n  getSymbolicName(tokenType) {\n    if (tokenType >= 0 && tokenType < this.symbolicNames.length) {\n      return this.symbolicNames[tokenType];\n    }\n    if (tokenType === Token.EOF) {\n      return \"EOF\";\n    }\n    return null;\n  }\n  getDisplayName(tokenType) {\n    if (tokenType >= 0 && tokenType < this.displayNames.length) {\n      const displayName = this.displayNames[tokenType];\n      if (displayName != null) {\n        return displayName;\n      }\n    }\n    const literalName = this.getLiteralName(tokenType);\n    if (literalName != null) {\n      return literalName;\n    }\n    const symbolicName = this.getSymbolicName(tokenType);\n    if (symbolicName != null) {\n      return symbolicName;\n    }\n    return `${tokenType}`;\n  }\n  getLiteralNames() {\n    return this.literalNames;\n  }\n  getSymbolicNames() {\n    return this.symbolicNames;\n  }\n  getDisplayNames() {\n    return this.displayNames;\n  }\n};\n\n// src/misc/IntervalSet.ts\nvar IntervalSet = class _IntervalSet {\n  static {\n    __name(this, \"IntervalSet\");\n  }\n  /** The list of sorted, disjoint intervals. */\n  intervals = [];\n  cachedHashCode;\n  constructor(set) {\n    if (set) {\n      if (Array.isArray(set)) {\n        for (const el of set) {\n          this.addOne(el);\n        }\n      } else {\n        this.addSet(set);\n      }\n    }\n  }\n  /** Create a set with all ints within range [a..b] (inclusive) */\n  static of(a, b) {\n    const s = new _IntervalSet();\n    s.addRange(a, b);\n    return s;\n  }\n  /** Combine all sets in the array and return the union of them */\n  static or(sets) {\n    const result = new _IntervalSet();\n    for (const set of sets) {\n      result.addSet(set);\n    }\n    return result;\n  }\n  [Symbol.iterator]() {\n    return this.intervals[Symbol.iterator]();\n  }\n  get(index) {\n    return this.intervals[index];\n  }\n  /**\n   * Returns the minimum value contained in the set if not isNil().\n   *\n   * @returns the minimum value contained in the set.\n   */\n  get minElement() {\n    if (this.intervals.length === 0) {\n      return Token.INVALID_TYPE;\n    }\n    return this.intervals[0].start;\n  }\n  /**\n   * Returns the maximum value contained in the set if not isNil().\n   *\n   * @returns the maximum value contained in the set.\n   */\n  get maxElement() {\n    if (this.intervals.length === 0) {\n      return Token.INVALID_TYPE;\n    }\n    return this.intervals[this.intervals.length - 1].stop;\n  }\n  clear() {\n    this.cachedHashCode = void 0;\n    this.intervals = [];\n  }\n  /**\n   * Add a single element to the set.  An isolated element is stored\n   *  as a range el..el.\n   */\n  addOne(v) {\n    this.addInterval(new Interval(v, v));\n  }\n  /**\n   * Add interval; i.e., add all integers from a to b to set.\n   *  If b < a, do nothing.\n   *  Keep list in sorted order (by left range value).\n   *  If overlap, combine ranges. For example,\n   *  If this is {1..5, 10..20}, adding 6..7 yields\n   *  {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}.\n   */\n  addRange(l, h) {\n    this.addInterval(new Interval(l, h));\n  }\n  addInterval(addition) {\n    this.cachedHashCode = void 0;\n    if (this.intervals.length === 0) {\n      this.intervals.push(addition);\n    } else {\n      for (let pos = 0; pos < this.intervals.length; pos++) {\n        const existing = this.intervals[pos];\n        if (addition.equals(existing)) {\n          return;\n        }\n        if (addition.adjacent(existing) || !addition.disjoint(existing)) {\n          const bigger = addition.union(existing);\n          this.intervals[pos] = bigger;\n          for (let sub = pos + 1; sub < this.intervals.length; ) {\n            const next = this.intervals[sub];\n            if (!bigger.adjacent(next) && bigger.disjoint(next)) {\n              break;\n            }\n            this.intervals.splice(sub, 1);\n            this.intervals[pos] = bigger.union(next);\n          }\n          return;\n        }\n        if (addition.startsBeforeDisjoint(existing)) {\n          this.intervals.splice(pos, 0, addition);\n          return;\n        }\n      }\n      this.intervals.push(addition);\n    }\n  }\n  addSet(other) {\n    other.intervals.forEach((toAdd) => {\n      return this.addInterval(toAdd);\n    }, this);\n    return this;\n  }\n  complementWithVocabulary(vocabulary) {\n    const result = new _IntervalSet();\n    if (!vocabulary) {\n      return result;\n    }\n    if (vocabulary.length === 0) {\n      return result;\n    }\n    result.addSet(vocabulary);\n    return result.subtract(this);\n  }\n  complement(minElement, maxElement) {\n    const result = new _IntervalSet();\n    result.addInterval(new Interval(minElement, maxElement));\n    return result.subtract(this);\n  }\n  /** combine all sets in the array returned the or'd value */\n  or(sets) {\n    const result = new _IntervalSet();\n    result.addSet(this);\n    sets.forEach((set) => {\n      return result.addSet(set);\n    });\n    return result;\n  }\n  and(other) {\n    if (other.length === 0) {\n      return new _IntervalSet();\n    }\n    const myIntervals = this.intervals;\n    const theirIntervals = other.intervals;\n    let intersection;\n    const mySize = myIntervals.length;\n    const theirSize = theirIntervals.length;\n    let i = 0;\n    let j = 0;\n    while (i < mySize && j < theirSize) {\n      const mine = myIntervals[i];\n      const theirs = theirIntervals[j];\n      if (mine.startsBeforeDisjoint(theirs)) {\n        i++;\n      } else if (theirs.startsBeforeDisjoint(mine)) {\n        j++;\n      } else if (mine.properlyContains(theirs)) {\n        if (!intersection) {\n          intersection = new _IntervalSet();\n        }\n        intersection.addInterval(mine.intersection(theirs));\n        j++;\n      } else if (theirs.properlyContains(mine)) {\n        if (!intersection) {\n          intersection = new _IntervalSet();\n        }\n        intersection.addInterval(mine.intersection(theirs));\n        i++;\n      } else if (!mine.disjoint(theirs)) {\n        if (!intersection) {\n          intersection = new _IntervalSet();\n        }\n        intersection.addInterval(mine.intersection(theirs));\n        if (mine.startsAfterNonDisjoint(theirs)) {\n          j++;\n        } else if (theirs.startsAfterNonDisjoint(mine)) {\n          i++;\n        }\n      }\n    }\n    if (!intersection) {\n      return new _IntervalSet();\n    }\n    return intersection;\n  }\n  /**\n   * Compute the set difference between two interval sets. The specific\n   * operation is `left - right`. If either of the input sets is\n   * `null`, it is treated as though it was an empty set.\n   */\n  subtract(other) {\n    if (this.length === 0) {\n      return new _IntervalSet();\n    }\n    const result = new _IntervalSet(this);\n    if (other.length === 0) {\n      return result;\n    }\n    let resultI = 0;\n    let rightI = 0;\n    while (resultI < result.intervals.length && rightI < other.intervals.length) {\n      const resultInterval = result.intervals[resultI];\n      const rightInterval = other.intervals[rightI];\n      if (rightInterval.stop < resultInterval.start) {\n        rightI++;\n        continue;\n      }\n      if (rightInterval.start > resultInterval.stop) {\n        resultI++;\n        continue;\n      }\n      let beforeCurrent;\n      let afterCurrent;\n      if (rightInterval.start > resultInterval.start) {\n        beforeCurrent = new Interval(resultInterval.start, rightInterval.start - 1);\n      }\n      if (rightInterval.stop < resultInterval.stop) {\n        afterCurrent = new Interval(rightInterval.stop + 1, resultInterval.stop);\n      }\n      if (beforeCurrent) {\n        if (afterCurrent) {\n          result.intervals[resultI] = beforeCurrent;\n          result.intervals.splice(resultI + 1, 0, afterCurrent);\n          resultI++;\n          rightI++;\n        } else {\n          result.intervals[resultI] = beforeCurrent;\n          resultI++;\n        }\n      } else {\n        if (afterCurrent) {\n          result.intervals[resultI] = afterCurrent;\n          rightI++;\n        } else {\n          result.intervals.splice(resultI, 1);\n        }\n      }\n    }\n    return result;\n  }\n  contains(el) {\n    const n2 = this.intervals.length;\n    let l = 0;\n    let r = n2 - 1;\n    while (l <= r) {\n      const m2 = Math.floor((l + r) / 2);\n      const interval = this.intervals[m2];\n      if (interval.stop < el) {\n        l = m2 + 1;\n      } else if (interval.start > el) {\n        r = m2 - 1;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n  removeRange(toRemove) {\n    this.cachedHashCode = void 0;\n    if (toRemove.start === toRemove.stop) {\n      this.removeOne(toRemove.start);\n    } else if (this.intervals !== null) {\n      let pos = 0;\n      for (const existing of this.intervals) {\n        if (toRemove.stop <= existing.start) {\n          return;\n        } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {\n          this.intervals[pos] = new Interval(existing.start, toRemove.start);\n          const x = new Interval(toRemove.stop, existing.stop);\n          this.intervals.splice(pos, 0, x);\n          return;\n        } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {\n          this.intervals.splice(pos, 1);\n          pos = pos - 1;\n        } else if (toRemove.start < existing.stop) {\n          this.intervals[pos] = new Interval(existing.start, toRemove.start);\n        } else if (toRemove.stop < existing.stop) {\n          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n        }\n        pos += 1;\n      }\n    }\n  }\n  removeOne(value) {\n    this.cachedHashCode = void 0;\n    for (let i = 0; i < this.intervals.length; i++) {\n      const existing = this.intervals[i];\n      if (value < existing.start) {\n        return;\n      } else if (value === existing.start && value === existing.stop) {\n        this.intervals.splice(i, 1);\n        return;\n      } else if (value === existing.start) {\n        this.intervals[i] = new Interval(existing.start + 1, existing.stop);\n        return;\n      } else if (value === existing.stop) {\n        this.intervals[i] = new Interval(existing.start, existing.stop - 1);\n        return;\n      } else if (value < existing.stop) {\n        const replace = new Interval(existing.start, value - 1);\n        this.intervals[i] = new Interval(value + 1, existing.stop);\n        this.intervals.splice(i, 0, replace);\n        return;\n      }\n    }\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      for (const interval of this.intervals) {\n        hash = MurmurHash.update(hash, interval.start);\n        hash = MurmurHash.update(hash, interval.stop);\n      }\n      this.cachedHashCode = MurmurHash.finish(hash, this.intervals.length * 2);\n    }\n    return this.cachedHashCode;\n  }\n  /**\n   * Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over\n   * both lists to make sure they are the same. Interval.equals() is used by the List.equals() method to check\n   * the ranges.\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.intervals.length !== other.intervals.length) {\n      return false;\n    }\n    for (let i = 0; i < this.intervals.length; i++) {\n      if (!this.intervals[i].equals(other.intervals[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  toString(elementsAreChar) {\n    if (this.intervals.length === 0) {\n      return \"{}\";\n    }\n    let result = \"\";\n    if (this.length > 1) {\n      result += \"{\";\n    }\n    for (let i = 0; i < this.intervals.length; ++i) {\n      const interval = this.intervals[i];\n      const start = interval.start;\n      const stop = interval.stop;\n      if (start === stop) {\n        if (start === Token.EOF) {\n          result += \"<EOF>\";\n        } else if (elementsAreChar) {\n          result += \"'\" + String.fromCodePoint(start) + \"'\";\n        } else {\n          result += start;\n        }\n      } else {\n        if (elementsAreChar) {\n          result += \"'\" + String.fromCodePoint(start) + \"'..'\" + String.fromCodePoint(stop) + \"'\";\n        } else {\n          result += start + \"..\" + stop;\n        }\n      }\n      if (i < this.intervals.length - 1) {\n        result += \", \";\n      }\n    }\n    if (this.length > 1) {\n      result += \"}\";\n    }\n    return result;\n  }\n  toStringWithVocabulary(vocabulary) {\n    if (this.intervals.length === 0) {\n      return \"{}\";\n    }\n    let result = \"\";\n    if (this.length > 1) {\n      result += \"{\";\n    }\n    for (let i = 0; i < this.intervals.length; ++i) {\n      const interval = this.intervals[i];\n      const start = interval.start;\n      const stop = interval.stop;\n      if (start === stop) {\n        if (start === Token.EOF) {\n          result += \"<EOF>\";\n        } else {\n          result += this.elementName(vocabulary, start);\n        }\n      } else {\n        for (let i2 = start; i2 <= stop; ++i2) {\n          if (i2 > start) {\n            result += \", \";\n          }\n          result += this.elementName(vocabulary, i2);\n        }\n      }\n      if (i < this.intervals.length - 1) {\n        result += \", \";\n      }\n    }\n    if (this.length > 1) {\n      result += \"}\";\n    }\n    return result;\n  }\n  toStringWithRuleNames(ruleNames) {\n    if (this.intervals.length === 0) {\n      return \"{}\";\n    }\n    let result = \"\";\n    if (this.length > 1) {\n      result += \"{\";\n    }\n    const vocabulary = Vocabulary.fromTokenNames(ruleNames);\n    for (let i = 0; i < this.intervals.length; ++i) {\n      const interval = this.intervals[i];\n      const start = interval.start;\n      const stop = interval.stop;\n      if (start === stop) {\n        if (start === Token.EOF) {\n          result += \"<EOF>\";\n        } else {\n          result += this.elementName(vocabulary, start);\n        }\n      } else {\n        for (let i2 = start; i2 <= stop; ++i2) {\n          if (i2 > start) {\n            result += \", \";\n          }\n          result += this.elementName(vocabulary, i2);\n        }\n      }\n      if (i < this.intervals.length - 1) {\n        result += \", \";\n      }\n    }\n    if (this.length > 1) {\n      result += \"}\";\n    }\n    return result;\n  }\n  toArray() {\n    const data = [];\n    for (const interval of this.intervals) {\n      for (let j = interval.start; j <= interval.stop; j++) {\n        data.push(j);\n      }\n    }\n    return data;\n  }\n  /** @returns the number of elements in this set. */\n  get length() {\n    let result = 0;\n    for (const interval of this.intervals) {\n      result += interval.length;\n    }\n    return result;\n  }\n  elementName(vocabulary, token) {\n    if (token === Token.EOF) {\n      return \"<EOF>\";\n    }\n    if (token === Token.EPSILON) {\n      return \"<EPSILON>\";\n    }\n    return vocabulary.getDisplayName(token);\n  }\n};\n\n// src/utils/helpers.ts\nvar isComparable = /* @__PURE__ */ __name((candidate) => {\n  return typeof candidate.equals === \"function\";\n}, \"isComparable\");\nvar valueToString = /* @__PURE__ */ __name((v) => {\n  return v === null ? \"null\" : v;\n}, \"valueToString\");\nvar arrayToString = /* @__PURE__ */ __name((value) => {\n  return Array.isArray(value) ? \"[\" + value.map(valueToString).join(\", \") + \"]\" : \"null\";\n}, \"arrayToString\");\nvar equalArrays = /* @__PURE__ */ __name((a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    const left = a[i];\n    const right = b[i];\n    if (left === right) {\n      continue;\n    }\n    if (!left || !left.equals(right)) {\n      return false;\n    }\n  }\n  return true;\n}, \"equalArrays\");\nvar equalNumberArrays = /* @__PURE__ */ __name((a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}, \"equalNumberArrays\");\nvar escapeWhitespace = /* @__PURE__ */ __name((s, escapeSpaces = false) => {\n  s = s.replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\");\n  if (escapeSpaces) {\n    s = s.replace(/ /g, \"\\xB7\");\n  }\n  return s;\n}, \"escapeWhitespace\");\n\n// src/atn/SemanticContext.ts\nvar SemanticContext = class _SemanticContext {\n  static {\n    __name(this, \"SemanticContext\");\n  }\n  cachedHashCode;\n  static andContext(a, b) {\n    if (a === null || a === _SemanticContext.NONE) {\n      return b;\n    }\n    if (b === null || b === _SemanticContext.NONE) {\n      return a;\n    }\n    const result = new AND(a, b);\n    if (result.operands.length === 1) {\n      return result.operands[0];\n    }\n    return result;\n  }\n  static orContext(a, b) {\n    if (a === null) {\n      return b;\n    }\n    if (b === null) {\n      return a;\n    }\n    if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {\n      return _SemanticContext.NONE;\n    }\n    const result = new OR(a, b);\n    if (result.operands.length === 1) {\n      return result.operands[0];\n    } else {\n      return result;\n    }\n  }\n  static filterPrecedencePredicates(set) {\n    const result = [];\n    for (const context of set) {\n      if (context instanceof _SemanticContext.PrecedencePredicate) {\n        result.push(context);\n      }\n    }\n    return result;\n  }\n  /**\n   * Evaluate the precedence predicates for the context and reduce the result.\n   *\n   * @param _parser The parser instance.\n   * @param _parserCallStack The current parser context object.\n   * @returns The simplified semantic context after precedence predicates are\n   * evaluated, which will be one of the following values.\n   * - {@link NONE}: if the predicate simplifies to `true` after\n   * precedence predicates are evaluated.\n   * - `null`: if the predicate simplifies to `false` after\n   * precedence predicates are evaluated.\n   * - `this`: if the semantic context is not changed as a result of\n   * precedence predicate evaluation.\n   * - A non-`null` {@link SemanticContext}: the new simplified\n   * semantic context after precedence predicates are evaluated.\n   */\n  evalPrecedence(_parser, _parserCallStack) {\n    return this;\n  }\n};\nvar AND = class _AND extends SemanticContext {\n  static {\n    __name(this, \"AND\");\n  }\n  operands;\n  /**\n   * A semantic context which is true whenever none of the contained contexts\n   * is false\n   */\n  constructor(a, b) {\n    super();\n    const operands = new HashSet();\n    if (a instanceof _AND) {\n      a.operands.forEach((o) => {\n        operands.add(o);\n      });\n    } else {\n      operands.add(a);\n    }\n    if (b instanceof _AND) {\n      b.operands.forEach((o) => {\n        operands.add(o);\n      });\n    } else {\n      operands.add(b);\n    }\n    const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);\n    if (precedencePredicates.length > 0) {\n      let reduced = null;\n      precedencePredicates.forEach((p) => {\n        if (reduced === null || p.precedence < reduced.precedence) {\n          reduced = p;\n        }\n      });\n      if (reduced) {\n        operands.add(reduced);\n      }\n    }\n    this.operands = operands.toArray();\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _AND)) {\n      return false;\n    }\n    return equalArrays(this.operands, other.operands);\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      for (const operand of this.operands) {\n        hash = MurmurHash.updateFromComparable(hash, operand);\n      }\n      hash = MurmurHash.update(hash, 3813686060);\n      this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);\n    }\n    return this.cachedHashCode;\n  }\n  /**\n   * {@inheritDoc}\n   *\n   *\n   * The evaluation of predicates by this context is short-circuiting, but\n   * unordered.\n   */\n  evaluate(parser, parserCallStack) {\n    for (const operand of this.operands) {\n      if (!operand.evaluate(parser, parserCallStack)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  evalPrecedence(parser, parserCallStack) {\n    let differs = false;\n    const operands = [];\n    for (const context of this.operands) {\n      const evaluated = context.evalPrecedence(parser, parserCallStack);\n      differs ||= evaluated !== context;\n      if (evaluated === null) {\n        return null;\n      } else if (evaluated !== SemanticContext.NONE) {\n        operands.push(evaluated);\n      }\n    }\n    if (!differs) {\n      return this;\n    }\n    if (operands.length === 0) {\n      return SemanticContext.NONE;\n    }\n    let result = null;\n    operands.forEach((o) => {\n      result = result === null ? o : SemanticContext.andContext(result, o);\n    });\n    return result;\n  }\n  toString() {\n    const s = this.operands.map((o) => {\n      return o.toString();\n    });\n    return (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n  }\n};\nvar OR = class _OR extends SemanticContext {\n  static {\n    __name(this, \"OR\");\n  }\n  operands;\n  /**\n   * A semantic context which is true whenever at least one of the contained\n   * contexts is true\n   */\n  constructor(a, b) {\n    super();\n    const operands = new HashSet();\n    if (a instanceof _OR) {\n      a.operands.forEach((o) => {\n        operands.add(o);\n      });\n    } else {\n      operands.add(a);\n    }\n    if (b instanceof _OR) {\n      b.operands.forEach((o) => {\n        operands.add(o);\n      });\n    } else {\n      operands.add(b);\n    }\n    const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);\n    if (precedencePredicates.length > 0) {\n      const s = precedencePredicates.sort((a2, b2) => {\n        return a2.compareTo(b2);\n      });\n      const reduced = s[s.length - 1];\n      operands.add(reduced);\n    }\n    this.operands = operands.toArray();\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    } else if (!(other instanceof _OR)) {\n      return false;\n    } else {\n      return equalArrays(this.operands, other.operands);\n    }\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      for (const operand of this.operands) {\n        hash = MurmurHash.updateFromComparable(hash, operand);\n      }\n      hash = MurmurHash.update(hash, 3383313031);\n      this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);\n    }\n    return this.cachedHashCode;\n  }\n  /**\n   * The evaluation of predicates by this context is short-circuiting, but unordered.\n   */\n  evaluate(parser, parserCallStack) {\n    for (const operand of this.operands) {\n      if (operand.evaluate(parser, parserCallStack)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  evalPrecedence(parser, parserCallStack) {\n    let differs = false;\n    const operands = [];\n    for (const context of this.operands) {\n      const evaluated = context.evalPrecedence(parser, parserCallStack);\n      differs ||= evaluated !== context;\n      if (evaluated === SemanticContext.NONE) {\n        return SemanticContext.NONE;\n      } else if (evaluated !== null) {\n        operands.push(evaluated);\n      }\n    }\n    if (!differs) {\n      return this;\n    }\n    if (operands.length === 0) {\n      return null;\n    }\n    let result = null;\n    operands.forEach((o) => {\n      result = result === null ? o : SemanticContext.orContext(result, o);\n    });\n    return result;\n  }\n  toString() {\n    const s = this.operands.map((o) => {\n      return o.toString();\n    });\n    return (s.length > 3 ? s.slice(3) : s).join(\"||\");\n  }\n};\n((SemanticContext2) => {\n  class Predicate extends SemanticContext2 {\n    static {\n      __name(this, \"Predicate\");\n    }\n    ruleIndex;\n    predIndex;\n    isCtxDependent;\n    // e.g., $i ref in pred\n    constructor(ruleIndex, predIndex, isCtxDependent) {\n      super();\n      this.ruleIndex = ruleIndex ?? -1;\n      this.predIndex = predIndex ?? -1;\n      this.isCtxDependent = isCtxDependent ?? false;\n    }\n    evaluate(parser, outerContext) {\n      const localctx = this.isCtxDependent ? outerContext : null;\n      return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n    }\n    hashCode() {\n      if (this.cachedHashCode === void 0) {\n        let hashCode = MurmurHash.initialize();\n        hashCode = MurmurHash.update(hashCode, this.ruleIndex);\n        hashCode = MurmurHash.update(hashCode, this.predIndex);\n        hashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);\n        hashCode = MurmurHash.finish(hashCode, 3);\n        this.cachedHashCode = hashCode;\n      }\n      return this.cachedHashCode;\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      }\n      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;\n    }\n    toString() {\n      return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n    }\n  }\n  SemanticContext2.Predicate = Predicate;\n  class PrecedencePredicate extends SemanticContext2 {\n    static {\n      __name(this, \"PrecedencePredicate\");\n    }\n    precedence;\n    constructor(precedence) {\n      super();\n      this.precedence = precedence ?? 0;\n    }\n    evaluate(parser, outerContext) {\n      return parser.precpred(outerContext, this.precedence);\n    }\n    evalPrecedence(parser, outerContext) {\n      if (parser.precpred(outerContext ?? null, this.precedence)) {\n        return SemanticContext2.NONE;\n      }\n      return null;\n    }\n    compareTo(other) {\n      return this.precedence - other.precedence;\n    }\n    hashCode() {\n      return 31 + this.precedence;\n    }\n    equals(other) {\n      if (this === other) {\n        return true;\n      }\n      return this.precedence === other.precedence;\n    }\n    toString() {\n      return \"{\" + this.precedence + \">=prec}?\";\n    }\n  }\n  SemanticContext2.PrecedencePredicate = PrecedencePredicate;\n  SemanticContext2.NONE = new Predicate();\n})(SemanticContext || (SemanticContext = {}));\n\n// src/atn/ATNConfig.ts\nvar ATNConfig = class _ATNConfig {\n  static {\n    __name(this, \"ATNConfig\");\n  }\n  /** The ATN state associated with this configuration */\n  state;\n  /** What alt (or lexer rule) is predicted by this configuration */\n  alt;\n  /**\n   * We cannot execute predicates dependent upon local context unless\n   * we know for sure we are in the correct context. Because there is\n   * no way to do this efficiently, we simply cannot evaluate\n   * dependent predicates unless we are in the rule that initially\n   * invokes the ATN simulator.\n   *\n   * closure() tracks the depth of how far we dip into the outer context:\n   * depth > 0.\n   */\n  reachesIntoOuterContext = false;\n  // Not used in hash code.\n  precedenceFilterSuppressed = false;\n  // Not used in hash code.\n  get semanticContext() {\n    return this.#semanticContext;\n  }\n  cachedHashCode;\n  // Shared with LexerATNConfig.\n  /**\n   * The syntactic context is a graph-structured stack node whose\n   * path(s) to the root is the rule invocation(s)\n   * chain used to arrive at the state.  The semantic context is\n   * the tree of semantic predicates encountered before reaching\n   * an ATN state\n   */\n  #context = null;\n  #semanticContext;\n  /** Never create config classes directly. Use the factory methods below. */\n  constructor(c, state, context, semanticContext) {\n    this.state = state;\n    this.alt = c.alt;\n    this.context = context;\n    this.#semanticContext = semanticContext ?? SemanticContext.NONE;\n    this.reachesIntoOuterContext = c.reachesIntoOuterContext;\n    if (c.precedenceFilterSuppressed !== void 0) {\n      this.precedenceFilterSuppressed = c.precedenceFilterSuppressed;\n    }\n  }\n  static duplicate(old, semanticContext) {\n    return new _ATNConfig(old, old.state, old.context, semanticContext ?? old.semanticContext);\n  }\n  static createWithContext(state, alt, context, semanticContext) {\n    return new _ATNConfig({ alt }, state, context, semanticContext);\n  }\n  static createWithConfig(state, config, context) {\n    return new _ATNConfig(config, state, context ?? config.context, config.semanticContext);\n  }\n  static createWithSemanticContext(state, c, semanticContext) {\n    return new _ATNConfig(c, state ?? c.state, c.context, semanticContext);\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hashCode = MurmurHash.initialize(7);\n      hashCode = MurmurHash.update(hashCode, this.state.stateNumber);\n      hashCode = MurmurHash.update(hashCode, this.alt);\n      hashCode = MurmurHash.updateFromComparable(hashCode, this.#context);\n      hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);\n      hashCode = MurmurHash.finish(hashCode, 4);\n      this.cachedHashCode = hashCode;\n    }\n    return this.cachedHashCode;\n  }\n  /**\n   * The stack of invoking states leading to the rule/states associated\n   * with this config.  We track only those contexts pushed during\n   * execution of the ATN simulator.\n   */\n  get context() {\n    return this.#context;\n  }\n  set context(context) {\n    this.#context = context;\n    this.cachedHashCode = void 0;\n  }\n  /**\n   * An ATN configuration is equal to another if both have\n   * the same state, they predict the same alternative, and\n   * syntactic/semantic contexts are the same.\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;\n  }\n  toString(_recog, showAlt = true) {\n    let alt = \"\";\n    if (showAlt) {\n      alt = \",\" + this.alt;\n    }\n    return \"(\" + this.state + alt + (this.context !== null ? \",[\" + this.context.toString() + \"]\" : \"\") + (this.semanticContext !== SemanticContext.NONE ? \",\" + this.semanticContext.toString() : \"\") + (this.reachesIntoOuterContext ? \",up=\" + this.reachesIntoOuterContext : \"\") + \")\";\n  }\n};\n\n// src/atn/ATNState.ts\nvar ATNState = class _ATNState {\n  static {\n    __name(this, \"ATNState\");\n  }\n  static INVALID_STATE_NUMBER = -1;\n  static INVALID_TYPE = 0;\n  static BASIC = 1;\n  static RULE_START = 2;\n  static BLOCK_START = 3;\n  static PLUS_BLOCK_START = 4;\n  static STAR_BLOCK_START = 5;\n  static TOKEN_START = 6;\n  static RULE_STOP = 7;\n  static BLOCK_END = 8;\n  static STAR_LOOP_BACK = 9;\n  static STAR_LOOP_ENTRY = 10;\n  static PLUS_LOOP_BACK = 11;\n  static LOOP_END = 12;\n  static stateType = _ATNState.INVALID_STATE_NUMBER;\n  stateNumber = 0;\n  ruleIndex = 0;\n  // at runtime, we don't have Rule objects\n  epsilonOnlyTransitions = false;\n  /** Used to cache lookahead during parsing, not used during construction */\n  nextTokenWithinRule;\n  /** Track the transitions emanating from this ATN state. */\n  transitions = [];\n  hashCode() {\n    return this.stateNumber;\n  }\n  equals(other) {\n    return this.stateNumber === other.stateNumber;\n  }\n  toString() {\n    return `${this.stateNumber}`;\n  }\n  addTransitionAtIndex(index, transition) {\n    if (this.transitions.length === 0) {\n      this.epsilonOnlyTransitions = transition.isEpsilon;\n    } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {\n      this.epsilonOnlyTransitions = false;\n    }\n    this.transitions.splice(index, 0, transition);\n  }\n  addTransition(transition) {\n    if (this.transitions.length === 0) {\n      this.epsilonOnlyTransitions = transition.isEpsilon;\n    } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {\n      this.epsilonOnlyTransitions = false;\n    }\n    this.transitions.push(transition);\n  }\n  setTransition(i, e) {\n    this.transitions.splice(i, 1, e);\n  }\n  removeTransition(index) {\n    const t = this.transitions.splice(index, 1);\n    return t[0];\n  }\n};\n\n// src/atn/PredictionContext.ts\nvar PredictionContext = class _PredictionContext {\n  static {\n    __name(this, \"PredictionContext\");\n  }\n  /**\n   * Represents `$` in an array in full context mode, when `$`\n   * doesn't mean wildcard: `$ + x = [$,x]`. Here,\n   * `$` = {@link EMPTY_RETURN_STATE}.\n   */\n  static EMPTY_RETURN_STATE = 2147483647;\n  static traceATNSimulator = false;\n  cachedHashCode;\n  constructor(cachedHashCode) {\n    this.cachedHashCode = cachedHashCode;\n  }\n  static calculateEmptyHashCode() {\n    let hash = MurmurHash.initialize(31);\n    hash = MurmurHash.finish(hash, 0);\n    return hash;\n  }\n  static calculateHashCodeSingle(parent, returnState) {\n    let hash = MurmurHash.initialize(31);\n    hash = MurmurHash.updateFromComparable(hash, parent);\n    hash = MurmurHash.update(hash, returnState);\n    hash = MurmurHash.finish(hash, 2);\n    return hash;\n  }\n  static calculateHashCodeList(parents, returnStates) {\n    let hash = MurmurHash.initialize(31);\n    for (const parent of parents) {\n      hash = MurmurHash.updateFromComparable(hash, parent);\n    }\n    for (const returnState of returnStates) {\n      hash = MurmurHash.update(hash, returnState);\n    }\n    hash = MurmurHash.finish(hash, 2 * parents.length);\n    return hash;\n  }\n  isEmpty() {\n    return false;\n  }\n  hasEmptyPath() {\n    return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;\n  }\n  hashCode() {\n    return this.cachedHashCode;\n  }\n  toString(_recog) {\n    return \"\";\n  }\n};\n\n// src/atn/SingletonPredictionContext.ts\nvar SingletonPredictionContext = class _SingletonPredictionContext extends PredictionContext {\n  static {\n    __name(this, \"SingletonPredictionContext\");\n  }\n  parent;\n  returnState;\n  constructor(parent, returnState) {\n    super(\n      parent ? PredictionContext.calculateHashCodeSingle(parent, returnState) : PredictionContext.calculateEmptyHashCode()\n    );\n    this.parent = parent ?? null;\n    this.returnState = returnState;\n  }\n  getParent(_index) {\n    return this.parent;\n  }\n  getReturnState(_index) {\n    return this.returnState;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _SingletonPredictionContext)) {\n      return false;\n    }\n    if (this.hashCode() !== other.hashCode()) {\n      return false;\n    }\n    if (this.returnState !== other.returnState) {\n      return false;\n    }\n    if (this.parent == null) {\n      return other.parent == null;\n    }\n    return this.parent.equals(other.parent);\n  }\n  toString() {\n    const up = this.parent === null ? \"\" : this.parent.toString();\n    if (up.length === 0) {\n      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n        return \"$\";\n      }\n      return \"\" + this.returnState;\n    } else {\n      return \"\" + this.returnState + \" \" + up;\n    }\n  }\n  get length() {\n    return 1;\n  }\n};\n\n// src/atn/EmptyPredictionContext.ts\nvar EmptyPredictionContext = class _EmptyPredictionContext extends SingletonPredictionContext {\n  static {\n    __name(this, \"EmptyPredictionContext\");\n  }\n  /**\n   * Represents `$` in local context prediction, which means wildcard.\n   * `*+x = *`.\n   */\n  static instance = new _EmptyPredictionContext();\n  constructor() {\n    super(void 0, PredictionContext.EMPTY_RETURN_STATE);\n  }\n  isEmpty() {\n    return true;\n  }\n  getParent() {\n    return null;\n  }\n  getReturnState() {\n    return this.returnState;\n  }\n  equals(other) {\n    return this === other;\n  }\n  toString() {\n    return \"$\";\n  }\n};\n\n// src/atn/Transition.ts\nvar Transition = class {\n  static {\n    __name(this, \"Transition\");\n  }\n  static INVALID = 0;\n  static EPSILON = 1;\n  static RANGE = 2;\n  static RULE = 3;\n  static PREDICATE = 4;\n  // e.g., {isType(input.LT(1))}\n  static ATOM = 5;\n  static ACTION = 6;\n  static SET = 7;\n  // ~(A|B) or ~atom, wildcard, which convert to next\n  static NOT_SET = 8;\n  static WILDCARD = 9;\n  static PRECEDENCE = 10;\n  /** The target of this transition. */\n  target;\n  constructor(target) {\n    this.target = target;\n  }\n  /**\n   * Determines if the transition is an \"epsilon\" transition.\n   *\n   * The default implementation returns `false`.\n   *\n   * @returns `true` if traversing this transition in the ATN does not\n   * consume an input symbol; otherwise, `false` if traversing this\n   * transition consumes (matches) an input symbol.\n   */\n  get isEpsilon() {\n    return false;\n  }\n  get label() {\n    return null;\n  }\n  toString() {\n    return \"\";\n  }\n};\n\n// src/atn/SetTransition.ts\nvar SetTransition = class extends Transition {\n  static {\n    __name(this, \"SetTransition\");\n  }\n  set;\n  constructor(target, set) {\n    super(target);\n    if (set) {\n      this.set = set;\n    } else {\n      this.set = IntervalSet.of(Token.INVALID_TYPE, Token.INVALID_TYPE);\n    }\n  }\n  get transitionType() {\n    return Transition.SET;\n  }\n  get label() {\n    return this.set;\n  }\n  matches(symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return this.set.contains(symbol);\n  }\n  toString() {\n    return this.set.toString();\n  }\n};\n\n// src/atn/NotSetTransition.ts\nvar NotSetTransition = class extends SetTransition {\n  static {\n    __name(this, \"NotSetTransition\");\n  }\n  get transitionType() {\n    return Transition.NOT_SET;\n  }\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n  }\n  toString() {\n    return \"~\" + super.toString();\n  }\n};\n\n// src/misc/MapKeyEqualityOperator.ts\nvar MapKeyEqualityComparator = class {\n  static {\n    __name(this, \"MapKeyEqualityComparator\");\n  }\n  keyComparator;\n  constructor(keyComparator) {\n    this.keyComparator = keyComparator;\n  }\n  hashCode(obj) {\n    return this.keyComparator.hashCode(obj.key);\n  }\n  equals(a, b) {\n    return this.keyComparator.equals(a.key, b.key);\n  }\n};\n\n// src/misc/HashMap.ts\nvar HashMap = class _HashMap {\n  static {\n    __name(this, \"HashMap\");\n  }\n  backingStore;\n  constructor(keyComparer) {\n    if (keyComparer instanceof _HashMap) {\n      this.backingStore = new HashSet(keyComparer.backingStore);\n    } else {\n      keyComparer = keyComparer ?? DefaultEqualityComparator.instance;\n      this.backingStore = new HashSet(new MapKeyEqualityComparator(keyComparer));\n    }\n  }\n  clear() {\n    this.backingStore.clear();\n  }\n  containsKey(key) {\n    return this.backingStore.contains({ key });\n  }\n  get(key) {\n    const bucket = this.backingStore.get({ key });\n    if (!bucket) {\n      return void 0;\n    }\n    return bucket.value;\n  }\n  get isEmpty() {\n    return this.backingStore.isEmpty;\n  }\n  /**\n   * Sets the value for a key in the map. If the key is not present in the map, it is added.\n   * If the key is present, the value is updated and the old value is returned.\n   *\n   * @param key The key to set.\n   * @param value The value to set.\n   *\n   * @returns The old value for the key, if present.\n   */\n  set(key, value) {\n    const element = this.backingStore.get({ key, value });\n    let result;\n    if (!element) {\n      this.backingStore.add({ key, value });\n    } else {\n      result = element.value;\n      element.value = value;\n    }\n    return result;\n  }\n  /**\n   * Sets the value for a key in the map if the key is not already present. Otherwise the value is not changed and\n   * the old value is returned.\n   *\n   * @param key The key to set.\n   * @param value The value to set.\n   *\n   * @returns The current value for the key, if present.\n   */\n  setIfAbsent(key, value) {\n    const element = this.backingStore.get({ key, value });\n    let result;\n    if (!element) {\n      this.backingStore.add({ key, value });\n    } else {\n      result = element.value;\n    }\n    return result;\n  }\n  keys() {\n    return this.backingStore.toArray().map((bucket) => {\n      return bucket.key;\n    });\n  }\n  values() {\n    return this.backingStore.toArray().map((bucket) => {\n      return bucket.value;\n    });\n  }\n  get size() {\n    return this.backingStore.size;\n  }\n  hashCode() {\n    return this.backingStore.hashCode();\n  }\n  equals(o) {\n    return this.backingStore.equals(o.backingStore);\n  }\n};\n\n// src/tree/TerminalNode.ts\nvar TerminalNode = class {\n  static {\n    __name(this, \"TerminalNode\");\n  }\n  parent = null;\n  symbol;\n  constructor(symbol) {\n    this.symbol = symbol;\n  }\n  getChild(_i) {\n    return null;\n  }\n  getSymbol() {\n    return this.symbol;\n  }\n  getPayload() {\n    return this.symbol;\n  }\n  getSourceInterval() {\n    if (this.symbol === null) {\n      return Interval.INVALID_INTERVAL;\n    }\n    const tokenIndex = this.symbol.tokenIndex;\n    return new Interval(tokenIndex, tokenIndex);\n  }\n  getChildCount() {\n    return 0;\n  }\n  accept(visitor) {\n    return visitor.visitTerminal(this);\n  }\n  getText() {\n    return this.symbol?.text ?? \"\";\n  }\n  toString() {\n    if (this.symbol?.type === Token.EOF) {\n      return \"<EOF>\";\n    } else {\n      return this.symbol?.text ?? \"\";\n    }\n  }\n  toStringTree() {\n    return this.toString();\n  }\n};\n\n// src/tree/ErrorNode.ts\nvar ErrorNode = class extends TerminalNode {\n  static {\n    __name(this, \"ErrorNode\");\n  }\n  accept(visitor) {\n    return visitor.visitErrorNode(this);\n  }\n};\n\n// src/CommonToken.ts\nvar CommonToken = class _CommonToken {\n  static {\n    __name(this, \"CommonToken\");\n  }\n  /**\n   * An empty tuple which is used as the default value of\n   * {@link source} for tokens that do not have a source.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static EMPTY_SOURCE = [null, null];\n  /**\n   * These properties share a field to reduce the memory footprint of\n   * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from\n   * the same source and input stream share a reference to the same\n   * {@link Pair} containing these values.\n   */\n  source;\n  tokenIndex;\n  start;\n  stop;\n  /**\n   * This is the backing field for {@link #getType} and {@link #setType}.\n   */\n  type;\n  /**\n   * The (one-based) line number on which the 1st character of this token was.\n   */\n  line;\n  /**\n   * The zero-based index of the first character position in its line.\n   */\n  column;\n  /**\n   * The token's channel.\n   */\n  channel;\n  /**\n   * This is the backing field for {@link getText} when the token text is\n   * explicitly set in the constructor or via {@link setText}.\n   */\n  #text;\n  constructor(details) {\n    this.type = details.type;\n    this.source = details.source;\n    this.tokenIndex = details.tokenIndex ?? -1;\n    this.line = details.line ?? 0;\n    this.column = details.column ?? -1;\n    this.channel = details.channel ?? Token.DEFAULT_CHANNEL;\n    this.start = details.start ?? 0;\n    this.stop = details.stop ?? 0;\n    this.#text = details.text;\n    if (details.line === void 0 && details.source[0] !== null) {\n      this.line = details.source[0].line;\n    }\n    if (details.column === void 0 && details.source[0] !== null) {\n      this.column = details.source[0].column;\n    }\n  }\n  /**\n   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n   *\n   * If `token` is also a {@link CommonToken} instance, the newly\n   * constructed token will share a reference to the {@link #text} field and\n   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will\n   * be assigned the result of calling {@link getText}, and {@link source}\n   * will be constructed from the result of {@link Token.getTokenSource} and\n   * {@link Token#getInputStream}.\n   *\n   * @param token The token to copy.\n   */\n  static fromToken(token) {\n    const source = [token.tokenSource, token.inputStream];\n    return new _CommonToken({\n      type: token.type,\n      line: token.line,\n      tokenIndex: token.tokenIndex,\n      column: token.column,\n      channel: token.channel,\n      start: token.start,\n      stop: token.stop,\n      text: token.text,\n      source\n    });\n  }\n  /**\n   * Constructs a new {@link CommonToken} with the specified token type and text.\n   *\n   * @param type The token type.\n   * @param text The text of the token.\n   */\n  static fromType(type, text) {\n    return new _CommonToken({ type, text, source: _CommonToken.EMPTY_SOURCE });\n  }\n  static fromSource(source, type, channel, start, stop) {\n    return new _CommonToken({ type, channel, start, stop, source });\n  }\n  get tokenSource() {\n    return this.source[0];\n  }\n  get inputStream() {\n    return this.source[1];\n  }\n  set inputStream(input) {\n    this.source[1] = input;\n  }\n  /**\n   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n   *\n   * If `oldToken` is also a {@link CommonToken} instance, the newly\n   * constructed token will share a reference to the {@link text} field and\n   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will\n   * be assigned the result of calling {@link getText}, and {@link source}\n   * will be constructed from the result of {@link Token.getTokenSource} and\n   * {@link Token.getInputStream}.\n   */\n  clone() {\n    const t = new _CommonToken({\n      source: this.source,\n      type: this.type,\n      channel: this.channel,\n      start: this.start,\n      stop: this.stop,\n      tokenIndex: this.tokenIndex,\n      line: this.line,\n      column: this.column,\n      text: this.#text\n    });\n    return t;\n  }\n  toString(recognizer) {\n    let channelStr = \"\";\n    if (this.channel > 0) {\n      channelStr = \",channel=\" + this.channel;\n    }\n    let text = this.text;\n    if (text) {\n      text = text.replace(/\\n/g, \"\\\\n\");\n      text = text.replace(/\\r/g, \"\\\\r\");\n      text = text.replace(/\\t/g, \"\\\\t\");\n    } else {\n      text = \"<no text>\";\n    }\n    let typeString = String(this.type);\n    if (recognizer) {\n      typeString = recognizer.vocabulary.getDisplayName(this.type) ?? \"<unknown>\";\n    }\n    return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + text + \"',<\" + typeString + \">\" + channelStr + \",\" + this.line + \":\" + this.column + \"]\";\n  }\n  get text() {\n    if (this.#text !== void 0) {\n      return this.#text;\n    }\n    const input = this.inputStream;\n    if (!input) {\n      return void 0;\n    }\n    const n2 = input.size;\n    if (this.start < n2 && this.stop < n2) {\n      return input.getTextFromRange(this.start, this.stop);\n    }\n    return \"<EOF>\";\n  }\n  set text(text) {\n    this.#text = text;\n  }\n  // WritableToken implementation\n  setText(text) {\n    this.#text = text;\n  }\n  setType(ttype) {\n    this.type = ttype;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharPositionInLine(pos) {\n    this.column = pos;\n  }\n  setChannel(channel) {\n    this.channel = channel;\n  }\n  setTokenIndex(index) {\n    this.tokenIndex = index;\n  }\n};\n\n// src/tree/Trees.ts\nvar Trees = class _Trees {\n  static {\n    __name(this, \"Trees\");\n  }\n  /**\n   * Print out a whole tree in LISP form. {@link getNodeText} is used on the\n   * node payloads to get the text for the nodes.  Detect\n   * parse trees and extract data appropriately.\n   */\n  static toStringTree(tree, ruleNames, recog) {\n    ruleNames = ruleNames ?? null;\n    if (recog) {\n      ruleNames = recog.ruleNames;\n    }\n    let s = _Trees.getNodeText(tree, ruleNames);\n    s = escapeWhitespace(s, false);\n    const c = tree.getChildCount();\n    if (c === 0) {\n      return s;\n    }\n    let res = \"(\" + s + \" \";\n    if (c > 0) {\n      s = _Trees.toStringTree(tree.getChild(0), ruleNames);\n      res = res.concat(s);\n    }\n    for (let i = 1; i < c; i++) {\n      s = _Trees.toStringTree(tree.getChild(i), ruleNames);\n      res = res.concat(\" \" + s);\n    }\n    res = res.concat(\")\");\n    return res;\n  }\n  static getNodeText(t, ruleNames, recog) {\n    ruleNames = ruleNames ?? null;\n    if (recog) {\n      ruleNames = recog.ruleNames;\n    }\n    if (ruleNames !== null) {\n      if (t instanceof ParserRuleContext) {\n        const context = t.ruleContext;\n        const altNumber = context.getAltNumber();\n        if (altNumber !== 0) {\n          return ruleNames[t.ruleIndex] + \":\" + altNumber;\n        }\n        return ruleNames[t.ruleIndex];\n      } else if (t instanceof ErrorNode) {\n        return t.toString();\n      } else if (t instanceof TerminalNode) {\n        return t.symbol.text;\n      }\n    }\n    const payload = t.getPayload();\n    if (isToken(payload)) {\n      return payload.text;\n    }\n    return String(t.getPayload());\n  }\n  /**\n   * Return ordered list of all children of this node\n   */\n  static getChildren(t) {\n    const list = [];\n    for (let i = 0; i < t.getChildCount(); i++) {\n      list.push(t.getChild(i));\n    }\n    return list;\n  }\n  /**\n   * Return a list of all ancestors of this node.  The first node of\n   * list is the root and the last is the parent of this node.\n   */\n  static getAncestors(t) {\n    if (t.parent === null) {\n      return [];\n    }\n    let ancestors = [];\n    let p = t.parent;\n    while (p !== null) {\n      ancestors = [p].concat(ancestors);\n      p = p.parent;\n    }\n    return ancestors;\n  }\n  /**\n   * Return true if t is u's parent or a node on path to root from u.\n   */\n  static isAncestorOf(t, u) {\n    if (t === null || u === null || t.parent === null) {\n      return false;\n    }\n    let p = u.parent;\n    while (p !== null) {\n      if (t === p) {\n        return true;\n      }\n      p = p.parent;\n    }\n    return false;\n  }\n  static findAllTokenNodes(t, ttype) {\n    return _Trees.findAllNodes(t, ttype, true);\n  }\n  static findAllRuleNodes(t, ruleIndex) {\n    return _Trees.findAllNodes(t, ruleIndex, false);\n  }\n  static findAllNodes(t, index, findTokens) {\n    const nodes = [];\n    _Trees.doFindAllNodes(t, index, findTokens, nodes);\n    return nodes;\n  }\n  static descendants(t) {\n    let nodes = [t];\n    for (let i = 0; i < t.getChildCount(); i++) {\n      nodes = nodes.concat(_Trees.descendants(t.getChild(i)));\n    }\n    return nodes;\n  }\n  /**\n   * Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex\n   * inclusively using post order traversal. Recursive depth-first-search.\n   */\n  static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {\n    const n2 = t.getChildCount();\n    for (let i = 0; i < n2; i++) {\n      const child = t.getChild(i);\n      const r = this.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\n      if (r !== null) {\n        return r;\n      }\n    }\n    if (t instanceof ParserRuleContext) {\n      if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?\n      (t.stop === null || stopTokenIndex <= t.stop.tokenIndex)) {\n        return t;\n      }\n    }\n    return null;\n  }\n  /**\n   * Replace any subtree siblings of root that are completely to left\n   * or right of lookahead range with a CommonToken(Token.INVALID_TYPE,\"...\")\n   * node. The source interval for t is not altered to suit smaller range!\n   *\n   * WARNING: destructive to t.\n   */\n  static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {\n    if (t === null) {\n      return;\n    }\n    for (let i = 0; i < t.getChildCount(); i++) {\n      const child = t.getChild(i);\n      const range = child.getSourceInterval();\n      if (t instanceof ParserRuleContext && (range.stop < startIndex || range.start > stopIndex)) {\n        if (this.isAncestorOf(child, root)) {\n          const abbrev = CommonToken.fromType(Token.INVALID_TYPE, \"...\");\n          t.children[i] = new TerminalNode(abbrev);\n        }\n      }\n    }\n  }\n  static doFindAllNodes(t, index, findTokens, nodes) {\n    if (findTokens && t instanceof TerminalNode) {\n      if (t.symbol?.type === index) {\n        nodes.push(t);\n      }\n    } else if (!findTokens && t instanceof ParserRuleContext) {\n      if (t.ruleIndex === index) {\n        nodes.push(t);\n      }\n    }\n    for (let i = 0; i < t.getChildCount(); i++) {\n      _Trees.doFindAllNodes(t.getChild(i), index, findTokens, nodes);\n    }\n  }\n};\n\n// src/ParserRuleContext.ts\nvar ParserRuleContext = class _ParserRuleContext {\n  static {\n    __name(this, \"ParserRuleContext\");\n  }\n  static empty = new _ParserRuleContext(null);\n  start = null;\n  stop = null;\n  children = [];\n  /**\n   * What state invoked the rule associated with this context?\n   *  The \"return address\" is the followState of invokingState\n   *  If parent is null, this should be -1 this context object represents\n   *  the start rule.\n   */\n  invokingState;\n  parent;\n  /**\n   * A rule context is a record of a single rule invocation. It knows\n   * which context invoked it, if any. If there is no parent context, then\n   * naturally the invoking state is not valid.  The parent link\n   * provides a chain upwards from the current rule invocation to the root\n   * of the invocation tree, forming a stack. We actually carry no\n   * information about the rule associated with this context (except\n   * when parsing). We keep only the state number of the invoking state from\n   * the ATN submachine that invoked this. Contrast this with the s\n   * pointer inside ParserRuleContext that tracks the current state\n   * being \"executed\" for the current rule.\n   *\n   * The parent contexts are useful for computing lookahead sets and\n   * getting error information.\n   *\n   * These objects are used during parsing and prediction.\n   * For the special case of parsers, we use the subclass\n   * ParserRuleContext.\n   */\n  constructor(parent, invokingStateNumber = -1) {\n    this.parent = parent;\n    this.invokingState = invokingStateNumber;\n  }\n  /** Copy a context */\n  copyFrom(ctx) {\n    this.parent = ctx.parent;\n    this.invokingState = ctx.invokingState;\n    this.children.slice(0, this.children.length);\n    this.start = ctx.start;\n    this.stop = ctx.stop;\n    if (ctx.children) {\n      ctx.children.forEach((child) => {\n        if (child instanceof ErrorNode) {\n          this.children.push(child);\n          child.parent = this;\n        }\n      });\n    }\n  }\n  // Double dispatch methods for listeners\n  enterRule(_listener) {\n  }\n  exitRule(_listener) {\n  }\n  addChild(child) {\n    this.children.push(child);\n    return child;\n  }\n  /**\n   * Used by enterOuterAlt to toss out a RuleContext previously added as\n   * we entered a rule. If we have label, we will need to remove\n   * generic ruleContext object.\n   */\n  removeLastChild() {\n    this.children.pop();\n  }\n  addTokenNode(token) {\n    const node = new TerminalNode(token);\n    this.children.push(node);\n    node.parent = this;\n    return node;\n  }\n  addErrorNode(errorNode) {\n    errorNode.parent = this;\n    this.children.push(errorNode);\n    return errorNode;\n  }\n  getChild(i, type) {\n    if (i < 0 || i >= this.children.length) {\n      return null;\n    }\n    if (!type) {\n      return this.children[i];\n    }\n    for (const child of this.children) {\n      if (child instanceof type) {\n        if (i === 0) {\n          return child;\n        } else {\n          i -= 1;\n        }\n      }\n    }\n    return null;\n  }\n  getToken(ttype, i) {\n    if (i < 0 || i >= this.children.length) {\n      return null;\n    }\n    for (const child of this.children) {\n      if (\"symbol\" in child) {\n        if (child.symbol?.type === ttype) {\n          if (i === 0) {\n            return child;\n          } else {\n            i -= 1;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  getTokens(ttype) {\n    const tokens = [];\n    for (const child of this.children) {\n      if (\"symbol\" in child) {\n        if (child.symbol?.type === ttype) {\n          tokens.push(child);\n        }\n      }\n    }\n    return tokens;\n  }\n  // XXX: base the child type selection on the rule index, not the class.\n  getRuleContext(index, ctxType) {\n    return this.getChild(index, ctxType);\n  }\n  // XXX: base the child type selection on the rule index, not the class.\n  getRuleContexts(ctxType) {\n    const contexts = [];\n    for (const child of this.children) {\n      if (child instanceof ctxType) {\n        contexts.push(child);\n      }\n    }\n    return contexts;\n  }\n  getChildCount() {\n    return this.children.length;\n  }\n  getSourceInterval() {\n    if (this.start === null) {\n      return Interval.INVALID_INTERVAL;\n    }\n    if (this.stop === null || this.stop.tokenIndex < this.start.tokenIndex) {\n      return new Interval(this.start.tokenIndex, this.start.tokenIndex - 1);\n    }\n    return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n  }\n  depth() {\n    let n2 = 0;\n    let p = this;\n    while (p !== null) {\n      p = p.parent;\n      n2 += 1;\n    }\n    return n2;\n  }\n  /**\n   * A context is empty if there is no invoking state; meaning nobody call\n   * current context.\n   */\n  isEmpty() {\n    return this.invokingState === -1;\n  }\n  get ruleContext() {\n    return this;\n  }\n  get ruleIndex() {\n    return -1;\n  }\n  getPayload() {\n    return this;\n  }\n  getText() {\n    if (this.children.length === 0) {\n      return \"\";\n    }\n    return this.children.map((child) => {\n      return child.getText();\n    }).join(\"\");\n  }\n  /**\n   * For rule associated with this parse tree internal node, return\n   * the outer alternative number used to match the input. Default\n   * implementation does not compute nor store this alt num. Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   * to set it.\n   */\n  getAltNumber() {\n    return ATN.INVALID_ALT_NUMBER;\n  }\n  /**\n   * Set the outer alternative number for this context node. Default\n   * implementation does nothing to avoid backing field overhead for\n   * trees that don't need it.  Create\n   * a subclass of ParserRuleContext with backing field and set\n   * option contextSuperClass.\n   */\n  setAltNumber(_altNumber) {\n  }\n  accept(visitor) {\n    return visitor.visitChildren(this);\n  }\n  toStringTree(...args) {\n    if (args.length < 2) {\n      return Trees.toStringTree(this, null, args[0]);\n    }\n    return Trees.toStringTree(this, args[0], args[1]);\n  }\n  toString(ruleNames, stop) {\n    ruleNames = ruleNames ?? null;\n    stop = stop ?? null;\n    let p = this;\n    let s = \"[\";\n    while (p !== null && p !== stop) {\n      if (ruleNames === null) {\n        if (!p.isEmpty()) {\n          s += p.invokingState;\n        }\n      } else {\n        const ri = p.ruleIndex;\n        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : \"\" + ri;\n        s += ruleName;\n      }\n      if (p.parent !== null && (ruleNames !== null || !p.parent.isEmpty())) {\n        s += \" \";\n      }\n      p = p.parent;\n    }\n    s += \"]\";\n    return s;\n  }\n};\n\n// src/atn/ArrayPredictionContext.ts\nvar ArrayPredictionContext = class _ArrayPredictionContext extends PredictionContext {\n  static {\n    __name(this, \"ArrayPredictionContext\");\n  }\n  parents = [];\n  returnStates = [];\n  constructor(parents, returnStates) {\n    super(PredictionContext.calculateHashCodeList(parents, returnStates));\n    this.parents = parents;\n    this.returnStates = returnStates;\n    return this;\n  }\n  isEmpty() {\n    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n  }\n  get length() {\n    return this.returnStates.length;\n  }\n  getParent(index) {\n    return this.parents[index];\n  }\n  getReturnState(index) {\n    return this.returnStates[index];\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _ArrayPredictionContext) || this.hashCode() !== other.hashCode()) {\n      return false;\n    }\n    return equalNumberArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);\n  }\n  toString() {\n    if (this.isEmpty()) {\n      return \"[]\";\n    }\n    const entries = [];\n    for (let i = 0; i < this.returnStates.length; i++) {\n      if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n        entries.push(\"$\");\n        continue;\n      }\n      entries.push(this.returnStates[i].toString());\n      if (this.parents[i]) {\n        entries.push(this.parents[i].toString());\n      } else {\n        entries.push(\"null\");\n      }\n    }\n    return `[${entries.join(\", \")}]`;\n  }\n};\n\n// src/atn/helpers.ts\nvar createSingletonPredictionContext = /* @__PURE__ */ __name((parent, returnState) => {\n  if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n    return EmptyPredictionContext.instance;\n  } else {\n    return new SingletonPredictionContext(parent, returnState);\n  }\n}, \"createSingletonPredictionContext\");\n\n// src/atn/PredictionContextUtils.ts\nvar predictionContextFromRuleContext = /* @__PURE__ */ __name((atn, outerContext) => {\n  if (!outerContext) {\n    outerContext = ParserRuleContext.empty;\n  }\n  if (!outerContext.parent || outerContext === ParserRuleContext.empty) {\n    return EmptyPredictionContext.instance;\n  }\n  const parent = predictionContextFromRuleContext(atn, outerContext.parent);\n  const state = atn.states[outerContext.invokingState];\n  const transition = state.transitions[0];\n  return createSingletonPredictionContext(parent, transition.followState.stateNumber);\n}, \"predictionContextFromRuleContext\");\nvar getCachedPredictionContext = /* @__PURE__ */ __name((context, contextCache, visited) => {\n  if (context.isEmpty()) {\n    return context;\n  }\n  let existing = visited.get(context);\n  if (existing) {\n    return existing;\n  }\n  existing = contextCache.get(context);\n  if (existing) {\n    visited.set(context, existing);\n    return existing;\n  }\n  let changed = false;\n  let parents = [];\n  for (let i = 0; i < parents.length; i++) {\n    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n    if (changed || parent !== context.getParent(i)) {\n      if (!changed) {\n        parents = [];\n        for (let j = 0; j < context.length; j++) {\n          parents[j] = context.getParent(j);\n        }\n        changed = true;\n      }\n      parents[i] = parent;\n    }\n  }\n  if (!changed) {\n    contextCache.add(context);\n    visited.set(context, context);\n    return context;\n  }\n  let updated;\n  if (parents.length === 0) {\n    updated = EmptyPredictionContext.instance;\n  } else if (parents.length === 1) {\n    updated = createSingletonPredictionContext(parents[0] ?? void 0, context.getReturnState(0));\n  } else {\n    updated = new ArrayPredictionContext(parents, context.returnStates);\n  }\n  contextCache.add(updated);\n  visited.set(updated, updated);\n  visited.set(context, updated);\n  return updated;\n}, \"getCachedPredictionContext\");\nvar merge = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {\n  if (a === b || a.equals(b)) {\n    return a;\n  }\n  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n    return mergeSingletons(a, b, rootIsWildcard, mergeCache);\n  }\n  if (rootIsWildcard) {\n    if (a instanceof EmptyPredictionContext) {\n      return a;\n    }\n    if (b instanceof EmptyPredictionContext) {\n      return b;\n    }\n  }\n  if (a instanceof SingletonPredictionContext) {\n    a = new ArrayPredictionContext([a.parent], [a.returnState]);\n  }\n  if (b instanceof SingletonPredictionContext) {\n    b = new ArrayPredictionContext([b.parent], [b.returnState]);\n  }\n  return mergeArrays(a, b, rootIsWildcard, mergeCache);\n}, \"merge\");\nvar mergeArrays = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {\n  if (mergeCache) {\n    let previous = mergeCache.get(a, b);\n    if (previous) {\n      return previous;\n    }\n    previous = mergeCache.get(b, a);\n    if (previous) {\n      return previous;\n    }\n  }\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let mergedReturnStates = new Array(a.returnStates.length + b.returnStates.length).fill(0);\n  let mergedParents = new Array(a.returnStates.length + b.returnStates.length).fill(null);\n  while (i < a.returnStates.length && j < b.returnStates.length) {\n    const aParent = a.parents[i];\n    const bParent = b.parents[j];\n    if (a.returnStates[i] === b.returnStates[j]) {\n      const payload = a.returnStates[i];\n      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && aParent === null && bParent === null;\n      const axAx = aParent !== null && bParent !== null && aParent === bParent;\n      if (bothDollars || axAx) {\n        mergedParents[k] = aParent;\n        mergedReturnStates[k] = payload;\n      } else {\n        mergedParents[k] = merge(aParent, bParent, rootIsWildcard, mergeCache);\n        mergedReturnStates[k] = payload;\n      }\n      i += 1;\n      j += 1;\n    } else if (a.returnStates[i] < b.returnStates[j]) {\n      mergedParents[k] = aParent;\n      mergedReturnStates[k] = a.returnStates[i];\n      i += 1;\n    } else {\n      mergedParents[k] = bParent;\n      mergedReturnStates[k] = b.returnStates[j];\n      j += 1;\n    }\n    k += 1;\n  }\n  if (i < a.returnStates.length) {\n    for (let p = i; p < a.returnStates.length; p++) {\n      mergedParents[k] = a.parents[p];\n      mergedReturnStates[k] = a.returnStates[p];\n      k += 1;\n    }\n  } else {\n    for (let p = j; p < b.returnStates.length; p++) {\n      mergedParents[k] = b.parents[p];\n      mergedReturnStates[k] = b.returnStates[p];\n      k += 1;\n    }\n  }\n  if (k < mergedParents.length) {\n    if (k === 1) {\n      const aNew = createSingletonPredictionContext(mergedParents[0] ?? void 0, mergedReturnStates[0]);\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, aNew);\n      }\n      return aNew;\n    }\n    mergedParents = mergedParents.slice(0, k);\n    mergedReturnStates = mergedReturnStates.slice(0, k);\n  }\n  const merged = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n  if (merged.equals(a)) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, a);\n    }\n    if (PredictionContext.traceATNSimulator) {\n      console.log(\"mergeArrays a=\" + a + \",b=\" + b + \" -> a\");\n    }\n    return a;\n  }\n  if (merged.equals(b)) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, b);\n    }\n    return b;\n  }\n  combineCommonParents(mergedParents);\n  if (mergeCache !== null) {\n    mergeCache.set(a, b, merged);\n  }\n  if (PredictionContext.traceATNSimulator) {\n    console.log(\"mergeArrays a=\" + a + \",b=\" + b + \" -> \" + merged);\n  }\n  return merged;\n}, \"mergeArrays\");\nvar combineCommonParents = /* @__PURE__ */ __name((parents) => {\n  const uniqueParents = new HashMap(ObjectEqualityComparator.instance);\n  for (const parent of parents) {\n    if (parent) {\n      if (!uniqueParents.containsKey(parent)) {\n        uniqueParents.set(parent, parent);\n      }\n    }\n  }\n  for (let q = 0; q < parents.length; q++) {\n    if (parents[q]) {\n      parents[q] = uniqueParents.get(parents[q]) ?? null;\n    }\n  }\n}, \"combineCommonParents\");\nvar mergeSingletons = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {\n  if (mergeCache !== null) {\n    let previous = mergeCache.get(a, b);\n    if (previous !== null) {\n      return previous;\n    }\n    previous = mergeCache.get(b, a);\n    if (previous !== null) {\n      return previous;\n    }\n  }\n  const rootMerge = mergeRoot(a, b, rootIsWildcard);\n  if (rootMerge !== null) {\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, rootMerge);\n    }\n    return rootMerge;\n  }\n  if (a.returnState === b.returnState) {\n    const parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);\n    if (parent === a.parent) {\n      return a;\n    }\n    if (parent === b.parent) {\n      return b;\n    }\n    const spc = createSingletonPredictionContext(parent, a.returnState);\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, spc);\n    }\n    return spc;\n  } else {\n    let singleParent = null;\n    if (a === b || a.parent !== null && a.parent.equals(b.parent)) {\n      singleParent = a.parent;\n    }\n    if (singleParent !== null) {\n      const payloads2 = [a.returnState, b.returnState];\n      if (a.returnState > b.returnState) {\n        payloads2[0] = b.returnState;\n        payloads2[1] = a.returnState;\n      }\n      const parents2 = [singleParent, singleParent];\n      const apc = new ArrayPredictionContext(parents2, payloads2);\n      if (mergeCache !== null) {\n        mergeCache.set(a, b, apc);\n      }\n      return apc;\n    }\n    const payloads = [a.returnState, b.returnState];\n    let parents = [a.parent, b.parent];\n    if (a.returnState > b.returnState) {\n      payloads[0] = b.returnState;\n      payloads[1] = a.returnState;\n      parents = [b.parent, a.parent];\n    }\n    const aNew = new ArrayPredictionContext(parents, payloads);\n    if (mergeCache !== null) {\n      mergeCache.set(a, b, aNew);\n    }\n    return aNew;\n  }\n}, \"mergeSingletons\");\nvar mergeRoot = /* @__PURE__ */ __name((a, b, rootIsWildcard) => {\n  if (rootIsWildcard) {\n    if (a === EmptyPredictionContext.instance || b === EmptyPredictionContext.instance) {\n      return EmptyPredictionContext.instance;\n    }\n  } else {\n    if (a === EmptyPredictionContext.instance && b === EmptyPredictionContext.instance) {\n      return EmptyPredictionContext.instance;\n    }\n    if (a === EmptyPredictionContext.instance) {\n      const payloads = [\n        b.returnState,\n        PredictionContext.EMPTY_RETURN_STATE\n      ];\n      const parents = [b.parent, null];\n      return new ArrayPredictionContext(parents, payloads);\n    }\n    if (b === EmptyPredictionContext.instance) {\n      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];\n      const parents = [a.parent, null];\n      return new ArrayPredictionContext(parents, payloads);\n    }\n  }\n  return null;\n}, \"mergeRoot\");\n\n// src/atn/LL1Analyzer.ts\nvar LL1Analyzer = class _LL1Analyzer {\n  constructor(atn) {\n    this.atn = atn;\n  }\n  static {\n    __name(this, \"LL1Analyzer\");\n  }\n  /**\n   * Special value added to the lookahead sets to indicate that we hit\n   * a predicate during analysis if `seeThruPreds==false`.\n   */\n  static hitPredicate = Token.INVALID_TYPE;\n  /**\n   * Calculates the SLL(1) expected lookahead set for each outgoing transition\n   * of an {@link ATNState}. The returned array has one element for each\n   * outgoing transition in `s`. If the closure from transition\n   * _i_ leads to a semantic predicate before matching a symbol, the\n   * element at index *i* of the result will be `undefined`.\n   *\n   * @param s the ATN state\n   * @returns the expected symbols for each outgoing transition of `s`.\n   */\n  getDecisionLookahead(s) {\n    const count = s.transitions.length;\n    const look = new Array(count);\n    for (let alt = 0; alt < count; alt++) {\n      const set = new IntervalSet();\n      const lookBusy = new HashSet();\n      this.doLook(\n        s.transitions[alt].target,\n        void 0,\n        EmptyPredictionContext.instance,\n        set,\n        lookBusy,\n        new BitSet(),\n        false,\n        false\n      );\n      if (set.length > 0 && !set.contains(_LL1Analyzer.hitPredicate)) {\n        look[alt] = set;\n      }\n    }\n    return look;\n  }\n  /**\n   * Compute set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   *\n   * If `ctx` is `null` and the end of the rule containing\n   * `s` is reached, {@link Token//EPSILON} is added to the result set.\n   * If `ctx` is not `null` and the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.\n   *\n   * @param s the ATN state\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx the complete parser context, or `null` if the context\n   * should be ignored\n   *\n   * @returns The set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   */\n  look(s, stopState, ctx) {\n    const r = new IntervalSet();\n    const lookContext = ctx ? predictionContextFromRuleContext(this.atn, ctx) : null;\n    this.doLook(s, stopState, lookContext, r, new HashSet(), new BitSet(), true, true);\n    return r;\n  }\n  /**\n   * Compute set of tokens that can follow `s` in the ATN in the\n   * specified `ctx`.\n   *\n   * If `ctx` is `null` and `stopState` or the end of the\n   * rule containing `s` is reached, {@link Token//EPSILON} is added to\n   * the result set. If `ctx` is not `null` and `addEOF` is\n   * `true` and `stopState` or the end of the outermost rule is\n   * reached, {@link Token//EOF} is added to the result set.\n   *\n   * @param s the ATN state.\n   * @param stopState the ATN state to stop at. This can be a\n   * {@link BlockEndState} to detect epsilon paths through a closure.\n   * @param ctx The outer context, or `null` if the outer context should\n   * not be used.\n   * @param look The result lookahead set.\n   * @param lookBusy A set used for preventing epsilon closures in the ATN\n   * from causing a stack overflow. Outside code should pass\n   * `new CustomizedSet<ATNConfig>` for this argument.\n   * @param calledRuleStack A set used for preventing left recursion in the\n   * ATN from causing a stack overflow. Outside code should pass\n   * `new BitSet()` for this argument.\n   * @param seeThruPreds `true` to true semantic predicates as\n   * implicitly `true` and \"see through them\", otherwise `false`\n   * to treat semantic predicates as opaque and add {@link hitPredicate} to the\n   * result if one is encountered.\n   * @param addEOF Add {@link Token//EOF} to the result if the end of the\n   * outermost context is reached. This parameter has no effect if `ctx`\n   * is `null`.\n   */\n  doLook(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n    const c = ATNConfig.createWithContext(s, 0, ctx);\n    if (lookBusy.get(c)) {\n      return;\n    }\n    lookBusy.add(c);\n    if (s === stopState) {\n      if (!ctx) {\n        look.addOne(Token.EPSILON);\n        return;\n      } else if (ctx.isEmpty() && addEOF) {\n        look.addOne(Token.EOF);\n        return;\n      }\n    }\n    if (s.constructor.stateType === ATNState.RULE_STOP) {\n      if (!ctx) {\n        look.addOne(Token.EPSILON);\n        return;\n      } else if (ctx.isEmpty() && addEOF) {\n        look.addOne(Token.EOF);\n        return;\n      }\n      if (ctx !== EmptyPredictionContext.instance) {\n        const removed = calledRuleStack.get(s.ruleIndex);\n        try {\n          calledRuleStack.clear(s.ruleIndex);\n          for (let i = 0; i < ctx.length; i++) {\n            const returnState = this.atn.states[ctx.getReturnState(i)];\n            this.doLook(\n              returnState,\n              stopState,\n              ctx.getParent(i),\n              look,\n              lookBusy,\n              calledRuleStack,\n              seeThruPreds,\n              addEOF\n            );\n          }\n        } finally {\n          if (removed) {\n            calledRuleStack.set(s.ruleIndex);\n          }\n        }\n        return;\n      }\n    }\n    for (const t of s.transitions) {\n      switch (t.transitionType) {\n        case Transition.RULE: {\n          if (calledRuleStack.get(t.target.ruleIndex)) {\n            continue;\n          }\n          const newContext = createSingletonPredictionContext(\n            ctx ?? void 0,\n            t.followState.stateNumber\n          );\n          try {\n            calledRuleStack.set(t.target.ruleIndex);\n            this.doLook(\n              t.target,\n              stopState,\n              newContext,\n              look,\n              lookBusy,\n              calledRuleStack,\n              seeThruPreds,\n              addEOF\n            );\n          } finally {\n            calledRuleStack.clear(t.target.ruleIndex);\n          }\n          break;\n        }\n        case Transition.PREDICATE:\n        case Transition.PRECEDENCE: {\n          if (seeThruPreds) {\n            this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } else {\n            look.addOne(_LL1Analyzer.hitPredicate);\n          }\n          break;\n        }\n        case Transition.WILDCARD: {\n          look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n          break;\n        }\n        default: {\n          if (t.isEpsilon) {\n            this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n          } else {\n            let set = t.label;\n            if (set) {\n              if (t instanceof NotSetTransition) {\n                set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n              }\n              look.addSet(set);\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n};\n\n// src/atn/ATN.ts\nvar ATN = class {\n  static {\n    __name(this, \"ATN\");\n  }\n  static INVALID_ALT_NUMBER = 0;\n  /** Represents the type of recognizer an ATN applies to */\n  static LEXER = 0;\n  static PARSER = 1;\n  /**\n   * Used for runtime deserialization of ATNs from strings\n   * The type of the ATN.\n   */\n  grammarType;\n  /** The maximum value for any symbol recognized by a transition in the ATN. */\n  maxTokenType;\n  states = [];\n  /**\n   * Each subrule/rule is a decision point and we must track them so we\n   * can go back later and build DFA predictors for them.  This includes\n   * all the rules, subrules, optional blocks, ()+, ()* etc...\n   */\n  decisionToState = [];\n  /** Maps from rule index to starting state number. */\n  ruleToStartState = [];\n  // Initialized by the ATN deserializer.\n  /** Maps from rule index to stop state number. */\n  ruleToStopState = [];\n  // Initialized by the ATN deserializer.\n  modeNameToStartState = /* @__PURE__ */ new Map();\n  /**\n   * For lexer ATNs, this maps the rule index to the resulting token type.\n   * For parser ATNs, this maps the rule index to the generated bypass token\n   * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n   * deserialization option was specified; otherwise, this is `null`\n   */\n  ruleToTokenType = [];\n  // Initialized by the ATN deserializer.\n  /**\n   * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n   * be referenced by action transitions in the ATN\n   */\n  lexerActions = [];\n  modeToStartState = [];\n  analyzer;\n  constructor(grammarType, maxTokenType) {\n    this.grammarType = grammarType;\n    this.maxTokenType = maxTokenType;\n    this.analyzer = new LL1Analyzer(this);\n  }\n  /**\n   * Compute the set of valid tokens that can occur starting in state `s`.\n   * If `ctx` is null, the set of tokens will not include what can follow\n   * the rule surrounding `s`. In other words, the set will be\n   * restricted to tokens reachable staying within `s`'s rule.\n   */\n  nextTokens(atnState, ctx) {\n    if (!ctx && atnState.nextTokenWithinRule) {\n      return atnState.nextTokenWithinRule;\n    }\n    const next = this.analyzer.look(atnState, void 0, ctx);\n    if (!ctx) {\n      atnState.nextTokenWithinRule = next;\n    }\n    return next;\n  }\n  addState(state) {\n    if (state) {\n      state.stateNumber = this.states.length;\n    }\n    this.states.push(state);\n  }\n  removeState(state) {\n    this.states[state.stateNumber] = null;\n  }\n  defineDecisionState(s) {\n    this.decisionToState.push(s);\n    s.decision = this.decisionToState.length - 1;\n    return s.decision;\n  }\n  getDecisionState(decision) {\n    if (this.decisionToState.length === 0) {\n      return null;\n    } else {\n      return this.decisionToState[decision];\n    }\n  }\n  getNumberOfDecisions() {\n    return this.decisionToState.length;\n  }\n  /**\n   * Computes the set of input symbols which could follow ATN state number\n   * `stateNumber` in the specified full `context`. This method\n   * considers the complete parser context, but does not evaluate semantic\n   * predicates (i.e. all predicates encountered during the calculation are\n   * assumed true). If a path in the ATN exists from the starting state to the\n   * {@link RuleStopState} of the outermost context without matching any\n   * symbols, {@link Token//EOF} is added to the returned set.\n   *\n   * If `context` is `null`, it is treated as\n   * {@link ParserRuleContext//EMPTY}.\n   *\n   * @param stateNumber the ATN state number\n   * @param context the full parse context\n   *\n   * @returns {IntervalSet} The set of potentially valid input symbols which could follow the\n   * specified state in the specified context.\n   *\n   * @throws IllegalArgumentException if the ATN does not contain a state with\n   * number `stateNumber`\n   */\n  getExpectedTokens(stateNumber, context) {\n    if (stateNumber < 0 || stateNumber >= this.states.length) {\n      throw new Error(\"Invalid state number.\");\n    }\n    const s = this.states[stateNumber];\n    let following = this.nextTokens(s);\n    if (!following.contains(Token.EPSILON)) {\n      return following;\n    }\n    let ctx = context;\n    const expected = new IntervalSet();\n    expected.addSet(following);\n    expected.removeOne(Token.EPSILON);\n    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n      const invokingState = this.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      following = this.nextTokens(rt.followState);\n      expected.addSet(following);\n      expected.removeOne(Token.EPSILON);\n      ctx = ctx.parent;\n    }\n    if (following.contains(Token.EPSILON)) {\n      expected.addOne(Token.EOF);\n    }\n    return expected;\n  }\n};\n\n// src/atn/ATNConfigSet.ts\nvar KeyTypeEqualityComparer = class _KeyTypeEqualityComparer {\n  static {\n    __name(this, \"KeyTypeEqualityComparer\");\n  }\n  static instance = new _KeyTypeEqualityComparer();\n  hashCode(config) {\n    let hashCode = 7;\n    hashCode = 31 * hashCode + config.state.stateNumber;\n    hashCode = 31 * hashCode + config.alt;\n    hashCode = 31 * hashCode + config.semanticContext.hashCode();\n    return hashCode;\n  }\n  equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    return a.state.stateNumber === b.state.stateNumber && a.alt === b.alt && a.semanticContext.equals(b.semanticContext);\n  }\n};\nvar ATNConfigSet = class {\n  static {\n    __name(this, \"ATNConfigSet\");\n  }\n  /**\n   * The reason that we need this is because we don't want the hash map to use\n   * the standard hash code and equals. We need all configurations with the\n   * same\n   * `(s,i,_,semctx)` to be equal. Unfortunately, this key effectively\n   * doubles\n   * the number of objects associated with ATNConfigs. The other solution is\n   * to\n   * use a hash table that lets us specify the equals/hashCode operation.\n   * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n   * when we go readonly as this set becomes a DFA state\n   */\n  configLookup = new HashSet(KeyTypeEqualityComparer.instance);\n  // Track the elements as they are added to the set; supports get(i).\n  configs = [];\n  uniqueAlt = 0;\n  /**\n   * Used in parser and lexer. In lexer, it indicates we hit a pred\n   * while computing a closure operation. Don't make a DFA state from this\n   */\n  hasSemanticContext = false;\n  dipsIntoOuterContext = false;\n  /**\n   * Indicates that this configuration set is part of a full context\n   * LL prediction. It will be used to determine how to merge $. With SLL\n   * it's a wildcard whereas it is not for LL context merge\n   */\n  fullCtx = false;\n  /**\n   * Indicates that the set of configurations is read-only. Do not\n   * allow any code to manipulate the set; DFA states will point at\n   * the sets and they must not change. This does not protect the other\n   * fields; in particular, conflictingAlts is set after\n   * we've made this readonly\n   */\n  readOnly = false;\n  conflictingAlts = null;\n  /**\n   * Tracks the first config that has a rule stop state. Avoids frequent linear search for that, when adding\n   * a DFA state in the lexer ATN simulator.\n   */\n  firstStopState;\n  #cachedHashCode = -1;\n  constructor(fullCtxOrOldSet) {\n    if (fullCtxOrOldSet !== void 0) {\n      if (typeof fullCtxOrOldSet === \"boolean\") {\n        this.fullCtx = fullCtxOrOldSet ?? true;\n      } else {\n        const old = fullCtxOrOldSet;\n        this.addAll(old.configs);\n        this.uniqueAlt = old.uniqueAlt;\n        this.conflictingAlts = old.conflictingAlts;\n        this.hasSemanticContext = old.hasSemanticContext;\n        this.dipsIntoOuterContext = old.dipsIntoOuterContext;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.configs[Symbol.iterator]();\n  }\n  /**\n   * Adding a new config means merging contexts with existing configs for\n   * `(s, i, pi, _)`, where `s` is the {@link ATNConfig.state}, `i` is the {@link ATNConfig.alt}, and\n   * `pi` is the {@link ATNConfig.semanticContext}. We use `(s,i,pi)` as key.\n   *\n   * This method updates {@link dipsIntoOuterContext} and\n   * {@link hasSemanticContext} when necessary.\n   */\n  add(config, mergeCache = null) {\n    if (this.readOnly) {\n      throw new Error(\"This set is readonly\");\n    }\n    if (!this.firstStopState && config.state.constructor.stateType === ATNState.RULE_STOP) {\n      this.firstStopState = config;\n    }\n    this.hasSemanticContext ||= config.semanticContext !== SemanticContext.NONE;\n    this.dipsIntoOuterContext ||= config.reachesIntoOuterContext;\n    const existing = this.configLookup.getOrAdd(config);\n    if (existing === config) {\n      this.#cachedHashCode = -1;\n      this.configs.push(config);\n      return;\n    }\n    const rootIsWildcard = !this.fullCtx;\n    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n    existing.reachesIntoOuterContext ||= config.reachesIntoOuterContext;\n    existing.precedenceFilterSuppressed ||= config.precedenceFilterSuppressed;\n    existing.context = merged;\n  }\n  /** Return a List holding list of configs */\n  get elements() {\n    return this.configs;\n  }\n  /**\n   * Gets the complete set of represented alternatives for the configuration set.\n   *\n   * @returns the set of represented alternatives in this configuration set\n   */\n  getAlts() {\n    const alts = new BitSet();\n    for (const config of this.configs) {\n      alts.set(config.alt);\n    }\n    return alts;\n  }\n  getPredicates() {\n    const preds = [];\n    for (const config of this.configs) {\n      if (config.semanticContext !== SemanticContext.NONE) {\n        preds.push(config.semanticContext);\n      }\n    }\n    return preds;\n  }\n  getStates() {\n    const states = new HashSet();\n    for (const config of this.configs) {\n      states.add(config.state);\n    }\n    return states;\n  }\n  optimizeConfigs(interpreter) {\n    if (this.readOnly) {\n      throw new Error(\"This set is readonly\");\n    }\n    if (this.configLookup.size === 0) {\n      return;\n    }\n    for (const config of this.configs) {\n      config.context = interpreter.getCachedContext(config.context);\n    }\n  }\n  addAll(coll) {\n    for (const config of coll) {\n      this.add(config);\n    }\n    return false;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext && equalArrays(this.configs, other.configs)) {\n      return true;\n    }\n    return false;\n  }\n  hashCode() {\n    if (this.#cachedHashCode === -1) {\n      this.#cachedHashCode = this.computeHashCode();\n    }\n    return this.#cachedHashCode;\n  }\n  get length() {\n    return this.configs.length;\n  }\n  isEmpty() {\n    return this.configs.length === 0;\n  }\n  contains(item) {\n    if (this.configLookup === null) {\n      throw new Error(\"This method is not implemented for readonly sets.\");\n    }\n    return this.configLookup.contains(item);\n  }\n  containsFast(item) {\n    if (this.configLookup === null) {\n      throw new Error(\"This method is not implemented for readonly sets.\");\n    }\n    return this.configLookup.contains(item);\n  }\n  clear() {\n    if (this.readOnly) {\n      throw new Error(\"This set is readonly\");\n    }\n    this.configs = [];\n    this.#cachedHashCode = -1;\n    this.configLookup = new HashSet(KeyTypeEqualityComparer.instance);\n  }\n  setReadonly(readOnly) {\n    this.readOnly = readOnly;\n    if (readOnly) {\n      this.configLookup = null;\n    }\n  }\n  toString() {\n    return arrayToString(this.configs) + (this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") + (this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") + (this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n  }\n  computeHashCode() {\n    let hash = MurmurHash.initialize();\n    this.configs.forEach((config) => {\n      hash = MurmurHash.update(hash, config.hashCode());\n    });\n    hash = MurmurHash.finish(hash, this.configs.length);\n    return hash;\n  }\n};\n\n// src/atn/BasicState.ts\nvar BasicState = class extends ATNState {\n  static {\n    __name(this, \"BasicState\");\n  }\n  static stateType = ATNState.BASIC;\n};\n\n// src/atn/DecisionState.ts\nvar DecisionState = class extends ATNState {\n  static {\n    __name(this, \"DecisionState\");\n  }\n  decision = -1;\n  nonGreedy = false;\n};\n\n// src/atn/BlockStartState.ts\nvar BlockStartState = class extends DecisionState {\n  static {\n    __name(this, \"BlockStartState\");\n  }\n  endState;\n};\n\n// src/atn/BlockEndState.ts\nvar BlockEndState = class extends ATNState {\n  static {\n    __name(this, \"BlockEndState\");\n  }\n  static stateType = ATNState.BLOCK_END;\n  startState;\n};\n\n// src/atn/LoopEndState.ts\nvar LoopEndState = class extends ATNState {\n  static {\n    __name(this, \"LoopEndState\");\n  }\n  static stateType = ATNState.LOOP_END;\n  loopBackState;\n};\n\n// src/atn/RuleStartState.ts\nvar RuleStartState = class extends ATNState {\n  static {\n    __name(this, \"RuleStartState\");\n  }\n  static stateType = ATNState.RULE_START;\n  stopState;\n  isLeftRecursiveRule = false;\n};\n\n// src/atn/RuleStopState.ts\nvar RuleStopState = class extends ATNState {\n  static {\n    __name(this, \"RuleStopState\");\n  }\n  static stateType = ATNState.RULE_STOP;\n};\n\n// src/atn/TokensStartState.ts\nvar TokensStartState = class extends DecisionState {\n  static {\n    __name(this, \"TokensStartState\");\n  }\n  static stateType = ATNState.TOKEN_START;\n};\n\n// src/atn/PlusLoopbackState.ts\nvar PlusLoopbackState = class extends DecisionState {\n  static {\n    __name(this, \"PlusLoopbackState\");\n  }\n  static stateType = ATNState.PLUS_LOOP_BACK;\n};\n\n// src/atn/StarLoopbackState.ts\nvar StarLoopbackState = class extends ATNState {\n  static {\n    __name(this, \"StarLoopbackState\");\n  }\n  static stateType = ATNState.STAR_LOOP_BACK;\n};\n\n// src/atn/StarLoopEntryState.ts\nvar StarLoopEntryState = class extends DecisionState {\n  static {\n    __name(this, \"StarLoopEntryState\");\n  }\n  static stateType = ATNState.STAR_LOOP_ENTRY;\n  // This is always set during ATN deserialization\n  loopBackState;\n  /**\n   * Indicates whether this state can benefit from a precedence DFA during SLL\n   * decision making.\n   *\n   * This is a computed property that is calculated during ATN deserialization\n   * and stored for use in {@link ParserATNSimulator} and\n   * {@link ParserInterpreter}.\n   *\n   * @see `DFA.isPrecedenceDfa`\n   */\n  precedenceRuleDecision = false;\n};\n\n// src/atn/PlusBlockStartState.ts\nvar PlusBlockStartState = class extends BlockStartState {\n  static {\n    __name(this, \"PlusBlockStartState\");\n  }\n  static stateType = ATNState.PLUS_BLOCK_START;\n  loopBackState;\n};\n\n// src/atn/StarBlockStartState.ts\nvar StarBlockStartState = class extends BlockStartState {\n  static {\n    __name(this, \"StarBlockStartState\");\n  }\n  static stateType = ATNState.STAR_BLOCK_START;\n};\n\n// src/atn/BasicBlockStartState.ts\nvar BasicBlockStartState = class extends BlockStartState {\n  static {\n    __name(this, \"BasicBlockStartState\");\n  }\n  static stateType = ATNState.BLOCK_START;\n};\n\n// src/atn/AtomTransition.ts\nvar AtomTransition = class extends Transition {\n  static {\n    __name(this, \"AtomTransition\");\n  }\n  /** The token type or character value; or, signifies special label. */\n  labelValue;\n  #label;\n  constructor(target, label) {\n    super(target);\n    this.labelValue = label;\n    this.#label = IntervalSet.of(label, label);\n  }\n  get label() {\n    return this.#label;\n  }\n  get transitionType() {\n    return Transition.ATOM;\n  }\n  matches(symbol) {\n    return this.labelValue === symbol;\n  }\n  toString() {\n    return this.labelValue.toString();\n  }\n};\n\n// src/atn/RuleTransition.ts\nvar RuleTransition = class extends Transition {\n  static {\n    __name(this, \"RuleTransition\");\n  }\n  ruleIndex;\n  precedence;\n  followState;\n  constructor(ruleStart, ruleIndex, precedence, followState) {\n    super(ruleStart);\n    this.ruleIndex = ruleIndex;\n    this.precedence = precedence;\n    this.followState = followState;\n  }\n  get isEpsilon() {\n    return true;\n  }\n  get transitionType() {\n    return Transition.RULE;\n  }\n  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return false;\n  }\n};\n\n// src/atn/RangeTransition.ts\nvar RangeTransition = class extends Transition {\n  static {\n    __name(this, \"RangeTransition\");\n  }\n  start;\n  stop;\n  #label = new IntervalSet();\n  constructor(target, start, stop) {\n    super(target);\n    this.start = start;\n    this.stop = stop;\n    this.#label.addRange(start, stop);\n  }\n  get label() {\n    return this.#label;\n  }\n  get transitionType() {\n    return Transition.RANGE;\n  }\n  matches(symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return symbol >= this.start && symbol <= this.stop;\n  }\n  toString() {\n    return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n  }\n};\n\n// src/atn/ActionTransition.ts\nvar ActionTransition = class extends Transition {\n  static {\n    __name(this, \"ActionTransition\");\n  }\n  ruleIndex;\n  actionIndex;\n  isCtxDependent;\n  constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n    super(target);\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex ?? -1;\n    this.isCtxDependent = isCtxDependent ?? false;\n  }\n  get isEpsilon() {\n    return true;\n  }\n  get transitionType() {\n    return Transition.ACTION;\n  }\n  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return false;\n  }\n  toString() {\n    return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n  }\n};\n\n// src/atn/EpsilonTransition.ts\nvar EpsilonTransition = class extends Transition {\n  static {\n    __name(this, \"EpsilonTransition\");\n  }\n  #outermostPrecedenceReturn;\n  constructor(target, outermostPrecedenceReturn = -1) {\n    super(target);\n    this.#outermostPrecedenceReturn = outermostPrecedenceReturn;\n  }\n  /**\n   * @returns the rule index of a precedence rule for which this transition is\n   * returning from, where the precedence value is 0; otherwise, -1.\n   *\n   * @see ATNConfig.isPrecedenceFilterSuppressed()\n   * @see ParserATNSimulator.applyPrecedenceFilter(ATNConfigSet)\n   * @since 4.4.1\n   */\n  get outermostPrecedenceReturn() {\n    return this.#outermostPrecedenceReturn;\n  }\n  get isEpsilon() {\n    return true;\n  }\n  get transitionType() {\n    return Transition.EPSILON;\n  }\n  matches() {\n    return false;\n  }\n  toString() {\n    return \"epsilon\";\n  }\n};\n\n// src/atn/WildcardTransition.ts\nvar WildcardTransition = class extends Transition {\n  static {\n    __name(this, \"WildcardTransition\");\n  }\n  get transitionType() {\n    return Transition.WILDCARD;\n  }\n  matches(symbol, minVocabSymbol, maxVocabSymbol) {\n    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n  }\n  toString() {\n    return \".\";\n  }\n};\n\n// src/atn/AbstractPredicateTransition.ts\nvar AbstractPredicateTransition = class extends Transition {\n  static {\n    __name(this, \"AbstractPredicateTransition\");\n  }\n  constructor(target) {\n    super(target);\n  }\n};\n\n// src/atn/PredicateTransition.ts\nvar PredicateTransition = class extends AbstractPredicateTransition {\n  static {\n    __name(this, \"PredicateTransition\");\n  }\n  ruleIndex;\n  predIndex;\n  isCtxDependent;\n  // e.g., $i ref in pred\n  constructor(target, ruleIndex, predIndex, isCtxDependent) {\n    super(target);\n    this.ruleIndex = ruleIndex;\n    this.predIndex = predIndex;\n    this.isCtxDependent = isCtxDependent;\n  }\n  get isEpsilon() {\n    return true;\n  }\n  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return false;\n  }\n  get transitionType() {\n    return Transition.PREDICATE;\n  }\n  getPredicate() {\n    return new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n  }\n  toString() {\n    return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n  }\n};\n\n// src/atn/PrecedencePredicateTransition.ts\nvar PrecedencePredicateTransition = class extends AbstractPredicateTransition {\n  static {\n    __name(this, \"PrecedencePredicateTransition\");\n  }\n  precedence;\n  constructor(target, precedence) {\n    super(target);\n    this.precedence = precedence;\n  }\n  get isEpsilon() {\n    return true;\n  }\n  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {\n    return false;\n  }\n  getPredicate() {\n    return new SemanticContext.PrecedencePredicate(this.precedence);\n  }\n  get transitionType() {\n    return Transition.PRECEDENCE;\n  }\n  toString() {\n    return this.precedence + \" >= _p\";\n  }\n};\n\n// src/atn/LexerActionType.ts\nvar LexerActionType = {\n  /** The type of a {@link LexerChannelAction} action. */\n  CHANNEL: 0,\n  /** The type of a {@link LexerCustomAction} action */\n  CUSTOM: 1,\n  /** The type of a {@link LexerModeAction} action. */\n  MODE: 2,\n  /** The type of a {@link LexerMoreAction} action. */\n  MORE: 3,\n  /** The type of a {@link LexerPopModeAction} action. */\n  POP_MODE: 4,\n  /** The type of a {@link LexerPushModeAction} action. */\n  PUSH_MODE: 5,\n  /** The type of a {@link LexerSkipAction} action. */\n  SKIP: 6,\n  /** The type of a {@link LexerTypeAction} action. */\n  TYPE: 7\n};\n\n// src/atn/LexerSkipAction.ts\nvar LexerSkipAction = class _LexerSkipAction {\n  static {\n    __name(this, \"LexerSkipAction\");\n  }\n  /** Provides a singleton instance of this parameter-less lexer action. */\n  static instance = new _LexerSkipAction();\n  actionType;\n  isPositionDependent = false;\n  constructor() {\n    this.actionType = LexerActionType.SKIP;\n  }\n  equals(obj) {\n    return obj === this;\n  }\n  hashCode() {\n    return LexerActionType.SKIP;\n  }\n  execute(lexer) {\n    lexer.skip();\n  }\n  toString() {\n    return \"skip\";\n  }\n};\n\n// src/atn/LexerChannelAction.ts\nvar LexerChannelAction = class _LexerChannelAction {\n  static {\n    __name(this, \"LexerChannelAction\");\n  }\n  channel;\n  actionType;\n  isPositionDependent = false;\n  cachedHashCode;\n  constructor(channel) {\n    this.actionType = LexerActionType.CHANNEL;\n    this.channel = channel;\n  }\n  /**\n   * This action is implemented by calling {@link Lexer.setChannel} with the\n   * value provided by {@link getChannel}.\n   */\n  execute(lexer) {\n    lexer.channel = this.channel;\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash.update(hash, this.channel);\n      this.cachedHashCode = MurmurHash.finish(hash, 2);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerChannelAction)) {\n      return false;\n    }\n    return this.channel === other.channel;\n  }\n  toString() {\n    return \"channel(\" + this.channel + \")\";\n  }\n};\n\n// src/atn/LexerCustomAction.ts\nvar LexerCustomAction = class _LexerCustomAction {\n  static {\n    __name(this, \"LexerCustomAction\");\n  }\n  ruleIndex;\n  actionIndex;\n  actionType;\n  isPositionDependent = true;\n  cachedHashCode;\n  /**\n   * Constructs a custom lexer action with the specified rule and action indexes.\n   *\n   * @param ruleIndex The rule index to use for calls to {@link Recognizer.action}.\n   * @param actionIndex The action index to use for calls to {@link Recognizer.action}.\n   */\n  constructor(ruleIndex, actionIndex) {\n    this.actionType = LexerActionType.CUSTOM;\n    this.ruleIndex = ruleIndex;\n    this.actionIndex = actionIndex;\n  }\n  /**\n   * Custom actions are implemented by calling {@link Lexer.action} with the\n   * appropriate rule and action indexes.\n   */\n  execute(lexer) {\n    lexer.action(null, this.ruleIndex, this.actionIndex);\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash.update(hash, this.ruleIndex);\n      hash = MurmurHash.update(hash, this.actionIndex);\n      this.cachedHashCode = MurmurHash.finish(hash, 3);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerCustomAction)) {\n      return false;\n    }\n    return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n  }\n};\n\n// src/atn/LexerMoreAction.ts\nvar LexerMoreAction = class _LexerMoreAction {\n  static {\n    __name(this, \"LexerMoreAction\");\n  }\n  static instance = new _LexerMoreAction();\n  actionType;\n  isPositionDependent = false;\n  constructor() {\n    this.actionType = LexerActionType.MORE;\n  }\n  equals(obj) {\n    return obj === this;\n  }\n  hashCode() {\n    return LexerActionType.MORE;\n  }\n  /**\n   * This action is implemented by calling {@link Lexer.popMode}.\n   */\n  execute(lexer) {\n    lexer.more();\n  }\n  toString() {\n    return \"more\";\n  }\n};\n\n// src/atn/LexerTypeAction.ts\nvar LexerTypeAction = class _LexerTypeAction {\n  static {\n    __name(this, \"LexerTypeAction\");\n  }\n  type;\n  actionType;\n  isPositionDependent = false;\n  cachedHashCode;\n  constructor(type) {\n    this.actionType = LexerActionType.TYPE;\n    this.type = type;\n  }\n  execute(lexer) {\n    lexer.type = this.type;\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash.update(hash, this.type);\n      this.cachedHashCode = MurmurHash.finish(hash, 2);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerTypeAction)) {\n      return false;\n    }\n    return this.type === other.type;\n  }\n  toString() {\n    return \"type(\" + this.type + \")\";\n  }\n};\n\n// src/atn/LexerPushModeAction.ts\nvar LexerPushModeAction = class _LexerPushModeAction {\n  static {\n    __name(this, \"LexerPushModeAction\");\n  }\n  mode;\n  actionType;\n  isPositionDependent = false;\n  cachedHashCode;\n  constructor(mode) {\n    this.actionType = LexerActionType.PUSH_MODE;\n    this.mode = mode;\n  }\n  /**\n   * This action is implemented by calling {@link Lexer.pushMode} with the\n   * value provided by {@link getMode}.\n   */\n  execute(lexer) {\n    lexer.pushMode(this.mode);\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash.update(hash, this.mode);\n      this.cachedHashCode = MurmurHash.finish(hash, 2);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerPushModeAction)) {\n      return false;\n    }\n    return this.mode === other.mode;\n  }\n  toString() {\n    return \"pushMode(\" + this.mode + \")\";\n  }\n};\n\n// src/atn/LexerPopModeAction.ts\nvar LexerPopModeAction = class _LexerPopModeAction {\n  static {\n    __name(this, \"LexerPopModeAction\");\n  }\n  static instance = new _LexerPopModeAction();\n  actionType;\n  isPositionDependent = false;\n  constructor() {\n    this.actionType = LexerActionType.POP_MODE;\n  }\n  equals(obj) {\n    return obj === this;\n  }\n  hashCode() {\n    return LexerActionType.POP_MODE;\n  }\n  /**\n   * This action is implemented by calling {@link Lexer//popMode}.\n   */\n  execute(lexer) {\n    lexer.popMode();\n  }\n  toString() {\n    return \"popMode\";\n  }\n};\n\n// src/atn/LexerModeAction.ts\nvar LexerModeAction = class _LexerModeAction {\n  static {\n    __name(this, \"LexerModeAction\");\n  }\n  mode;\n  actionType;\n  isPositionDependent = false;\n  cachedHashCode;\n  constructor(mode) {\n    this.actionType = LexerActionType.MODE;\n    this.mode = mode;\n  }\n  /**\n   * This action is implemented by calling {@link Lexer.mode} with the\n   * value provided by {@link getMode}.\n   */\n  execute(lexer) {\n    lexer.mode = this.mode;\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.actionType);\n      hash = MurmurHash.update(hash, this.mode);\n      this.cachedHashCode = MurmurHash.finish(hash, 2);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerModeAction)) {\n      return false;\n    }\n    return this.mode === other.mode;\n  }\n  toString() {\n    return \"mode(\" + this.mode + \")\";\n  }\n};\n\n// src/atn/ATNDeserializer.ts\nvar ATNDeserializer = class _ATNDeserializer {\n  static {\n    __name(this, \"ATNDeserializer\");\n  }\n  static SERIALIZED_VERSION = 4;\n  static stateTypeMapper = /* @__PURE__ */ new Map([\n    [ATNState.INVALID_TYPE, void 0],\n    [ATNState.BASIC, BasicState],\n    [ATNState.RULE_START, RuleStartState],\n    [ATNState.BLOCK_START, BasicBlockStartState],\n    [ATNState.PLUS_BLOCK_START, PlusBlockStartState],\n    [ATNState.STAR_BLOCK_START, StarBlockStartState],\n    [ATNState.TOKEN_START, TokensStartState],\n    [ATNState.RULE_STOP, RuleStopState],\n    [ATNState.BLOCK_END, BlockEndState],\n    [ATNState.STAR_LOOP_BACK, StarLoopbackState],\n    [ATNState.STAR_LOOP_ENTRY, StarLoopEntryState],\n    [ATNState.PLUS_LOOP_BACK, PlusLoopbackState],\n    [ATNState.LOOP_END, LoopEndState]\n  ]);\n  static lexerActionFactoryMapper = /* @__PURE__ */ new Map([\n    [LexerActionType.CHANNEL, (data1) => {\n      return new LexerChannelAction(data1);\n    }],\n    [LexerActionType.CUSTOM, (data1, data2) => {\n      return new LexerCustomAction(data1, data2);\n    }],\n    [LexerActionType.MODE, (data1) => {\n      return new LexerModeAction(data1);\n    }],\n    [LexerActionType.MORE, () => {\n      return LexerMoreAction.instance;\n    }],\n    [LexerActionType.POP_MODE, () => {\n      return LexerPopModeAction.instance;\n    }],\n    [LexerActionType.PUSH_MODE, (data1) => {\n      return new LexerPushModeAction(data1);\n    }],\n    [LexerActionType.SKIP, () => {\n      return LexerSkipAction.instance;\n    }],\n    [LexerActionType.TYPE, (data1) => {\n      return new LexerTypeAction(data1);\n    }]\n  ]);\n  data = [];\n  pos = 0;\n  deserializationOptions;\n  actionFactories;\n  constructor(options) {\n    if (!options) {\n      options = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: false };\n    }\n    this.deserializationOptions = options;\n  }\n  deserialize(data) {\n    this.data = data;\n    this.checkVersion();\n    const atn = this.readATN();\n    this.readStates(atn);\n    this.readRules(atn);\n    this.readModes(atn);\n    const sets = [];\n    this.readSets(atn, sets);\n    this.readEdges(atn, sets);\n    this.readDecisions(atn);\n    this.readLexerActions(atn);\n    this.markPrecedenceDecisions(atn);\n    this.verifyATN(atn);\n    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATN.PARSER) {\n      this.generateRuleBypassTransitions(atn);\n      this.verifyATN(atn);\n    }\n    return atn;\n  }\n  checkVersion() {\n    const version = this.data[this.pos++];\n    if (version !== _ATNDeserializer.SERIALIZED_VERSION) {\n      throw new Error(\"Could not deserialize ATN with version \" + version + \" (expected \" + _ATNDeserializer.SERIALIZED_VERSION + \").\");\n    }\n  }\n  readATN() {\n    const grammarType = this.data[this.pos++];\n    const maxTokenType = this.data[this.pos++];\n    return new ATN(grammarType, maxTokenType);\n  }\n  readStates(atn) {\n    let j;\n    let stateNumber;\n    const loopBackStateNumbers = [];\n    const endStateNumbers = [];\n    const stateCount = this.data[this.pos++];\n    for (let i = 0; i < stateCount; i++) {\n      const stateType = this.data[this.pos++];\n      if (stateType === ATNState.INVALID_TYPE) {\n        atn.addState(null);\n        continue;\n      }\n      const ruleIndex = this.data[this.pos++];\n      const s = this.stateFactory(stateType, ruleIndex);\n      if (stateType === ATNState.LOOP_END) {\n        const loopBackStateNumber = this.data[this.pos++];\n        loopBackStateNumbers.push([s, loopBackStateNumber]);\n      } else if (s instanceof BlockStartState) {\n        const endStateNumber = this.data[this.pos++];\n        endStateNumbers.push([s, endStateNumber]);\n      }\n      atn.addState(s);\n    }\n    for (j = 0; j < loopBackStateNumbers.length; j++) {\n      const pair = loopBackStateNumbers[j];\n      pair[0].loopBackState = atn.states[pair[1]] ?? void 0;\n    }\n    for (j = 0; j < endStateNumbers.length; j++) {\n      const pair = endStateNumbers[j];\n      pair[0].endState = atn.states[pair[1]];\n    }\n    const numNonGreedyStates = this.data[this.pos++];\n    for (j = 0; j < numNonGreedyStates; j++) {\n      stateNumber = this.data[this.pos++];\n      atn.states[stateNumber].nonGreedy = true;\n    }\n    const numPrecedenceStates = this.data[this.pos++];\n    for (j = 0; j < numPrecedenceStates; j++) {\n      stateNumber = this.data[this.pos++];\n      atn.states[stateNumber].isLeftRecursiveRule = true;\n    }\n  }\n  readRules(atn) {\n    let i;\n    const ruleCount = this.data[this.pos++];\n    if (atn.grammarType === ATN.LEXER) {\n      atn.ruleToTokenType = new Array(ruleCount);\n      atn.ruleToTokenType.fill(0);\n    }\n    atn.ruleToStartState = new Array(ruleCount);\n    atn.ruleToStartState.fill(null);\n    for (i = 0; i < ruleCount; i++) {\n      const s = this.data[this.pos++];\n      atn.ruleToStartState[i] = atn.states[s];\n      if (atn.grammarType === ATN.LEXER) {\n        const tokenType = this.data[this.pos++];\n        atn.ruleToTokenType[i] = tokenType;\n      }\n    }\n    atn.ruleToStopState = new Array(ruleCount);\n    atn.ruleToStopState.fill(null);\n    for (i = 0; i < atn.states.length; i++) {\n      const state = atn.states[i];\n      if (!(state instanceof RuleStopState)) {\n        continue;\n      }\n      atn.ruleToStopState[state.ruleIndex] = state;\n      atn.ruleToStartState[state.ruleIndex].stopState = state;\n    }\n  }\n  readModes(atn) {\n    const modeCount = this.data[this.pos++];\n    for (let i = 0; i < modeCount; i++) {\n      const s = this.data[this.pos++];\n      atn.modeToStartState.push(atn.states[s]);\n    }\n  }\n  readSets(atn, sets) {\n    const m2 = this.data[this.pos++];\n    for (let i = 0; i < m2; i++) {\n      const intervalSet = new IntervalSet();\n      sets.push(intervalSet);\n      const n2 = this.data[this.pos++];\n      const containsEof = this.data[this.pos++];\n      if (containsEof !== 0) {\n        intervalSet.addOne(-1);\n      }\n      for (let j = 0; j < n2; j++) {\n        const i1 = this.data[this.pos++];\n        const i2 = this.data[this.pos++];\n        intervalSet.addRange(i1, i2);\n      }\n    }\n  }\n  readEdges(atn, sets) {\n    let i;\n    let j;\n    let state;\n    let trans;\n    let target;\n    const edgeCount = this.data[this.pos++];\n    for (i = 0; i < edgeCount; i++) {\n      const src = this.data[this.pos++];\n      const trg = this.data[this.pos++];\n      const ttype = this.data[this.pos++];\n      const arg1 = this.data[this.pos++];\n      const arg2 = this.data[this.pos++];\n      const arg3 = this.data[this.pos++];\n      trans = this.edgeFactory(atn, ttype, trg, arg1, arg2, arg3, sets);\n      const srcState = atn.states[src];\n      srcState.addTransition(trans);\n    }\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n      for (j = 0; j < state.transitions.length; j++) {\n        const t = state.transitions[j];\n        if (!(t instanceof RuleTransition)) {\n          continue;\n        }\n        let outermostPrecedenceReturn = -1;\n        if (atn.ruleToStartState[t.target.ruleIndex].isLeftRecursiveRule) {\n          if (t.precedence === 0) {\n            outermostPrecedenceReturn = t.target.ruleIndex;\n          }\n        }\n        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n        atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n      }\n    }\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n      if (state instanceof BlockStartState) {\n        if (!state.endState) {\n          throw new Error(\"IllegalState\");\n        }\n        if (state.endState.startState) {\n          throw new Error(\"IllegalState\");\n        }\n        state.endState.startState = state;\n      }\n      if (state instanceof PlusLoopbackState) {\n        for (j = 0; j < state.transitions.length; j++) {\n          target = state.transitions[j].target;\n          if (target instanceof PlusBlockStartState) {\n            target.loopBackState = state;\n          }\n        }\n      } else if (state instanceof StarLoopbackState) {\n        for (j = 0; j < state.transitions.length; j++) {\n          target = state.transitions[j].target;\n          if (target instanceof StarLoopEntryState) {\n            target.loopBackState = state;\n          }\n        }\n      }\n    }\n  }\n  readDecisions(atn) {\n    const decisionCount = this.data[this.pos++];\n    for (let i = 0; i < decisionCount; i++) {\n      const s = this.data[this.pos++];\n      const decState = atn.states[s];\n      atn.decisionToState.push(decState);\n      decState.decision = i;\n    }\n  }\n  readLexerActions(atn) {\n    if (atn.grammarType === ATN.LEXER) {\n      const count = this.data[this.pos++];\n      atn.lexerActions = [];\n      for (let i = 0; i < count; i++) {\n        const actionType = this.data[this.pos++];\n        const data1 = this.data[this.pos++];\n        const data2 = this.data[this.pos++];\n        atn.lexerActions.push(this.lexerActionFactory(actionType, data1, data2));\n      }\n    }\n  }\n  generateRuleBypassTransitions(atn) {\n    let i;\n    const count = atn.ruleToStartState.length;\n    for (i = 0; i < count; i++) {\n      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n    }\n    for (i = 0; i < count; i++) {\n      this.generateRuleBypassTransition(atn, i);\n    }\n  }\n  generateRuleBypassTransition(atn, idx) {\n    let i;\n    let state;\n    const bypassStart = new BasicBlockStartState();\n    bypassStart.ruleIndex = idx;\n    atn.addState(bypassStart);\n    const bypassStop = new BlockEndState();\n    bypassStop.ruleIndex = idx;\n    atn.addState(bypassStop);\n    bypassStart.endState = bypassStop;\n    atn.defineDecisionState(bypassStart);\n    bypassStop.startState = bypassStart;\n    let excludeTransition = null;\n    let endState = null;\n    if (atn.ruleToStartState[idx].isLeftRecursiveRule) {\n      endState = null;\n      for (i = 0; i < atn.states.length; i++) {\n        state = atn.states[i];\n        if (this.stateIsEndStateFor(state, idx)) {\n          endState = state;\n          excludeTransition = state.loopBackState.transitions[0];\n          break;\n        }\n      }\n      if (excludeTransition === null) {\n        throw new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\n      }\n    } else {\n      endState = atn.ruleToStopState[idx];\n    }\n    for (i = 0; i < atn.states.length; i++) {\n      state = atn.states[i];\n      for (const transition of state.transitions) {\n        if (transition === excludeTransition) {\n          continue;\n        }\n        if (transition.target === endState) {\n          transition.target = bypassStop;\n        }\n      }\n    }\n    const ruleToStartState = atn.ruleToStartState[idx];\n    while (ruleToStartState.transitions.length > 0) {\n      const transition = ruleToStartState.removeTransition(ruleToStartState.transitions.length - 1);\n      bypassStart.addTransition(transition);\n    }\n    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n    if (endState) {\n      bypassStop.addTransition(new EpsilonTransition(endState));\n    }\n    const matchState = new BasicState();\n    atn.addState(matchState);\n    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n    bypassStart.addTransition(new EpsilonTransition(matchState));\n  }\n  stateIsEndStateFor(state, idx) {\n    if (state.ruleIndex !== idx) {\n      return null;\n    }\n    if (!(state instanceof StarLoopEntryState)) {\n      return null;\n    }\n    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n    if (!(maybeLoopEndState instanceof LoopEndState)) {\n      return null;\n    }\n    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n      return state;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n   * the {@link StarLoopEntryState} field to the correct value.\n   *\n   * @param atn The ATN.\n   */\n  markPrecedenceDecisions(atn) {\n    for (const state of atn.states) {\n      if (!(state instanceof StarLoopEntryState)) {\n        continue;\n      }\n      if (atn.ruleToStartState[state.ruleIndex].isLeftRecursiveRule) {\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (maybeLoopEndState instanceof LoopEndState) {\n          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {\n            state.precedenceRuleDecision = true;\n          }\n        }\n      }\n    }\n  }\n  verifyATN(atn) {\n    if (!this.deserializationOptions.verifyATN) {\n      return;\n    }\n    for (const state of atn.states) {\n      if (state === null) {\n        continue;\n      }\n      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n      if (state instanceof PlusBlockStartState) {\n        this.checkCondition(state.loopBackState !== null);\n      } else if (state instanceof StarLoopEntryState) {\n        this.checkCondition(state.loopBackState !== null);\n        this.checkCondition(state.transitions.length === 2);\n        if (state.transitions[0].target instanceof StarBlockStartState) {\n          this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n          this.checkCondition(!state.nonGreedy);\n        } else if (state.transitions[0].target instanceof LoopEndState) {\n          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n          this.checkCondition(state.nonGreedy);\n        } else {\n          throw new Error(\"IllegalState\");\n        }\n      } else if (state instanceof StarLoopbackState) {\n        this.checkCondition(state.transitions.length === 1);\n        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n      } else if (state instanceof LoopEndState) {\n        this.checkCondition(state.loopBackState !== null);\n      } else if (state instanceof RuleStartState) {\n        this.checkCondition(state.stopState !== null);\n      } else if (state instanceof BlockStartState) {\n        this.checkCondition(state.endState !== null);\n      } else if (state instanceof BlockEndState) {\n        this.checkCondition(state.startState !== null);\n      } else if (state instanceof DecisionState) {\n        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n      } else {\n        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);\n      }\n    }\n  }\n  checkCondition(condition, message) {\n    if (!condition) {\n      if (message === void 0 || message === null) {\n        message = \"IllegalState\";\n      }\n      throw message;\n    }\n  }\n  edgeFactory(atn, type, trg, arg1, arg2, arg3, sets) {\n    const target = atn.states[trg];\n    switch (type) {\n      case Transition.EPSILON:\n        return new EpsilonTransition(target);\n      case Transition.RANGE:\n        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n      case Transition.RULE:\n        return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n      case Transition.PREDICATE:\n        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n      case Transition.PRECEDENCE:\n        return new PrecedencePredicateTransition(target, arg1);\n      case Transition.ATOM:\n        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n      case Transition.ACTION:\n        return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n      case Transition.SET:\n        return new SetTransition(target, sets[arg1]);\n      case Transition.NOT_SET:\n        return new NotSetTransition(target, sets[arg1]);\n      case Transition.WILDCARD:\n        return new WildcardTransition(target);\n      default:\n        throw new Error(\"The specified transition type: \" + type + \" is not valid.\");\n    }\n  }\n  stateFactory(type, ruleIndex) {\n    const ctor = _ATNDeserializer.stateTypeMapper.get(type);\n    if (!ctor) {\n      throw new Error(\"The specified state type \" + type + \" is not valid.\");\n    }\n    const s = new ctor();\n    s.ruleIndex = ruleIndex;\n    return s;\n  }\n  lexerActionFactory(type, data1, data2) {\n    const factory = _ATNDeserializer.lexerActionFactoryMapper.get(type);\n    if (!factory) {\n      throw new Error(\"The specified lexer action type \" + type + \" is not valid.\");\n    }\n    return factory(data1, data2);\n  }\n};\n\n// src/misc/OrderedHashMap.ts\nvar OrderedHashMap = class _OrderedHashMap extends HashMap {\n  static {\n    __name(this, \"OrderedHashMap\");\n  }\n  #keys = [];\n  clear() {\n    super.clear();\n    this.#keys = [];\n  }\n  get(key) {\n    return super.get(key);\n  }\n  set(key, value) {\n    const result = super.set(key, value);\n    if (result === void 0) {\n      this.#keys.push(key);\n    }\n    return result;\n  }\n  setIfAbsent(key, value) {\n    const result = super.setIfAbsent(key, value);\n    if (result === void 0) {\n      this.#keys.push(key);\n    }\n    return result;\n  }\n  /**\n   * @returns an iterable of the values in the map, in the order they were inserted.\n   */\n  values() {\n    return {\n      [Symbol.iterator]: () => {\n        let index = 0;\n        return {\n          next: /* @__PURE__ */ __name(() => {\n            if (index < this.#keys.length) {\n              return {\n                done: false,\n                value: super.get(this.#keys[index++])\n              };\n            }\n            return {\n              done: true,\n              value: void 0\n            };\n          }, \"next\")\n        };\n      }\n    };\n  }\n  /**\n   * @returns an iterable of the keys in the map, in the order they were inserted.\n   */\n  keys() {\n    return this.#keys[Symbol.iterator]();\n  }\n  equals(o) {\n    if (!(o instanceof _OrderedHashMap)) {\n      return false;\n    }\n    return super.equals(o);\n  }\n};\n\n// src/atn/ATNSerializer.ts\nvar ATNSerializer = class _ATNSerializer {\n  static {\n    __name(this, \"ATNSerializer\");\n  }\n  atn;\n  data = [];\n  // Note that we use a LinkedHashMap as a set to maintain insertion order while deduplicating entries with the\n  // same key.\n  sets = new OrderedHashMap(ObjectEqualityComparator.instance);\n  nonGreedyStates = [];\n  precedenceStates = [];\n  constructor(atn) {\n    this.atn = atn;\n  }\n  static getSerialized(atn) {\n    return new _ATNSerializer(atn).serialize();\n  }\n  static serializeSets(data, sets) {\n    data.push(sets.length);\n    for (const set of sets) {\n      const containsEof = set.contains(Token.EOF);\n      const intervals = [...set];\n      if (containsEof && intervals[0].stop === Token.EOF) {\n        data.push(intervals.length - 1);\n      } else {\n        data.push(intervals.length);\n      }\n      data.push(containsEof ? 1 : 0);\n      for (const interval of intervals) {\n        if (interval.start === Token.EOF) {\n          if (interval.stop === Token.EOF) {\n            continue;\n          } else {\n            data.push(0);\n          }\n        } else {\n          data.push(interval.start);\n        }\n        data.push(interval.stop);\n      }\n    }\n  }\n  /**\n   * Serialize state descriptors, edge descriptors, and decision -> state map\n   *  into list of ints.  Likely out of date, but keeping as it could be helpful:\n   *\n   *      SERIALIZED_VERSION\n   *      UUID (2 longs)\n   * \t\tgrammar-type, (ANTLRParser.LEXER, ...)\n   *  \tmax token type,\n   *  \tnum states,\n   *  \tstate-0-type ruleIndex, state-1-type ruleIndex, ... state-i-type ruleIndex optional-arg ...\n   *  \tnum rules,\n   *  \trule-1-start-state rule-1-args, rule-2-start-state  rule-2-args, ...\n   *  \t(args are token type,actionIndex in lexer else 0,0)\n   *      num modes,\n   *      mode-0-start-state, mode-1-start-state, ... (parser has 0 modes)\n   *      num unicode-bmp-sets\n   *      bmp-set-0-interval-count intervals, bmp-set-1-interval-count intervals, ...\n   *      num unicode-smp-sets\n   *      smp-set-0-interval-count intervals, smp-set-1-interval-count intervals, ...\n   *\tnum total edges,\n   *      src, trg, edge-type, edge arg1, optional edge arg2 (present always), ...\n   *      num decisions,\n   *      decision-0-start-state, decision-1-start-state, ...\n   *\n   *  Convenient to pack into unsigned shorts to make as Java string.\n   */\n  serialize() {\n    this.addPreamble();\n    const edgeCount = this.addEdges();\n    this.addNonGreedyStates();\n    this.addPrecedenceStates();\n    this.addRuleStatesAndLexerTokenTypes();\n    this.addModeStartStates();\n    const setIndices = this.addSets();\n    this.addEdges(edgeCount, setIndices);\n    this.addDecisionStartStates();\n    this.addLexerActions();\n    return this.data;\n  }\n  addPreamble() {\n    this.data.push(ATNDeserializer.SERIALIZED_VERSION);\n    this.data.push(this.atn.grammarType);\n    this.data.push(this.atn.maxTokenType);\n  }\n  addLexerActions() {\n    if (this.atn.grammarType === ATN.LEXER) {\n      this.data.push(this.atn.lexerActions.length);\n      for (const action of this.atn.lexerActions) {\n        this.data.push(action.actionType);\n        switch (action.actionType) {\n          case LexerActionType.CHANNEL: {\n            const channel = action.channel;\n            this.data.push(channel);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.CUSTOM: {\n            const ruleIndex = action.ruleIndex;\n            const actionIndex = action.actionIndex;\n            this.data.push(ruleIndex);\n            this.data.push(actionIndex);\n            break;\n          }\n          case LexerActionType.MODE: {\n            const mode = action.mode;\n            this.data.push(mode);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.MORE: {\n            this.data.push(0);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.POP_MODE: {\n            this.data.push(0);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.PUSH_MODE: {\n            const mode = action.mode;\n            this.data.push(mode);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.SKIP: {\n            this.data.push(0);\n            this.data.push(0);\n            break;\n          }\n          case LexerActionType.TYPE: {\n            const type = action.type;\n            this.data.push(type);\n            this.data.push(0);\n            break;\n          }\n          default: {\n            throw new Error(`The specified lexer action type ${action.actionType} is not valid.`);\n          }\n        }\n      }\n    }\n  }\n  addDecisionStartStates() {\n    this.data.push(this.atn.decisionToState.length);\n    for (const decStartState of this.atn.decisionToState) {\n      this.data.push(decStartState.stateNumber);\n    }\n  }\n  addEdges(...args) {\n    switch (args.length) {\n      case 0: {\n        let edgeCount = 0;\n        this.data.push(this.atn.states.length);\n        for (const s of this.atn.states) {\n          if (s === null) {\n            this.data.push(ATNState.INVALID_TYPE);\n            continue;\n          }\n          const stateType = s.constructor.stateType;\n          if (s instanceof DecisionState && s.nonGreedy) {\n            this.nonGreedyStates.push(s.stateNumber);\n          }\n          if (s instanceof RuleStartState && s.isLeftRecursiveRule) {\n            this.precedenceStates.push(s.stateNumber);\n          }\n          this.data.push(stateType);\n          this.data.push(s.ruleIndex);\n          if (s.constructor.stateType === ATNState.LOOP_END) {\n            this.data.push(s.loopBackState.stateNumber);\n          } else {\n            if (s instanceof BlockStartState) {\n              this.data.push(s.endState.stateNumber);\n            }\n          }\n          if (s.constructor.stateType !== ATNState.RULE_STOP) {\n            edgeCount += s.transitions.length;\n          }\n          for (const t of s.transitions) {\n            const edgeType = t.transitionType;\n            if (edgeType === Transition.SET || edgeType === Transition.NOT_SET) {\n              const st = t;\n              this.sets.set(st.set, true);\n            }\n          }\n        }\n        return edgeCount;\n      }\n      case 2: {\n        const [edgeCount, setIndices] = args;\n        this.data.push(edgeCount);\n        for (const s of this.atn.states) {\n          if (s === null) {\n            continue;\n          }\n          if (s.constructor.stateType === ATNState.RULE_STOP) {\n            continue;\n          }\n          for (const t of s.transitions) {\n            if (this.atn.states[t.target.stateNumber] === null) {\n              throw new Error(\"Cannot serialize a transition to a removed state.\");\n            }\n            const src = s.stateNumber;\n            let trg = t.target.stateNumber;\n            const edgeType = t.transitionType;\n            let arg1 = 0;\n            let arg2 = 0;\n            let arg3 = 0;\n            switch (edgeType) {\n              case Transition.RULE: {\n                trg = t.followState.stateNumber;\n                arg1 = t.target.stateNumber;\n                arg2 = t.ruleIndex;\n                arg3 = t.precedence;\n                break;\n              }\n              case Transition.PRECEDENCE: {\n                const ppt = t;\n                arg1 = ppt.precedence;\n                break;\n              }\n              case Transition.PREDICATE: {\n                const pt = t;\n                arg1 = pt.ruleIndex;\n                arg2 = pt.predIndex;\n                arg3 = pt.isCtxDependent ? 1 : 0;\n                break;\n              }\n              case Transition.RANGE: {\n                arg1 = t.start;\n                arg2 = t.stop;\n                if (arg1 === Token.EOF) {\n                  arg1 = 0;\n                  arg3 = 1;\n                }\n                break;\n              }\n              case Transition.ATOM: {\n                arg1 = t.labelValue;\n                if (arg1 === Token.EOF) {\n                  arg1 = 0;\n                  arg3 = 1;\n                }\n                break;\n              }\n              case Transition.ACTION: {\n                const at = t;\n                arg1 = at.ruleIndex;\n                arg2 = at.actionIndex;\n                arg3 = at.isCtxDependent ? 1 : 0;\n                break;\n              }\n              case Transition.SET: {\n                arg1 = setIndices.get(t.set);\n                break;\n              }\n              case Transition.NOT_SET: {\n                arg1 = setIndices.get(t.set);\n                break;\n              }\n              case Transition.WILDCARD: {\n                break;\n              }\n              default:\n            }\n            this.data.push(src);\n            this.data.push(trg);\n            this.data.push(edgeType);\n            this.data.push(arg1);\n            this.data.push(arg2);\n            this.data.push(arg3);\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(\"Invalid number of arguments\");\n      }\n    }\n  }\n  addSets() {\n    _ATNSerializer.serializeSets(this.data, [...this.sets.keys()]);\n    const setIndices = new HashMap();\n    let setIndex = 0;\n    for (const s of this.sets.keys()) {\n      setIndices.set(s, setIndex++);\n    }\n    return setIndices;\n  }\n  addModeStartStates() {\n    const modeCount = this.atn.modeToStartState.length;\n    this.data.push(modeCount);\n    if (modeCount > 0) {\n      for (const modeStartState of this.atn.modeToStartState) {\n        this.data.push(modeStartState.stateNumber);\n      }\n    }\n  }\n  addRuleStatesAndLexerTokenTypes() {\n    const ruleCount = this.atn.ruleToStartState.length;\n    this.data.push(ruleCount);\n    for (let r = 0; r < ruleCount; r++) {\n      const ruleStartState = this.atn.ruleToStartState[r];\n      this.data.push(ruleStartState.stateNumber);\n      if (this.atn.grammarType === ATN.LEXER) {\n        this.data.push(this.atn.ruleToTokenType[r]);\n      }\n    }\n  }\n  addPrecedenceStates() {\n    this.data.push(this.precedenceStates.length);\n    for (const state of this.precedenceStates) {\n      this.data.push(state);\n    }\n  }\n  addNonGreedyStates() {\n    this.data.push(this.nonGreedyStates.length);\n    for (const state of this.nonGreedyStates) {\n      this.data.push(state);\n    }\n  }\n};\n\n// src/dfa/DFAState.ts\nvar DFAState = class _DFAState {\n  static {\n    __name(this, \"DFAState\");\n  }\n  stateNumber = -1;\n  configs;\n  /**\n   * `edges[symbol]` points to target of symbol. Shift up by 1 so (-1) {@link Token.EOF} maps to `edges[0]`.\n   */\n  edges = [];\n  isAcceptState = false;\n  /**\n   * If accept state, what ttype do we match or alt do we predict? This is set to {@link ATN.INVALID_ALT_NUMBER}\n   * when {@link predicates} `!= null` or {@link requiresFullContext}.\n   */\n  prediction = -1;\n  lexerActionExecutor = null;\n  /**\n   * Indicates that this state was created during SLL prediction that discovered a conflict between the configurations\n   * in the state. Future {@link ParserATNSimulator.execATN} invocations immediately jumped doing\n   * full context prediction if this field is true.\n   */\n  requiresFullContext = false;\n  /**\n   * During SLL parsing, this is a list of predicates associated with the ATN configurations of the DFA state.\n   * When we have predicates, {@link requiresFullContext} is `false` since full context prediction evaluates\n   * predicates on-the-fly. If this is not null, then {@link prediction} is `ATN.INVALID_ALT_NUMBER`.\n   *\n   * We only use these for non-{@link #requiresFullContext} but conflicting states. That\n   * means we know from the context (it's $ or we don't dip into outer\n   * context) that it's an ambiguity not a conflict.\n   *\n   * This list is computed by {@link ParserATNSimulator#predicateDFAState}.\n   */\n  predicates = null;\n  constructor(configs) {\n    if (configs) {\n      this.configs = configs;\n    }\n  }\n  static fromState(stateNumber) {\n    const result = new _DFAState();\n    result.stateNumber = stateNumber;\n    return result;\n  }\n  static fromConfigs(configs) {\n    return new _DFAState(configs);\n  }\n  static hashCode(state) {\n    return state.configs.hashCode();\n  }\n  /**\n   * Two {@link DFAState} instances are equal if their ATN configuration sets\n   * are the same. This method is used to see if a state already exists.\n   *\n   * Because the number of alternatives and number of ATN configurations are\n   * finite, there is a finite number of DFA states that can be processed.\n   * This is necessary to show that the algorithm terminates.\n   *\n   * Cannot test the DFA state numbers here because in\n   * {@link ParserATNSimulator#addDFAState} we need to know if any other state\n   * exists that has this exact set of ATN configurations. The\n   * {@link #stateNumber} is irrelevant.\n   *\n   * @param a The first {@link DFAState}.\n   * @param b The second {@link DFAState}.\n   *\n   * @returns `true` if the two states are equal, otherwise `false`.\n   */\n  static equals(a, b) {\n    return a.configs.equals(b.configs);\n  }\n  /**\n   * @returns the set of all alts mentioned by all ATN configurations in this DFA state.\n   */\n  getAltSet() {\n    const alts = /* @__PURE__ */ new Set();\n    for (const config of this.configs) {\n      alts.add(config.alt);\n    }\n    if (alts.size === 0) {\n      return null;\n    }\n    return alts;\n  }\n  toString() {\n    let buf = \"\";\n    buf += this.stateNumber;\n    buf += \":\";\n    buf += this.configs ? this.configs.toString() : \"\";\n    if (this.isAcceptState) {\n      buf += \"=>\";\n      if (this.predicates) {\n        buf += arrayToString(this.predicates);\n      } else {\n        buf += this.prediction;\n      }\n    }\n    return buf.toString();\n  }\n};\n\n// src/atn/ATNSimulator.ts\nvar ATNSimulator = class {\n  static {\n    __name(this, \"ATNSimulator\");\n  }\n  /** Must distinguish between missing edge and edge we know leads nowhere */\n  static ERROR = DFAState.fromState(2147483647);\n  atn;\n  /**\n   * The context cache maps all PredictionContext objects that are ==\n   * to a single cached copy. This cache is shared across all contexts\n   * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n   * to use only cached nodes/graphs in addDFAState(). We don't want to\n   * fill this during closure() since there are lots of contexts that\n   * pop up but are not used ever again. It also greatly slows down closure().\n   *\n   * This cache makes a huge difference in memory and a little bit in speed.\n   * For the Java grammar on java.*, it dropped the memory requirements\n   * at the end from 25M to 16M. We don't store any of the full context\n   * graphs in the DFA because they are limited to local context only,\n   * but apparently there's a lot of repetition there as well. We optimize\n   * the config contexts before storing the config set in the DFA states\n   * by literally rebuilding them with cached subgraphs only.\n   *\n   * I tried a cache for use during closure operations, that was\n   * whacked after each adaptivePredict(). It cost a little bit\n   * more time I think and doesn't save on the overall footprint\n   * so it's not worth the complexity.\n   */\n  sharedContextCache;\n  constructor(atn, sharedContextCache) {\n    this.atn = atn;\n    this.sharedContextCache = sharedContextCache;\n    return this;\n  }\n  getCachedContext(context) {\n    if (!this.sharedContextCache) {\n      return context;\n    }\n    const visited = new HashMap(ObjectEqualityComparator.instance);\n    return getCachedPredictionContext(context, this.sharedContextCache, visited);\n  }\n};\n\n// src/atn/CodePointTransitions.ts\nvar CodePointTransitions = class _CodePointTransitions {\n  static {\n    __name(this, \"CodePointTransitions\");\n  }\n  /** @returns new {@link AtomTransition}     */\n  static createWithCodePoint(target, codePoint) {\n    return _CodePointTransitions.createWithCodePointRange(target, codePoint, codePoint);\n  }\n  /** @returns new {@link AtomTransition} if range represents one atom else {@link SetTransition}. */\n  static createWithCodePointRange(target, codePointFrom, codePointTo) {\n    return codePointFrom === codePointTo ? new AtomTransition(target, codePointFrom) : new RangeTransition(target, codePointFrom, codePointTo);\n  }\n};\n\n// src/atn/DecisionInfo.ts\nvar DecisionInfo = class {\n  static {\n    __name(this, \"DecisionInfo\");\n  }\n  /**\n   * The decision number, which is an index into {@link ATN.decisionToState}.\n   */\n  decision = 0;\n  /**\n   * The total number of times {@link ParserATNSimulator.adaptivePredict} was\n   * invoked for this decision.\n   */\n  invocations = 0;\n  /**\n   * The total time spent in {@link ParserATNSimulator.adaptivePredict} for\n   * this decision, in nanoseconds.\n   *\n   * The value of this field contains the sum of differential results obtained\n   * by {@link process.hrtime()}, and is not adjusted to compensate for JIT\n   * and/or garbage collection overhead. For best accuracy, use a modern Node.js\n   * version that provides precise results from {@link process.hrtime()}, and\n   * perform profiling in a separate process which is warmed up by parsing the\n   * input prior to profiling.\n   */\n  timeInPrediction = 0;\n  /**\n   * The sum of the lookahead required for SLL prediction for this decision.\n   * Note that SLL prediction is used before LL prediction for performance\n   * reasons even when {@link PredictionMode.LL} or\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION} is used.\n   */\n  sllTotalLook = 0;\n  /**\n   * Gets the minimum lookahead required for any single SLL prediction to\n   * complete for this decision, by reaching a unique prediction, reaching an\n   * SLL conflict state, or encountering a syntax error.\n   */\n  sllMinLook = 0;\n  /**\n   * Gets the maximum lookahead required for any single SLL prediction to\n   * complete for this decision, by reaching a unique prediction, reaching an\n   * SLL conflict state, or encountering a syntax error.\n   */\n  sllMaxLook = 0;\n  /**\n   * Gets the {@link LookaheadEventInfo} associated with the event where the\n   * {@link sllMaxLook} value was set.\n   */\n  sllMaxLookEvent;\n  /**\n   * The sum of the lookahead required for LL prediction for this decision.\n   * Note that LL prediction is only used when SLL prediction reaches a\n   * conflict state.\n   */\n  llTotalLook = 0;\n  /**\n   * Gets the minimum lookahead required for any single LL prediction to\n   * complete for this decision. An LL prediction completes when the algorithm\n   * reaches a unique prediction, a conflict state (for\n   * {@link PredictionMode.LL}, an ambiguity state (for\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n   */\n  llMinLook = 0;\n  /**\n   * Gets the maximum lookahead required for any single LL prediction to\n   * complete for this decision. An LL prediction completes when the algorithm\n   * reaches a unique prediction, a conflict state (for\n   * {@link PredictionMode.LL}, an ambiguity state (for\n   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n   */\n  llMaxLook = 0;\n  /**\n   * Gets the {@link LookaheadEventInfo} associated with the event where the\n   * {@link llMaxLook} value was set.\n   */\n  llMaxLookEvent;\n  /**\n   * A collection of {@link ContextSensitivityInfo} instances describing the\n   * context sensitivities encountered during LL prediction for this decision.\n   */\n  contextSensitivities;\n  /**\n   * A collection of {@link DecisionEventInfo} instances describing the parse errors\n   * identified during calls to {@link ParserATNSimulator.adaptivePredict} for\n   * this decision.\n   */\n  errors;\n  /**\n   * A collection of {@link AmbiguityInfo} instances describing the\n   * ambiguities encountered during LL prediction for this decision.\n   */\n  ambiguities;\n  /**\n   * A collection of {@link PredicateEvalInfo} instances describing the\n   * results of evaluating individual predicates during prediction for this\n   * decision.\n   */\n  predicateEvals;\n  /**\n   * The total number of ATN transitions required during SLL prediction for\n   * this decision. An ATN transition is determined by the number of times the\n   * DFA does not contain an edge that is required for prediction, resulting\n   * in on-the-fly computation of that edge.\n  /**\n   * If DFA caching of SLL transitions is employed by the implementation, ATN\n   * computation may cache the computed edge for efficient lookup during\n   * future parsing of this decision. Otherwise, the SLL parsing algorithm\n   * will use ATN transitions exclusively.\n   *\n   * @see sllDFATransitions\n   * @see ParserATNSimulator.computeTargetState\n   * @see LexerATNSimulator.computeTargetState\n   */\n  sllATNTransitions = 0;\n  /**\n   * The total number of DFA transitions required during SLL prediction for\n   * this decision.\n   *\n   * If the ATN simulator implementation does not use DFA caching for SLL\n   * transitions, this value will be 0.\n   *\n   * @see ParserATNSimulator.getExistingTargetState\n   * @see LexerATNSimulator.getExistingTargetState\n   */\n  sllDFATransitions = 0;\n  /**\n   * Gets the total number of times SLL prediction completed in a conflict\n   * state, resulting in fallback to LL prediction.\n   *\n   * Note that this value is not related to whether or not\n   * {@link PredictionMode.SLL} may be used successfully with a particular\n   * grammar. If the ambiguity resolution algorithm applied to the SLL\n   * conflicts for this decision produce the same result as LL prediction for\n   * this decision, {@link PredictionMode.SLL} would produce the same overall\n   * parsing result as {@link PredictionMode.LL}.\n   */\n  llFallback = 0;\n  /**\n   * The total number of ATN transitions required during LL prediction for\n   * this decision. An ATN transition is determined by the number of times the\n   * DFA does not contain an edge that is required for prediction, resulting\n   * in on-the-fly computation of that edge.\n   *\n   * If DFA caching of LL transitions is employed by the implementation, ATN\n   * computation may cache the computed edge for efficient lookup during\n   * future parsing of this decision. Otherwise, the LL parsing algorithm will\n   * use ATN transitions exclusively.\n   *\n   * @see llDFATransitions\n   * @see ParserATNSimulator.computeTargetState\n   * @see LexerATNSimulator.computeTargetState\n   */\n  llATNTransitions = 0;\n  /**\n   * The total number of DFA transitions required during LL prediction for\n   * this decision.\n   *\n   * If the ATN simulator implementation does not use DFA caching for LL\n   * transitions, this value will be 0.\n   *\n   * @see ParserATNSimulator.getExistingTargetState\n   * @see LexerATNSimulator.getExistingTargetState\n   */\n  llDFATransitions = 0;\n  /**\n   * Constructs a new instance of the {@link DecisionInfo} class to contain\n   * statistics for a particular decision.\n   *\n   * @param decision The decision number\n   */\n  constructor(decision) {\n    this.decision = decision;\n    this.contextSensitivities = [];\n    this.errors = [];\n    this.ambiguities = [];\n    this.predicateEvals = [];\n  }\n  toString() {\n    return \"{decision=\" + this.decision + \", contextSensitivities=\" + this.contextSensitivities.length + \", errors=\" + this.errors.length + \", ambiguities=\" + this.ambiguities.length + \", sllLookahead=\" + this.sllTotalLook + \", sllATNTransitions=\" + this.sllATNTransitions + \", sllDFATransitions=\" + this.sllDFATransitions + \", llFallback=\" + this.llFallback + \", llLookahead=\" + this.llTotalLook + \", llATNTransitions=\" + this.llATNTransitions + \"}\";\n  }\n};\n\n// src/atn/LexerATNConfig.ts\nvar LexerATNConfig = class _LexerATNConfig extends ATNConfig {\n  static {\n    __name(this, \"LexerATNConfig\");\n  }\n  /**\n   * This is the backing field for {@link #getLexerActionExecutor}.\n   */\n  lexerActionExecutor;\n  passedThroughNonGreedyDecision;\n  constructor(config, state, context, lexerActionExecutor) {\n    super(config, state, context ?? config.context, context ? SemanticContext.NONE : config.semanticContext);\n    this.lexerActionExecutor = context ? lexerActionExecutor : config.lexerActionExecutor ?? null;\n    this.passedThroughNonGreedyDecision = _LexerATNConfig.checkNonGreedyDecision(config, this.state);\n    return this;\n  }\n  static createWithExecutor(config, state, lexerActionExecutor) {\n    return new _LexerATNConfig(config, state, config.context, lexerActionExecutor);\n  }\n  static createWithConfig(state, config, context) {\n    return new _LexerATNConfig(config, state, context ?? null, config.lexerActionExecutor);\n  }\n  static createWithContext(state, alt, context) {\n    return new _LexerATNConfig({ alt }, state, context, null);\n  }\n  static checkNonGreedyDecision(source, target) {\n    return source.passedThroughNonGreedyDecision || \"nonGreedy\" in target && target.nonGreedy;\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hashCode = MurmurHash.initialize(7);\n      hashCode = MurmurHash.update(hashCode, this.state.stateNumber);\n      hashCode = MurmurHash.update(hashCode, this.alt);\n      hashCode = MurmurHash.updateFromComparable(hashCode, this.context);\n      hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);\n      hashCode = MurmurHash.update(hashCode, this.passedThroughNonGreedyDecision ? 1 : 0);\n      hashCode = MurmurHash.updateFromComparable(hashCode, this.lexerActionExecutor);\n      hashCode = MurmurHash.finish(hashCode, 6);\n      this.cachedHashCode = hashCode;\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor && other.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);\n  }\n};\n\n// src/BaseErrorListener.ts\nvar BaseErrorListener = class {\n  static {\n    __name(this, \"BaseErrorListener\");\n  }\n  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n  }\n  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n  }\n  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n  }\n  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n  }\n};\n\n// src/ConsoleErrorListener.ts\nvar ConsoleErrorListener = class _ConsoleErrorListener extends BaseErrorListener {\n  static {\n    __name(this, \"ConsoleErrorListener\");\n  }\n  /**\n   * Provides a default instance of {@link ConsoleErrorListener}.\n   */\n  static instance = new _ConsoleErrorListener();\n  syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {\n    console.error(\"line \" + line + \":\" + charPositionInLine + \" \" + msg);\n  }\n};\n\n// src/ProxyErrorListener.ts\nvar ProxyErrorListener = class extends BaseErrorListener {\n  constructor(delegates) {\n    super();\n    this.delegates = delegates;\n    return this;\n  }\n  static {\n    __name(this, \"ProxyErrorListener\");\n  }\n  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    this.delegates.forEach((d) => {\n      d.syntaxError(recognizer, offendingSymbol, line, column, msg, e);\n    });\n  }\n  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    this.delegates.forEach((d) => {\n      d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n    });\n  }\n  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    this.delegates.forEach((d) => {\n      d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);\n    });\n  }\n  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    this.delegates.forEach((d) => {\n      d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs);\n    });\n  }\n};\n\n// src/Recognizer.ts\nvar Recognizer = class _Recognizer {\n  static {\n    __name(this, \"Recognizer\");\n  }\n  static EOF = -1;\n  static tokenTypeMapCache = /* @__PURE__ */ new Map();\n  static ruleIndexMapCache = /* @__PURE__ */ new Map();\n  interpreter;\n  listeners = [ConsoleErrorListener.instance];\n  stateNumber = -1;\n  checkVersion(toolVersion) {\n    const runtimeVersion = \"4.13.1\";\n    if (runtimeVersion !== toolVersion) {\n      console.error(\"ANTLR runtime and generated code versions disagree: \" + runtimeVersion + \"!=\" + toolVersion);\n    }\n  }\n  addErrorListener(listener) {\n    this.listeners.push(listener);\n  }\n  removeErrorListeners() {\n    this.listeners = [];\n  }\n  removeErrorListener(listener) {\n    for (let i = 0; i < this.listeners.length; i++) {\n      if (this.listeners[i] === listener) {\n        this.listeners.splice(i, 1);\n        return;\n      }\n    }\n  }\n  getErrorListeners() {\n    return this.listeners;\n  }\n  getTokenTypeMap() {\n    const vocabulary = this.vocabulary;\n    let result = _Recognizer.tokenTypeMapCache.get(vocabulary);\n    if (!result) {\n      result = /* @__PURE__ */ new Map();\n      for (let i = 0; i <= this.atn.maxTokenType; i++) {\n        const literalName = vocabulary.getLiteralName(i);\n        if (literalName) {\n          result.set(literalName, i);\n        }\n        const symbolicName = vocabulary.getSymbolicName(i);\n        if (symbolicName) {\n          result.set(symbolicName, i);\n        }\n      }\n      result.set(\"EOF\", Token.EOF);\n      _Recognizer.tokenTypeMapCache.set(vocabulary, result);\n    }\n    return result;\n  }\n  /**\n   * Get a map from rule names to rule indexes.\n   * Used for XPath and tree pattern compilation.\n   */\n  getRuleIndexMap() {\n    const ruleNames = this.ruleNames;\n    let result = _Recognizer.ruleIndexMapCache.get(ruleNames);\n    if (!result) {\n      result = /* @__PURE__ */ new Map();\n      ruleNames.forEach((ruleName, idx) => {\n        return result.set(ruleName, idx);\n      });\n      _Recognizer.ruleIndexMapCache.set(ruleNames, result);\n    }\n    return result;\n  }\n  getTokenType(tokenName) {\n    const ttype = this.getTokenTypeMap().get(tokenName);\n    if (ttype) {\n      return ttype;\n    }\n    return Token.INVALID_TYPE;\n  }\n  /** What is the error header, normally line/character position information? */\n  getErrorHeader(e) {\n    const line = e.offendingToken?.line;\n    const column = e.offendingToken?.column;\n    return \"line \" + line + \":\" + column;\n  }\n  get errorListenerDispatch() {\n    return new ProxyErrorListener(this.listeners);\n  }\n  /**\n   * subclass needs to override these if there are semantic predicates or actions\n   * that the ATN interp needs to execute\n   */\n  sempred(_localctx, _ruleIndex, _actionIndex) {\n    return true;\n  }\n  // TODO: make localCtx an optional parameter, not optional null.\n  precpred(_localctx, _precedence) {\n    return true;\n  }\n  action(_localctx, _ruleIndex, _actionIndex) {\n  }\n  get atn() {\n    return this.interpreter.atn;\n  }\n  get state() {\n    return this.stateNumber;\n  }\n  set state(state) {\n    this.stateNumber = state;\n  }\n  getParseInfo() {\n    return void 0;\n  }\n};\n\n// src/CommonTokenFactory.ts\nvar CommonTokenFactory = class _CommonTokenFactory {\n  static {\n    __name(this, \"CommonTokenFactory\");\n  }\n  /**\n   * The default {@link CommonTokenFactory} instance.\n   *\n   *\n   * This token factory does not explicitly copy token text when constructing\n   * tokens.\n   */\n  static DEFAULT = new _CommonTokenFactory();\n  /**\n   * Indicates whether {@link CommonToken.setText} should be called after\n   * constructing tokens to explicitly set the text. This is useful for cases\n   * where the input stream might not be able to provide arbitrary substrings\n   * of text from the input after the lexer creates a token (e.g. the\n   * implementation of {@link CharStream.getText} in\n   * {@link UnbufferedCharStream} throws an\n   * {@link UnsupportedOperationException}). Explicitly setting the token text\n   * allows {@link Token.getText} to be called at any time regardless of the\n   * input stream implementation.\n   *\n   *\n   * The default value is `false` to avoid the performance and memory\n   * overhead of copying text for every token unless explicitly requested.\n   */\n  copyText = false;\n  constructor(copyText) {\n    this.copyText = copyText ?? false;\n  }\n  create(source, type, text, channel, start, stop, line, column) {\n    const t = CommonToken.fromSource(source, type, channel, start, stop);\n    t.line = line;\n    t.column = column;\n    if (text) {\n      t.text = text;\n    } else if (this.copyText && source[1] !== null) {\n      t.text = source[1].getTextFromRange(start, stop);\n    }\n    return t;\n  }\n};\n\n// src/RecognitionException.ts\nvar RecognitionException = class _RecognitionException extends Error {\n  static {\n    __name(this, \"RecognitionException\");\n  }\n  ctx;\n  /**\n   * The current {@link Token} when an error occurred. Since not all streams\n   * support accessing symbols by index, we have to track the {@link Token}\n   * instance itself\n   */\n  offendingToken = null;\n  /**\n   * Get the ATN state number the parser was in at the time the error\n   * occurred. For {@link NoViableAltException} and\n   * {@link LexerNoViableAltException} exceptions, this is the\n   * {@link DecisionState} number. For others, it is the state whose outgoing\n   * edge we couldn't match.\n   */\n  offendingState = -1;\n  recognizer;\n  input;\n  constructor(params) {\n    super(params.message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _RecognitionException);\n    }\n    this.message = params.message;\n    this.recognizer = params.recognizer;\n    this.input = params.input;\n    this.ctx = params.ctx;\n    if (this.recognizer !== null) {\n      this.offendingState = this.recognizer.state;\n    }\n  }\n  /**\n   * Gets the set of input symbols which could potentially follow the\n   * previously matched symbol at the time this exception was thrown.\n   *\n   * If the set of expected tokens is not known and could not be computed,\n   * this method returns `null`.\n   *\n   * @returns The set of token types that could potentially follow the current\n   * state in the ATN, or `null` if the information is not available.\n   */\n  getExpectedTokens() {\n    if (this.recognizer !== null && this.ctx !== null) {\n      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n    } else {\n      return null;\n    }\n  }\n  // If the state number is not known, this method returns -1.\n  toString() {\n    return this.message;\n  }\n};\n\n// src/LexerNoViableAltException.ts\nvar LexerNoViableAltException = class extends RecognitionException {\n  static {\n    __name(this, \"LexerNoViableAltException\");\n  }\n  startIndex;\n  deadEndConfigs;\n  constructor(lexer, input, startIndex, deadEndConfigs) {\n    super({ message: \"\", recognizer: lexer, input, ctx: null });\n    this.startIndex = startIndex;\n    this.deadEndConfigs = deadEndConfigs;\n  }\n  toString() {\n    let symbol = \"\";\n    if (this.input && this.startIndex >= 0 && this.startIndex < this.input.size) {\n      symbol = this.input.getTextFromRange(this.startIndex, this.startIndex);\n    }\n    return `LexerNoViableAltException(${symbol})`;\n  }\n};\n\n// src/Lexer.ts\nvar Lexer = class _Lexer extends Recognizer {\n  static {\n    __name(this, \"Lexer\");\n  }\n  static DEFAULT_MODE = 0;\n  static MORE = -2;\n  static SKIP = -3;\n  static DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\n  static HIDDEN = Token.HIDDEN_CHANNEL;\n  options = {\n    minDFAEdge: 0,\n    maxDFAEdge: 256,\n    minCodePoint: 0,\n    maxCodePoint: 1114111\n  };\n  /**\n   * What character index in the stream did the current token start at?\n   *  Needed, for example, to get the text for current token.  Set at\n   *  the start of nextToken.\n   */\n  tokenStartCharIndex = -1;\n  /** The channel number for the current token */\n  channel = 0;\n  /** The token type for the current token */\n  type = 0;\n  mode = _Lexer.DEFAULT_MODE;\n  /** The start column of the current token (the one that was last read by `nextToken`). */\n  currentTokenColumn = 0;\n  /**\n   * The line on which the first character of the current token (the one that was last read by `nextToken`) resides.\n   */\n  currentTokenStartLine = 0;\n  input;\n  /**\n   * The goal of all lexer rules/methods is to create a token object.\n   *  This is an instance variable as multiple rules may collaborate to\n   *  create a single token.  nextToken will return this object after\n   *  matching lexer rule(s).  If you subclass to allow multiple token\n   *  emissions, then set this to the last token to be matched or\n   *  something non-null so that the auto token emit mechanism will not\n   *  emit another token.\n   */\n  token = null;\n  /**\n   * Once we see EOF on char stream, next token will be EOF.\n   * If you have DONE : EOF ; then you see DONE EOF.\n   */\n  hitEOF = false;\n  factory;\n  #modeStack = [];\n  /**\n   * The text to be used for the next token. If this is not null, then the text\n   * for the next token is fixed and is not subject to change in the normal\n   * workflow of the lexer.\n   */\n  #text;\n  constructor(input, options) {\n    super();\n    this.options = { ...this.options, ...options };\n    this.input = input;\n    this.factory = CommonTokenFactory.DEFAULT;\n  }\n  reset(seekBack = true) {\n    if (seekBack) {\n      this.input.seek(0);\n    }\n    this.token = null;\n    this.type = Token.INVALID_TYPE;\n    this.channel = Token.DEFAULT_CHANNEL;\n    this.tokenStartCharIndex = -1;\n    this.currentTokenColumn = -1;\n    this.currentTokenStartLine = -1;\n    this.#text = void 0;\n    this.hitEOF = false;\n    this.mode = _Lexer.DEFAULT_MODE;\n    this.#modeStack = [];\n    this.interpreter.reset();\n  }\n  /** @returns a token from this source; i.e., match a token on the char stream. */\n  nextToken() {\n    if (this.input === null) {\n      throw new Error(\"nextToken requires a non-null input stream.\");\n    }\n    const tokenStartMarker = this.input.mark();\n    try {\n      while (true) {\n        if (this.hitEOF) {\n          this.emitEOF();\n          return this.token;\n        }\n        this.token = null;\n        this.channel = Token.DEFAULT_CHANNEL;\n        this.tokenStartCharIndex = this.input.index;\n        this.currentTokenColumn = this.interpreter.column;\n        this.currentTokenStartLine = this.interpreter.line;\n        this.#text = void 0;\n        let continueOuter = false;\n        while (true) {\n          this.type = Token.INVALID_TYPE;\n          let ttype = _Lexer.SKIP;\n          try {\n            ttype = this.interpreter.match(this.input, this.mode);\n          } catch (e) {\n            if (e instanceof LexerNoViableAltException) {\n              this.notifyListeners(e);\n              this.recover(e);\n            } else {\n              throw e;\n            }\n          }\n          if (this.input.LA(1) === Token.EOF) {\n            this.hitEOF = true;\n          }\n          if (this.type === Token.INVALID_TYPE) {\n            this.type = ttype;\n          }\n          if (this.type === _Lexer.SKIP) {\n            continueOuter = true;\n            break;\n          }\n          if (this.type !== _Lexer.MORE) {\n            break;\n          }\n        }\n        if (continueOuter) {\n          continue;\n        }\n        if (this.token === null) {\n          this.emit();\n        }\n        return this.token;\n      }\n    } finally {\n      this.input.release(tokenStartMarker);\n    }\n  }\n  /**\n   * Instruct the lexer to skip creating a token for current lexer rule\n   * and look for another token. nextToken() knows to keep looking when\n   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n   * if token==null at end of any token rule, it creates one for you\n   * and emits it.\n   */\n  skip() {\n    this.type = _Lexer.SKIP;\n  }\n  more() {\n    this.type = _Lexer.MORE;\n  }\n  pushMode(m2) {\n    if (LexerATNSimulator.debug) {\n      console.log(\"pushMode \" + m2);\n    }\n    this.#modeStack.push(this.mode);\n    this.mode = m2;\n  }\n  popMode() {\n    if (this.#modeStack.length === 0) {\n      throw new Error(\"Empty Stack\");\n    }\n    if (LexerATNSimulator.debug) {\n      console.log(\"popMode back to \" + this.#modeStack.slice(0, -1));\n    }\n    this.mode = this.#modeStack.pop();\n    return this.mode;\n  }\n  get modeStack() {\n    return this.#modeStack;\n  }\n  /**\n   * By default does not support multiple emits per nextToken invocation\n   * for efficiency reasons. Subclass and override this method, nextToken,\n   * and getToken (to push tokens into a list and pull from that list\n   * rather than a single variable as this implementation does).\n   */\n  emitToken(token) {\n    this.token = token;\n  }\n  /**\n   * The standard method called to automatically emit a token at the\n   * outermost lexical rule. The token object should point into the\n   * char buffer start..stop. If there is a text override in 'text',\n   * use that to set the token's text. Override this method to emit\n   * custom Token objects or provide a new factory.\n   */\n  emit() {\n    const t = this.factory.create(\n      [this, this.input],\n      this.type,\n      this.#text,\n      this.channel,\n      this.tokenStartCharIndex,\n      this.getCharIndex() - 1,\n      this.currentTokenStartLine,\n      this.currentTokenColumn\n    );\n    this.emitToken(t);\n    return t;\n  }\n  emitEOF() {\n    const eof = this.factory.create(\n      [this, this.input],\n      Token.EOF,\n      void 0,\n      Token.DEFAULT_CHANNEL,\n      this.input.index,\n      this.input.index - 1,\n      this.line,\n      this.column\n    );\n    this.emitToken(eof);\n    return eof;\n  }\n  /** What is the index of the current character of lookahead? */\n  getCharIndex() {\n    return this.input.index;\n  }\n  /**\n   * Return a list of all Token objects in input char stream.\n   * Forces load of all tokens. Does not include EOF token.\n   */\n  getAllTokens() {\n    const tokens = [];\n    let t = this.nextToken();\n    while (t.type !== Token.EOF) {\n      tokens.push(t);\n      t = this.nextToken();\n    }\n    return tokens;\n  }\n  notifyListeners(e) {\n    const start = this.tokenStartCharIndex;\n    const stop = this.input.index;\n    const text = this.input.getTextFromRange(start, stop);\n    const msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n    this.errorListenerDispatch.syntaxError(this, null, this.currentTokenStartLine, this.currentTokenColumn, msg, e);\n  }\n  getErrorDisplay(s) {\n    return s;\n  }\n  getErrorDisplayForChar(c) {\n    if (c.charCodeAt(0) === Token.EOF) {\n      return \"<EOF>\";\n    }\n    if (c === \"\\n\") {\n      return \"\\\\n\";\n    }\n    if (c === \"\t\") {\n      return \"\\\\t\";\n    }\n    if (c === \"\\r\") {\n      return \"\\\\r\";\n    }\n    return c;\n  }\n  getCharErrorDisplay(c) {\n    return \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n  }\n  /**\n   * Lexers can normally match any char in it's vocabulary after matching\n   * a token, so do the easy thing and just kill a character and hope\n   * it all works out. You can instead use the rule invocation stack\n   * to do sophisticated error recovery if you are in a fragment rule.\n   */\n  recover(re) {\n    if (this.input.LA(1) !== Token.EOF) {\n      if (re instanceof LexerNoViableAltException) {\n        this.interpreter.consume(this.input);\n      } else {\n        this.input.consume();\n      }\n    }\n  }\n  get inputStream() {\n    return this.input;\n  }\n  set inputStream(input) {\n    this.reset(false);\n    this.input = input;\n  }\n  set tokenFactory(factory) {\n    this.factory = factory;\n  }\n  get tokenFactory() {\n    return this.factory;\n  }\n  get sourceName() {\n    return this.input.getSourceName();\n  }\n  get line() {\n    return this.interpreter.line;\n  }\n  set line(line) {\n    this.interpreter.line = line;\n  }\n  get column() {\n    return this.interpreter.column;\n  }\n  set column(column) {\n    this.interpreter.column = column;\n  }\n  get text() {\n    if (this.#text) {\n      return this.#text;\n    } else {\n      return this.interpreter.getText(this.input);\n    }\n  }\n  set text(text) {\n    this.#text = text;\n  }\n};\n\n// src/dfa/DFASerializer.ts\nvar DFASerializer = class {\n  static {\n    __name(this, \"DFASerializer\");\n  }\n  dfa;\n  vocabulary;\n  constructor(dfa, vocabulary) {\n    this.dfa = dfa;\n    this.vocabulary = vocabulary;\n  }\n  toString() {\n    if (!this.dfa.s0) {\n      return \"\";\n    }\n    let buf = \"\";\n    const states = this.dfa.getStates();\n    for (const s of states) {\n      let n2 = 0;\n      n2 = s.edges.length;\n      for (let i = 0; i < n2; i++) {\n        const t = s.edges[i];\n        if (t && t.stateNumber !== 2147483647) {\n          buf += this.getStateString(s);\n          const label = this.getEdgeLabel(i);\n          buf += \"-\";\n          buf += label;\n          buf += \"->\";\n          buf += this.getStateString(t);\n          buf += \"\\n\";\n        }\n      }\n    }\n    return buf;\n  }\n  getEdgeLabel(i) {\n    const name = this.vocabulary.getDisplayName(i - 1);\n    return `${name}`;\n  }\n  getStateString(s) {\n    const n2 = s.stateNumber;\n    const baseStateStr = (s.isAcceptState ? \":\" : \"\") + \"s\" + n2 + (s.requiresFullContext ? \"^\" : \"\");\n    if (s.isAcceptState) {\n      if (s.predicates !== null) {\n        return `${baseStateStr}=>${s.predicates.toString()}`;\n      }\n      return `${baseStateStr}=>${s.prediction}`;\n    } else {\n      return `${baseStateStr}`;\n    }\n  }\n};\n\n// src/dfa/LexerDFASerializer.ts\nvar LexerDFASerializer = class extends DFASerializer {\n  static {\n    __name(this, \"LexerDFASerializer\");\n  }\n  constructor(dfa) {\n    super(dfa, Vocabulary.EMPTY_VOCABULARY);\n  }\n  getEdgeLabel = /* @__PURE__ */ __name((i) => {\n    return \"'\" + String.fromCharCode(i) + \"'\";\n  }, \"getEdgeLabel\");\n};\n\n// src/dfa/DFA.ts\nvar DFA = class {\n  static {\n    __name(this, \"DFA\");\n  }\n  s0;\n  decision;\n  /** From which ATN state did we create this DFA? */\n  atnStartState;\n  /**\n   * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n   * start state {@link #s0} which is not stored in {@link #states}. The\n   * {@link DFAState#edges} array for this start state contains outgoing edges\n   * supplying individual start states corresponding to specific precedence\n   * values.\n   *\n   * @returns `true` if this is a precedence DFA; otherwise, `false`.\n   */\n  isPrecedenceDfa;\n  /**\n   * A mapping from an ATNConfigSet hash to a DFAState.\n   * Used to quick look up the DFA state for a particular configuration set.\n   */\n  states = /* @__PURE__ */ new Map();\n  constructor(atnStartState, decision) {\n    this.atnStartState = atnStartState;\n    this.decision = decision ?? 0;\n    let precedenceDfa = false;\n    if (atnStartState instanceof StarLoopEntryState) {\n      if (atnStartState.precedenceRuleDecision) {\n        precedenceDfa = true;\n        this.s0 = DFAState.fromState(-1);\n      }\n    }\n    this.isPrecedenceDfa = precedenceDfa;\n  }\n  [Symbol.iterator] = () => {\n    return this.states.values()[Symbol.iterator]();\n  };\n  /**\n   * Get the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n    @returns The start state corresponding to the specified precedence, or\n   * `null` if no start state exists for the specified precedence.\n   *\n   * @throws IllegalStateException if this is not a precedence DFA.\n   * @see #isPrecedenceDfa\n   */\n  getPrecedenceStartState = /* @__PURE__ */ __name((precedence) => {\n    if (!this.isPrecedenceDfa) {\n      throw new Error(`Only precedence DFAs may contain a precedence start state.`);\n    }\n    if (!this.s0 || !this.s0.edges || precedence < 0 || precedence >= this.s0.edges.length) {\n      return void 0;\n    }\n    return this.s0.edges[precedence];\n  }, \"getPrecedenceStartState\");\n  /**\n   * Set the start state for a specific precedence value.\n   *\n   * @param precedence The current precedence.\n   * @param startState The start state corresponding to the specified precedence.\n   */\n  setPrecedenceStartState = /* @__PURE__ */ __name((precedence, startState) => {\n    if (!this.isPrecedenceDfa) {\n      throw new Error(`Only precedence DFAs may contain a precedence start state.`);\n    }\n    if (precedence < 0 || !this.s0) {\n      return;\n    }\n    this.s0.edges[precedence] = startState;\n  }, \"setPrecedenceStartState\");\n  /**\n   * @returns a list of all states in this DFA, ordered by state number.\n   */\n  getStates() {\n    const result = [...this.states.values()];\n    result.sort((o1, o2) => {\n      return o1.stateNumber - o2.stateNumber;\n    });\n    return result;\n  }\n  getState(state) {\n    return this.states.get(state.configs.hashCode()) ?? null;\n  }\n  getStateForConfigs(configs) {\n    return this.states.get(configs.hashCode()) ?? null;\n  }\n  addState(state) {\n    const hash = state.configs.hashCode();\n    if (this.states.has(hash)) {\n      return;\n    }\n    this.states.set(hash, state);\n    state.stateNumber = this.states.size - 1;\n  }\n  toString(vocabulary) {\n    if (!vocabulary) {\n      return this.toString(Vocabulary.EMPTY_VOCABULARY);\n    }\n    if (!this.s0) {\n      return \"\";\n    }\n    const serializer = new DFASerializer(this, vocabulary);\n    return serializer.toString() ?? \"\";\n  }\n  toLexerString() {\n    if (!this.s0) {\n      return \"\";\n    }\n    const serializer = new LexerDFASerializer(this);\n    return serializer.toString() ?? \"\";\n  }\n  get length() {\n    return this.states.size;\n  }\n};\n\n// src/atn/LexerIndexedCustomAction.ts\nvar LexerIndexedCustomAction = class _LexerIndexedCustomAction {\n  static {\n    __name(this, \"LexerIndexedCustomAction\");\n  }\n  offset;\n  action;\n  actionType;\n  isPositionDependent = true;\n  cachedHashCode;\n  constructor(offset, action) {\n    this.actionType = action.actionType;\n    this.offset = offset;\n    this.action = action;\n  }\n  /**\n   * This method calls {@link execute} on the result of {@link getAction}\n   * using the provided `lexer`.\n   */\n  execute(lexer) {\n    this.action.execute(lexer);\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hash = MurmurHash.initialize();\n      hash = MurmurHash.update(hash, this.offset);\n      hash = MurmurHash.updateFromComparable(hash, this.action);\n      this.cachedHashCode = MurmurHash.finish(hash, 2);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof _LexerIndexedCustomAction)) {\n      return false;\n    }\n    return this.offset === other.offset && this.action === other.action;\n  }\n};\n\n// src/atn/LexerActionExecutor.ts\nvar LexerActionExecutor = class _LexerActionExecutor {\n  static {\n    __name(this, \"LexerActionExecutor\");\n  }\n  lexerActions;\n  actionType;\n  isPositionDependent = false;\n  cachedHashCode;\n  /**\n   * Represents an executor for a sequence of lexer actions which traversed during\n   * the matching operation of a lexer rule (token).\n   *\n   * The executor tracks position information for position-dependent lexer actions\n   * efficiently, ensuring that actions appearing only at the end of the rule do\n   * not cause bloating of the {@link DFA} created for the lexer.\n   */\n  constructor(lexerActions) {\n    this.actionType = -1;\n    this.lexerActions = lexerActions ?? [];\n    return this;\n  }\n  /**\n   * Creates a {@link LexerActionExecutor} which executes the actions for\n   * the input `lexerActionExecutor` followed by a specified\n   * `lexerAction`.\n   *\n   * @param lexerActionExecutor The executor for actions already traversed by\n   * the lexer while matching a token within a particular\n   * {@link LexerATNConfig}. If this is `null`, the method behaves as\n   * though it were an empty executor.\n   * @param lexerAction The lexer action to execute after the actions\n   * specified in `lexerActionExecutor`.\n   *\n   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n   * of `lexerActionExecutor` and `lexerAction`.\n   */\n  static append(lexerActionExecutor, lexerAction) {\n    if (lexerActionExecutor === null) {\n      return new _LexerActionExecutor([lexerAction]);\n    }\n    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);\n    return new _LexerActionExecutor(lexerActions);\n  }\n  /**\n   * Creates a {@link LexerActionExecutor} which encodes the current offset\n   * for position-dependent lexer actions.\n   *\n   * Normally, when the executor encounters lexer actions where\n   * {@link LexerAction//isPositionDependent} returns `true`, it calls\n   * {@link IntStream.seek} on the input {@link CharStream} to set the input\n   * position to the *end* of the current token. This behavior provides\n   * for efficient DFA representation of lexer actions which appear at the end\n   * of a lexer rule, even when the lexer rule matches a variable number of\n   * characters.\n   *\n   * Prior to traversing a match transition in the ATN, the current offset\n   * from the token start index is assigned to all position-dependent lexer\n   * actions which have not already been assigned a fixed offset. By storing\n   * the offsets relative to the token start index, the DFA representation of\n   * lexer actions which appear in the middle of tokens remains efficient due\n   * to sharing among tokens of the same length, regardless of their absolute\n   * position in the input stream.\n   *\n   * If the current executor already has offsets assigned to all\n   * position-dependent lexer actions, the method returns `this`.\n   *\n   * @param offset The current offset to assign to all position-dependent\n   * lexer actions which do not already have offsets assigned.\n   *\n   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n   * for all position-dependent lexer actions.\n   */\n  fixOffsetBeforeMatch(offset) {\n    let updatedLexerActions = null;\n    for (let i = 0; i < this.lexerActions.length; i++) {\n      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n        if (updatedLexerActions === null) {\n          updatedLexerActions = this.lexerActions.concat([]);\n        }\n        updatedLexerActions[i] = new LexerIndexedCustomAction(\n          offset,\n          this.lexerActions[i]\n        );\n      }\n    }\n    if (updatedLexerActions === null) {\n      return this;\n    } else {\n      return new _LexerActionExecutor(updatedLexerActions);\n    }\n  }\n  /**\n   * Execute the actions encapsulated by this executor within the context of a\n   * particular {@link Lexer}.\n   *\n   * This method calls {@link IntStream.seek} to set the position of the\n   * `input` {@link CharStream} prior to calling\n   * {@link LexerAction.execute} on a position-dependent action. Before the\n   * method returns, the input position will be restored to the same position\n   * it was in when the method was invoked.\n   *\n   * @param lexer The lexer instance.\n   * @param input The input stream which is the source for the current token.\n   * When this method is called, the current {@link IntStream.index} for\n   * `input` should be the start of the following token, i.e. 1\n   * character past the end of the current token.\n   * @param startIndex The token start index. This value may be passed to\n   * {@link IntStream.seek} to set the `input` position to the beginning\n   * of the token.\n   */\n  execute(lexer, input, startIndex) {\n    if (input === void 0 || startIndex === void 0) {\n      return;\n    }\n    let requiresSeek = false;\n    const stopIndex = input.index;\n    try {\n      for (const lexerAction of this.lexerActions) {\n        let action = lexerAction;\n        if (lexerAction instanceof LexerIndexedCustomAction) {\n          const offset = lexerAction.offset;\n          input.seek(startIndex + offset);\n          action = lexerAction.action;\n          requiresSeek = startIndex + offset !== stopIndex;\n        } else if (lexerAction.isPositionDependent) {\n          input.seek(stopIndex);\n          requiresSeek = false;\n        }\n        action.execute(lexer);\n      }\n    } finally {\n      if (requiresSeek) {\n        input.seek(stopIndex);\n      }\n    }\n  }\n  hashCode() {\n    if (this.cachedHashCode === void 0) {\n      let hashCode = MurmurHash.initialize(7);\n      for (const lexerAction of this.lexerActions) {\n        hashCode = MurmurHash.update(hashCode, lexerAction.hashCode());\n      }\n      this.cachedHashCode = MurmurHash.finish(hashCode, this.lexerActions.length);\n    }\n    return this.cachedHashCode;\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.cachedHashCode !== other.cachedHashCode) {\n      return false;\n    }\n    if (this.lexerActions.length !== other.lexerActions.length) {\n      return false;\n    }\n    return this.lexerActions.every((action, index) => {\n      return action.equals(other.lexerActions[index]);\n    });\n  }\n};\n\n// src/misc/OrderedHashSet.ts\nvar OrderedHashSet = class _OrderedHashSet extends HashSet {\n  static {\n    __name(this, \"OrderedHashSet\");\n  }\n  elements = [];\n  getOrAdd(o) {\n    const oldSize = this.size;\n    const result = super.getOrAdd(o);\n    if (this.size > oldSize) {\n      this.elements.push(o);\n    }\n    return result;\n  }\n  equals(o) {\n    if (!(o instanceof _OrderedHashSet)) {\n      return false;\n    }\n    return super.equals(o);\n  }\n  clear() {\n    super.clear();\n    this.elements = [];\n  }\n  *[Symbol.iterator]() {\n    yield* this.elements;\n  }\n  toArray() {\n    return this.elements.slice(0);\n  }\n};\n\n// src/atn/OrderedATNConfigSet.ts\nvar OrderedATNConfigSet = class extends ATNConfigSet {\n  static {\n    __name(this, \"OrderedATNConfigSet\");\n  }\n  constructor() {\n    super();\n    this.configLookup = new OrderedHashSet();\n  }\n};\n\n// src/atn/LexerATNSimulator.ts\nvar LexerATNSimulator = class _LexerATNSimulator extends ATNSimulator {\n  static {\n    __name(this, \"LexerATNSimulator\");\n  }\n  static debug = false;\n  decisionToDFA;\n  recognizer = null;\n  /**\n   * The current token's starting index into the character stream.\n   *  Shared across DFA to ATN simulation in case the ATN fails and the\n   *  DFA did not have a previous accept state. In this case, we use the\n   *  ATN-generated exception object.\n   */\n  startIndex = -1;\n  /** line number 1..n within the input */\n  line = 1;\n  /** The index of the character relative to the beginning of the line 0..n-1 */\n  column = 0;\n  mode = Lexer.DEFAULT_MODE;\n  /** Used during DFA/ATN exec to record the most recent accept configuration info */\n  prevAccept;\n  options;\n  /** Lookup table for lexer ATN config creation. */\n  lexerATNConfigFactory;\n  /**\n   * When we hit an accept state in either the DFA or the ATN, we\n   * have to notify the character stream to start buffering characters\n   * via {@link IntStream//mark} and record the current state. The current sim state\n   * includes the current index into the input, the current line,\n   * and current character position in that line. Note that the Lexer is\n   * tracking the starting line and characterization of the token. These\n   * variables track the \"state\" of the simulator when it hits an accept state.\n   *\n   * We track these variables separately for the DFA and ATN simulation\n   * because the DFA simulation often has to fail over to the ATN\n   * simulation. If the ATN simulation fails, we need the DFA to fall\n   * back to its previously accepted state, if any. If the ATN succeeds,\n   * then the ATN does the accept and the DFA simulator that invoked it\n   * can simply return the predicted token type.\n   */\n  constructor(recog, atn, decisionToDFA, sharedContextCache) {\n    super(atn, sharedContextCache);\n    this.decisionToDFA = decisionToDFA;\n    this.recognizer = recog;\n    if (recog) {\n      this.options = recog.options;\n    } else {\n      this.options = {\n        minDFAEdge: 0,\n        maxDFAEdge: 256,\n        minCodePoint: 0,\n        maxCodePoint: 1114111\n      };\n    }\n  }\n  match(input, mode) {\n    this.mode = mode;\n    const mark = input.mark();\n    try {\n      this.startIndex = input.index;\n      this.prevAccept = void 0;\n      const dfa = this.decisionToDFA[mode];\n      if (!dfa.s0) {\n        return this.matchATN(input);\n      }\n      return this.execATN(input, dfa.s0);\n    } finally {\n      input.release(mark);\n    }\n  }\n  reset() {\n    this.prevAccept = void 0;\n    this.startIndex = -1;\n    this.line = 1;\n    this.column = 0;\n    this.mode = Lexer.DEFAULT_MODE;\n  }\n  clearDFA() {\n    for (let d = 0; d < this.decisionToDFA.length; d++) {\n      this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);\n    }\n  }\n  getDFA(mode) {\n    return this.decisionToDFA[mode];\n  }\n  /** @returns the text matched so far for the current token. */\n  getText(input) {\n    return input.getTextFromRange(this.startIndex, input.index - 1);\n  }\n  consume(input) {\n    const curChar = input.LA(1);\n    if (curChar === \"\\n\".charCodeAt(0)) {\n      this.line += 1;\n      this.column = 0;\n    } else {\n      this.column += 1;\n    }\n    input.consume();\n  }\n  getTokenName(tt) {\n    if (tt === Token.EOF) {\n      return \"EOF\";\n    } else {\n      return \"'\" + String.fromCharCode(tt) + \"'\";\n    }\n  }\n  matchATN(input) {\n    const startState = this.atn.modeToStartState[this.mode];\n    if (_LexerATNSimulator.debug) {\n      console.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n    }\n    const oldMode = this.mode;\n    const s0Closure = this.computeStartState(input, startState);\n    const suppressEdge = s0Closure.hasSemanticContext;\n    s0Closure.hasSemanticContext = false;\n    const next = this.addDFAState(s0Closure);\n    if (!suppressEdge) {\n      this.decisionToDFA[this.mode].s0 = next;\n    }\n    const predict = this.execATN(input, next);\n    if (_LexerATNSimulator.debug) {\n      console.log(\"DFA after matchATN: \" + this.decisionToDFA[oldMode].toLexerString());\n    }\n    return predict;\n  }\n  execATN(input, state) {\n    if (_LexerATNSimulator.debug) {\n      console.log(\"start state closure=\" + state.configs);\n    }\n    if (state.isAcceptState) {\n      this.captureSimState(input, state);\n    }\n    let t = input.LA(1);\n    while (true) {\n      if (_LexerATNSimulator.debug) {\n        console.log(\"execATN loop starting closure: \" + state.configs);\n      }\n      let target = this.getExistingTargetState(state, t);\n      if (!target) {\n        target = this.computeTargetState(input, state, t);\n      }\n      if (target === ATNSimulator.ERROR) {\n        break;\n      }\n      if (t !== Token.EOF) {\n        this.consume(input);\n      }\n      if (target.isAcceptState) {\n        this.captureSimState(input, target);\n        if (t === Token.EOF) {\n          break;\n        }\n      }\n      t = input.LA(1);\n      state = target;\n    }\n    return this.failOrAccept(input, state.configs, t);\n  }\n  /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns `null`.\n   *\n   * @param s The current DFA state.\n   * @param t The next input symbol.\n   *\n   * @returns The existing target DFA state for the given input symbol\n   * `t`, or `null` if the target state for this edge is not already cached\n   */\n  getExistingTargetState(s, t) {\n    if (t >= this.options.minDFAEdge && t <= this.options.maxDFAEdge) {\n      const target = s.edges[t - this.options.minDFAEdge];\n      if (_LexerATNSimulator.debug && target) {\n        console.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n      }\n      return target;\n    }\n    return void 0;\n  }\n  /**\n   * Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding\n   * edge to the DFA.\n   *\n   * @param input The input stream\n   * @param s The current DFA state\n   * @param t The next input symbol\n   *\n   * @returns The computed target DFA state for the given input symbol `t`.\n   *          If `t` does not lead to a valid DFA state, this method returns `ERROR`.\n   */\n  computeTargetState(input, s, t) {\n    const reach = new OrderedATNConfigSet();\n    this.getReachableConfigSet(input, s.configs, reach, t);\n    if (reach.length === 0) {\n      if (!reach.hasSemanticContext) {\n        this.addDFAEdge(s, t, ATNSimulator.ERROR);\n      }\n      return ATNSimulator.ERROR;\n    }\n    return this.addDFAEdge(s, t, null, reach);\n  }\n  failOrAccept(input, reach, t) {\n    if (this.prevAccept?.dfaState) {\n      const { dfaState, index, line, column } = this.prevAccept;\n      this.accept(input, dfaState.lexerActionExecutor, this.startIndex, index, line, column);\n      return dfaState.prediction;\n    }\n    if (t === Token.EOF && input.index === this.startIndex) {\n      return Token.EOF;\n    }\n    throw new LexerNoViableAltException(this.recognizer, input, this.startIndex, reach);\n  }\n  /**\n   * Given a starting configuration set, figure out all ATN configurations we can reach upon input `t`.\n   * Parameter `reach` is a return parameter.\n   */\n  getReachableConfigSet(input, closure, reach, t) {\n    let skipAlt = ATN.INVALID_ALT_NUMBER;\n    for (const cfg of closure) {\n      const currentAltReachedAcceptState = cfg.alt === skipAlt;\n      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n        continue;\n      }\n      if (_LexerATNSimulator.debug) {\n        console.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg.toString(this.recognizer, true));\n      }\n      for (const trans of cfg.state.transitions) {\n        const target = this.getReachableTarget(trans, t);\n        if (target) {\n          let lexerActionExecutor = cfg.lexerActionExecutor;\n          if (lexerActionExecutor) {\n            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n          }\n          const treatEofAsEpsilon = t === Token.EOF;\n          const config = LexerATNConfig.createWithExecutor(\n            cfg,\n            target,\n            lexerActionExecutor\n          );\n          if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n            skipAlt = cfg.alt;\n          }\n        }\n      }\n    }\n  }\n  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n    if (_LexerATNSimulator.debug) {\n      console.log(\"ACTION %s\\n\", lexerActionExecutor);\n    }\n    input.seek(index);\n    this.line = line;\n    this.column = charPos;\n    if (lexerActionExecutor && this.recognizer) {\n      lexerActionExecutor.execute(this.recognizer, input, startIndex);\n    }\n  }\n  getReachableTarget(trans, t) {\n    if (trans.matches(t, this.options.minCodePoint, this.options.maxCodePoint)) {\n      return trans.target;\n    } else {\n      return void 0;\n    }\n  }\n  computeStartState(input, p) {\n    const initialContext = EmptyPredictionContext.instance;\n    const configs = new OrderedATNConfigSet();\n    for (let i = 0; i < p.transitions.length; i++) {\n      const target = p.transitions[i].target;\n      const cfg = LexerATNConfig.createWithContext(target, i + 1, initialContext);\n      this.closure(input, cfg, configs, false, false, false);\n    }\n    return configs;\n  }\n  /**\n   * Since the alternatives within any lexer decision are ordered by\n   * preference, this method stops pursuing the closure as soon as an accept\n   * state is reached. After the first accept state is reached by depth-first\n   * search from `config`, all other (potentially reachable) states for\n   * this rule would have a lower priority.\n   *\n   * @returns {boolean} `true` if an accept state is reached, otherwise `false`.\n   */\n  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n    let cfg = null;\n    if (_LexerATNSimulator.debug) {\n      console.log(\"closure(\" + config.toString(this.recognizer, true) + \")\");\n    }\n    if (config.state.constructor.stateType === ATNState.RULE_STOP) {\n      if (_LexerATNSimulator.debug) {\n        if (this.recognizer !== null) {\n          console.log(\n            \"closure at %s rule stop %s\\n\",\n            this.recognizer.ruleNames[config.state.ruleIndex],\n            config\n          );\n        } else {\n          console.log(\"closure at rule stop %s\\n\", config);\n        }\n      }\n      if (!config.context || config.context.hasEmptyPath()) {\n        if (!config.context || config.context.isEmpty()) {\n          configs.add(config);\n          return true;\n        } else {\n          configs.add(LexerATNConfig.createWithConfig(config.state, config, EmptyPredictionContext.instance));\n          currentAltReachedAcceptState = true;\n        }\n      }\n      if (config.context && !config.context.isEmpty()) {\n        for (let i = 0; i < config.context.length; i++) {\n          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n            const newContext = config.context.getParent(i);\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            cfg = LexerATNConfig.createWithConfig(returnState, config, newContext);\n            currentAltReachedAcceptState = this.closure(\n              input,\n              cfg,\n              configs,\n              currentAltReachedAcceptState,\n              speculative,\n              treatEofAsEpsilon\n            );\n          }\n        }\n      }\n      return currentAltReachedAcceptState;\n    }\n    if (!config.state.epsilonOnlyTransitions) {\n      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n        configs.add(config);\n      }\n    }\n    for (const trans of config.state.transitions) {\n      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n      if (cfg) {\n        currentAltReachedAcceptState = this.closure(\n          input,\n          cfg,\n          configs,\n          currentAltReachedAcceptState,\n          speculative,\n          treatEofAsEpsilon\n        );\n      }\n    }\n    return currentAltReachedAcceptState;\n  }\n  // side-effect: can alter configs.hasSemanticContext\n  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {\n    if (!this.lexerATNConfigFactory) {\n      this.setupATNFactoryLookup();\n    }\n    const factory = this.lexerATNConfigFactory[trans.transitionType];\n    if (!factory) {\n      return null;\n    }\n    return factory(input, config, trans, configs, speculative, treatEofAsEpsilon);\n  }\n  /**\n   * Fills the lookup table for creating lexer ATN configs. This helps to avoid frequent checks of the transition\n   * type, which determines the configuration of the created config.\n   */\n  setupATNFactoryLookup() {\n    this.lexerATNConfigFactory = [];\n    this.lexerATNConfigFactory[Transition.RULE] = (input, config, trans) => {\n      const newContext = createSingletonPredictionContext(\n        config.context ?? void 0,\n        trans.followState.stateNumber\n      );\n      return LexerATNConfig.createWithConfig(trans.target, config, newContext);\n    };\n    this.lexerATNConfigFactory[Transition.PRECEDENCE] = () => {\n      throw new Error(\"Precedence predicates are not supported in lexers.\");\n    };\n    this.lexerATNConfigFactory[Transition.PREDICATE] = (input, config, trans, configs, speculative) => {\n      const pt = trans;\n      if (_LexerATNSimulator.debug) {\n        console.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n      }\n      configs.hasSemanticContext = true;\n      if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {\n        return LexerATNConfig.createWithConfig(trans.target, config);\n      }\n      return null;\n    };\n    this.lexerATNConfigFactory[Transition.ACTION] = (input, config, trans) => {\n      if (config.context === null || config.context.hasEmptyPath()) {\n        const lexerActionExecutor = LexerActionExecutor.append(\n          config.lexerActionExecutor,\n          this.atn.lexerActions[trans.actionIndex]\n        );\n        return LexerATNConfig.createWithExecutor(config, trans.target, lexerActionExecutor);\n      } else {\n        return LexerATNConfig.createWithConfig(trans.target, config);\n      }\n    };\n    this.lexerATNConfigFactory[Transition.EPSILON] = (input, config, trans) => {\n      return LexerATNConfig.createWithConfig(trans.target, config);\n    };\n    const simple = /* @__PURE__ */ __name((input, config, trans, configs, speculative, treatEofAsEpsilon) => {\n      if (treatEofAsEpsilon) {\n        if (trans.matches(Token.EOF, this.options.minCodePoint, this.options.maxCodePoint)) {\n          return LexerATNConfig.createWithConfig(trans.target, config);\n        }\n      }\n      return null;\n    }, \"simple\");\n    this.lexerATNConfigFactory[Transition.ATOM] = simple;\n    this.lexerATNConfigFactory[Transition.RANGE] = simple;\n    this.lexerATNConfigFactory[Transition.SET] = simple;\n  }\n  /**\n   * Evaluate a predicate specified in the lexer.\n   *\n   * If `speculative` is `true`, this method was called before\n   * {@link consume} for the matched character. This method should call\n   * {@link consume} before evaluating the predicate to ensure position\n   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n   * and {@link Lexer}, properly reflect the current\n   * lexer state. This method should restore `input` and the simulator\n   * to the original state before returning (i.e. undo the actions made by the\n   * call to {@link consume}.\n   *\n   * @param input The input stream.\n   * @param ruleIndex The rule containing the predicate.\n   * @param predIndex The index of the predicate within the rule.\n   * @param speculative `true` if the current index in `input` is\n   * one character before the predicate's location.\n   *\n   * @returns `true` if the specified predicate evaluates to\n   * `true`.\n   */\n  evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n    if (!this.recognizer) {\n      return true;\n    }\n    if (!speculative) {\n      return this.recognizer.sempred(null, ruleIndex, predIndex);\n    }\n    const savedColumn = this.column;\n    const savedLine = this.line;\n    const index = input.index;\n    const marker = input.mark();\n    try {\n      this.consume(input);\n      return this.recognizer.sempred(null, ruleIndex, predIndex);\n    } finally {\n      this.column = savedColumn;\n      this.line = savedLine;\n      input.seek(index);\n      input.release(marker);\n    }\n  }\n  captureSimState(input, dfaState) {\n    this.prevAccept = {\n      index: input.index,\n      line: this.line,\n      column: this.column,\n      dfaState\n    };\n  }\n  addDFAEdge(from, tk, to, configs) {\n    if (!to && configs) {\n      const suppressEdge = configs.hasSemanticContext;\n      configs.hasSemanticContext = false;\n      to = this.addDFAState(configs);\n      if (suppressEdge) {\n        return to;\n      }\n    }\n    if (tk < this.options.minDFAEdge || tk > this.options.maxDFAEdge) {\n      return to;\n    }\n    if (_LexerATNSimulator.debug) {\n      console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + tk);\n    }\n    from.edges[tk - this.options.minDFAEdge] = to;\n    return to;\n  }\n  /**\n   * Add a new DFA state if there isn't one with this set of configurations already. This method also detects\n   * the first configuration containing an ATN rule stop state. Later, when traversing the DFA, we will know\n   * which rule to accept.\n   */\n  addDFAState(configs) {\n    const dfa = this.decisionToDFA[this.mode];\n    const existing = dfa.getStateForConfigs(configs);\n    if (existing) {\n      return existing;\n    }\n    const proposed = DFAState.fromConfigs(configs);\n    const firstConfigWithRuleStopState = configs.firstStopState;\n    if (firstConfigWithRuleStopState) {\n      proposed.isAcceptState = true;\n      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n    }\n    configs.setReadonly(true);\n    dfa.addState(proposed);\n    return proposed;\n  }\n};\n\n// src/atn/ParseInfo.ts\nvar ParseInfo = class {\n  static {\n    __name(this, \"ParseInfo\");\n  }\n  atnSimulator;\n  constructor(atnSimulator) {\n    this.atnSimulator = atnSimulator;\n  }\n  /**\n   * Gets an array of {@link DecisionInfo} instances containing the profiling\n   * information gathered for each decision in the ATN.\n   *\n   * @returns An array of {@link DecisionInfo} instances, indexed by decision\n   * number.\n   */\n  getDecisionInfo() {\n    return this.atnSimulator.getDecisionInfo();\n  }\n  /**\n   * Gets the decision numbers for decisions that required one or more\n   * full-context predictions during parsing. These are decisions for which\n   * {@link DecisionInfo#llFallback} is non-zero.\n   *\n   * @returns A list of decision numbers which required one or more\n   * full-context predictions during parsing.\n   */\n  getLLDecisions() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    const result = new Array();\n    for (let i = 0; i < decisions.length; i++) {\n      const fallBack = decisions[i].llFallback;\n      if (fallBack > 0) {\n        result.push(i);\n      }\n    }\n    return result;\n  }\n  /**\n   * Gets the total time spent during prediction across all decisions made\n   * during parsing. This value is the sum of\n   * {@link DecisionInfo#timeInPrediction} for all decisions.\n   */\n  getTotalTimeInPrediction() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let t = 0;\n    for (const decision of decisions) {\n      t += decision.timeInPrediction;\n    }\n    return t;\n  }\n  /**\n   * Gets the total number of SLL lookahead operations across all decisions\n   * made during parsing. This value is the sum of\n   * {@link DecisionInfo#sllTotalLook} for all decisions.\n   */\n  getTotalSLLLookaheadOps() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let k = 0;\n    for (const decision of decisions) {\n      k += decision.sllTotalLook;\n    }\n    return k;\n  }\n  /**\n   * Gets the total number of LL lookahead operations across all decisions\n   * made during parsing. This value is the sum of\n   * {@link DecisionInfo#llTotalLook} for all decisions.\n   */\n  getTotalLLLookaheadOps() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let k = 0;\n    for (const decision of decisions) {\n      k += decision.llTotalLook;\n    }\n    return k;\n  }\n  /**\n   * Gets the total number of ATN lookahead operations for SLL prediction\n   * across all decisions made during parsing.\n   */\n  getTotalSLLATNLookaheadOps() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let k = 0;\n    for (const decision of decisions) {\n      k += decision.sllATNTransitions;\n    }\n    return k;\n  }\n  /**\n   * Gets the total number of ATN lookahead operations for LL prediction\n   * across all decisions made during parsing.\n   */\n  getTotalLLATNLookaheadOps() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let k = 0;\n    for (const decision of decisions) {\n      k += decision.llATNTransitions;\n    }\n    return k;\n  }\n  /**\n   * Gets the total number of ATN lookahead operations for SLL and LL\n   * prediction across all decisions made during parsing.\n   *\n   *\n   * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and\n   * {@link #getTotalLLATNLookaheadOps}.\n   */\n  getTotalATNLookaheadOps() {\n    const decisions = this.atnSimulator.getDecisionInfo();\n    let k = 0;\n    for (const decision of decisions) {\n      k += decision.sllATNTransitions;\n      k += decision.llATNTransitions;\n    }\n    return k;\n  }\n  getDFASize(decision) {\n    if (decision === void 0) {\n      let n2 = 0;\n      const decisionToDFA = this.atnSimulator.decisionToDFA;\n      for (let i = 0; i < decisionToDFA.length; i++) {\n        n2 += this.getDFASize(i);\n      }\n      return n2;\n    } else {\n      const decisionToDFA = this.atnSimulator.decisionToDFA[decision];\n      return decisionToDFA.length;\n    }\n  }\n};\n\n// src/NoViableAltException.ts\nvar NoViableAltException = class extends RecognitionException {\n  static {\n    __name(this, \"NoViableAltException\");\n  }\n  /** Which configurations did we try at input.index() that couldn't match input.LT(1)? */\n  deadEndConfigs = null;\n  /**\n   * The token object at the start index; the input stream might\n   * \tnot be buffering tokens so get a reference to it. (At the\n   *  time the error occurred, of course the stream needs to keep a\n   *  buffer all of the tokens but later we might not have access to those.)\n   */\n  startToken;\n  constructor(recognizer, input = null, startToken = null, offendingToken = null, deadEndConfigs = null, ctx = null) {\n    ctx = ctx ?? recognizer.context;\n    offendingToken = offendingToken ?? recognizer.getCurrentToken();\n    startToken = startToken ?? recognizer.getCurrentToken();\n    input = input ?? recognizer.inputStream;\n    super({ message: \"\", recognizer, input, ctx });\n    this.deadEndConfigs = deadEndConfigs;\n    this.startToken = startToken;\n    this.offendingToken = offendingToken;\n  }\n};\n\n// src/utils/DoubleDict.ts\nvar DoubleDict = class {\n  static {\n    __name(this, \"DoubleDict\");\n  }\n  cacheMap;\n  constructor() {\n    this.cacheMap = new HashMap();\n  }\n  get(a, b) {\n    const d = this.cacheMap.get(a) ?? null;\n    return d === null ? null : d.get(b) ?? null;\n  }\n  set(a, b, o) {\n    let d = this.cacheMap.get(a);\n    if (!d) {\n      d = new HashMap();\n      this.cacheMap.set(a, d);\n    }\n    d.set(b, o);\n  }\n};\n\n// src/atn/PredictionMode.ts\nvar SubsetEqualityComparer = class _SubsetEqualityComparer {\n  static {\n    __name(this, \"SubsetEqualityComparer\");\n  }\n  static instance = new _SubsetEqualityComparer();\n  hashCode(config) {\n    let hashCode = MurmurHash.initialize(7);\n    hashCode = MurmurHash.update(hashCode, config.state.stateNumber);\n    hashCode = MurmurHash.updateFromComparable(hashCode, config.context);\n    hashCode = MurmurHash.finish(hashCode, 2);\n    return hashCode;\n  }\n  equals(a, b) {\n    return a.state.stateNumber === b.state.stateNumber && (a.context?.equals(b.context) ?? true);\n  }\n};\nvar PredictionMode = class _PredictionMode {\n  static {\n    __name(this, \"PredictionMode\");\n  }\n  /**\n   * The SLL(*) prediction mode. This prediction mode ignores the current\n   * parser context when making predictions. This is the fastest prediction\n   * mode, and provides correct results for many grammars. This prediction\n   * mode is more powerful than the prediction mode provided by ANTLR 3, but\n   * may result in syntax errors for grammar and input combinations which are\n   * not SLL.\n   *\n   *\n   * When using this prediction mode, the parser will either return a correct\n   * parse tree (i.e. the same parse tree that would be returned with the\n   * {@link LL} prediction mode), or it will report a syntax error. If a\n   * syntax error is encountered when using the {@link SLL} prediction mode,\n   * it may be due to either an actual syntax error in the input or indicate\n   * that the particular combination of grammar and input requires the more\n   * powerful {@link LL} prediction abilities to complete successfully.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */\n  static SLL = 0;\n  /**\n   * The LL(*) prediction mode. This prediction mode allows the current parser\n   * context to be used for resolving SLL conflicts that occur during\n   * prediction. This is the fastest prediction mode that guarantees correct\n   * parse results for all combinations of grammars with syntactically correct\n   * inputs.\n   *\n   *\n   * When using this prediction mode, the parser will make correct decisions\n   * for all syntactically-correct grammar and input combinations. However, in\n   * cases where the grammar is truly ambiguous this prediction mode might not\n   * report a precise answer for *exactly which* alternatives are\n   * ambiguous.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */\n  static LL = 1;\n  /**\n   *\n   * The LL(*) prediction mode with exact ambiguity detection. In addition to\n   * the correctness guarantees provided by the {@link LL} prediction mode,\n   * this prediction mode instructs the prediction algorithm to determine the\n   * complete and exact set of ambiguous alternatives for every ambiguous\n   * decision encountered while parsing.\n   *\n   *\n   * This prediction mode may be used for diagnosing ambiguities during\n   * grammar development. Due to the performance overhead of calculating sets\n   * of ambiguous alternatives, this prediction mode should be avoided when\n   * the exact results are not necessary.\n   *\n   *\n   * This prediction mode does not provide any guarantees for prediction\n   * behavior for syntactically-incorrect inputs.\n   */\n  static LL_EXACT_AMBIG_DETECTION = 2;\n  /**\n   *\n   *Computes the SLL prediction termination condition.\n   *\n   *\n   *This method computes the SLL prediction termination condition for both of\n   *the following cases.\n   *\n   * - The usual SLL+LL fallback upon SLL conflict\n   * - Pure SLL without LL fallback\n   *\n   ***COMBINED SLL+LL PARSING**\n   *\n   *When LL-fallback is enabled upon SLL conflict, correct predictions are\n   *ensured regardless of how the termination condition is computed by this\n   *method. Due to the substantially higher cost of LL prediction, the\n   *prediction should only fall back to LL when the additional lookahead\n   *cannot lead to a unique SLL prediction.\n   *\n   *Assuming combined SLL+LL parsing, an SLL configuration set with only\n   *conflicting subsets should fall back to full LL, even if the\n   *configuration sets don't resolve to the same alternative (e.g.\n   *`{1,2`} and `{3,4`}. If there is at least one non-conflicting\n   *configuration, SLL could continue with the hopes that more lookahead will\n   *resolve via one of those non-conflicting configurations.\n   *\n   *Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n   *stops when it sees only conflicting configuration subsets. In contrast,\n   *full LL keeps going when there is uncertainty.\n   *\n   ***HEURISTIC**\n   *\n   *As a heuristic, we stop prediction when we see any conflicting subset\n   *unless we see a state that only has one alternative associated with it.\n   *The single-alt-state thing lets prediction continue upon rules like\n   *(otherwise, it would admit defeat too soon):\n   *\n   *`[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;`\n   *\n   *When the ATN simulation reaches the state before `';'`, it has a\n   *DFA state that looks like: `[12|1|[], 6|2|[], 12|2|[]]`. Naturally\n   *`12|1|[]` and `12|2|[]` conflict, but we cannot stop\n   *processing this node because alternative to has another way to continue,\n   *via `[6|2|[]]`.\n   *\n   *It also let's us continue for this rule:\n   *\n   *`[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;`\n   *\n   *After matching input A, we reach the stop state for rule A, state 1.\n   *State 8 is the state right before B. Clearly alternatives 1 and 2\n   *conflict and no amount of further lookahead will separate the two.\n   *However, alternative 3 will be able to continue and so we do not stop\n   *working on this state. In the previous example, we're concerned with\n   *states associated with the conflicting alternatives. Here alt 3 is not\n   *associated with the conflicting configs, but since we can continue\n   *looking for input reasonably, don't declare the state done.\n   *\n   ***PURE SLL PARSING**\n   *\n   *To handle pure SLL parsing, all we have to do is make sure that we\n   *combine stack contexts for configurations that differ only by semantic\n   *predicate. From there, we can do the usual SLL termination heuristic.\n   *\n   ***PREDICATES IN SLL+LL PARSING**\n   *\n   *SLL decisions don't evaluate predicates until after they reach DFA stop\n   *states because they need to create the DFA cache that works in all\n   *semantic situations. In contrast, full LL evaluates predicates collected\n   *during start state computation so it can ignore predicates thereafter.\n   *This means that SLL termination detection can totally ignore semantic\n   *predicates.\n   *\n   *Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n   *semantic predicate contexts so we might see two configurations like the\n   *following.\n   *\n   *`(s, 1, x, {`), (s, 1, x', {p})}\n   *\n   *Before testing these configurations against others, we have to merge\n   *`x` and `x'` (without modifying the existing configurations).\n   *For example, we test `(x+x')==x''` when looking for conflicts in\n   *the following configurations.\n   *\n   *`(s, 1, x, {`), (s, 1, x', {p}), (s, 2, x'', {})}\n   *\n   *If the configuration set has predicates (as indicated by\n   *{@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n   *the configurations to strip out all of the predicates so that a standard\n   *{@link ATNConfigSet} will merge everything ignoring predicates.\n   */\n  static hasSLLConflictTerminatingPrediction(mode, configs) {\n    if (_PredictionMode.allConfigsInRuleStopStates(configs)) {\n      return true;\n    }\n    if (mode === _PredictionMode.SLL) {\n      if (configs.hasSemanticContext) {\n        const dup = new ATNConfigSet();\n        for (let c of configs) {\n          c = ATNConfig.duplicate(c, SemanticContext.NONE);\n          dup.add(c);\n        }\n        configs = dup;\n      }\n    }\n    const altSets = _PredictionMode.getConflictingAltSubsets(configs);\n    return _PredictionMode.hasConflictingAltSet(altSets) && !_PredictionMode.hasStateAssociatedWithOneAlt(configs);\n  }\n  /**\n   * Checks if any configuration in `configs` is in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @returns `true` if any configuration in `configs` is in a\n   * {@link RuleStopState}, otherwise `false`\n   */\n  static hasConfigInRuleStopState(configs) {\n    for (const c of configs) {\n      if (c.state instanceof RuleStopState) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if all configurations in `configs` are in a\n   * {@link RuleStopState}. Configurations meeting this condition have reached\n   * the end of the decision rule (local context) or end of start rule (full\n   * context).\n   *\n   * @param configs the configuration set to test\n   * @returns `true` if all configurations in `configs` are in a\n   * {@link RuleStopState}, otherwise `false`\n   */\n  static allConfigsInRuleStopStates(configs) {\n    for (const c of configs) {\n      if (!(c.state instanceof RuleStopState)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   *\n   * Full LL prediction termination.\n   *\n   * Can we stop looking ahead during ATN simulation or is there some\n   * uncertainty as to which alternative we will ultimately pick, after\n   * consuming more input? Even if there are partial conflicts, we might know\n   * that everything is going to resolve to the same minimum alternative. That\n   * means we can stop since no more lookahead will change that fact. On the\n   * other hand, there might be multiple conflicts that resolve to different\n   * minimums. That means we need more look ahead to decide which of those\n   * alternatives we should predict.\n   *\n   * The basic idea is to split the set of configurations `C`, into\n   * conflicting subsets `(s, _, ctx, _)` and singleton subsets with\n   * non-conflicting configurations. Two configurations conflict if they have\n   * identical {@link ATNConfig.state} and {@link ATNConfig.context} values\n   * but different {@link ATNConfig.alt} value, e.g. `(s, i, ctx, _)`\n   * and `(s, j, ctx, _)` for `i!=j`.\n   *\n   * Reduce these configuration subsets to the set of possible alternatives.\n   * You can compute the alternative subsets in one pass as follows:\n   *\n   * `A_s,ctx = {i | (s, i, ctx, _)`} for each configuration in\n   * `C` holding `s` and `ctx` fixed.\n   *\n   * Or in pseudo-code, for each configuration `c` in `C`:\n   *\n   * ```\n   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * ```\n   *\n   * The values in `map` are the set of `A_s,ctx` sets.\n   *\n   * If `|A_s,ctx|=1` then there is no conflict associated with\n   * `s` and `ctx`.\n   *\n   * Reduce the subsets to singletons by choosing a minimum of each subset. If\n   * the union of these alternative subsets is a singleton, then no amount of\n   * more lookahead will help us. We will always pick that alternative. If,\n   * however, there is more than one alternative, then we are uncertain which\n   * alternative to predict and must continue looking for resolution. We may\n   * or may not discover an ambiguity in the future, even if there are no\n   * conflicting subsets this round.\n   *\n   * The biggest sin is to terminate early because it means we've made a\n   * decision but were uncertain as to the eventual outcome. We haven't used\n   * enough lookahead. On the other hand, announcing a conflict too late is no\n   * big deal; you will still have the conflict. It's just inefficient. It\n   * might even look until the end of file.\n   *\n   * No special consideration for semantic predicates is required because\n   * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n   * no configuration contains a semantic context during the termination\n   * check.\n   *\n   * **CONFLICTING CONFIGS**\n   *\n   * Two configurations `(s, i, x)` and `(s, j, x')`, conflict when `i!=j` but `x=x'`. Because we merge all\n   * `(s, i, _)` configurations together, that means that there are at most `n` configurations associated with state\n   * `s` for `n` possible alternatives in the decision. The merged stacks complicate the comparison of configuration\n   * contexts `x` and `x'`. Sam checks to see if one is a subset of the other by calling merge and checking to see\n   * if the merged result is either `x` or `x'`. If the `x` associated with lowest alternative `i` is the superset,\n   * then `i` is the only possible prediction since the others resolve to `min(i)` as well. However, if `x` is\n   * associated with `j>i` then at least one stack configuration for `j` is not in conflict with alternative `i`.\n   * The algorithm should keep going, looking for more lookahead due to the uncertainty.\n   *\n   * For simplicity, I'm doing a equality check between `x` and `x'` that lets the algorithm continue to consume\n   * lookahead longer than necessary. The reason I like the equality is of course the simplicity but also because\n   * that is the test you need to detect the alternatives that are actually in conflict.\n   *\n   * **CONTINUE/STOP RULE**\n   *\n   * Continue if union of resolved alternative sets from non-conflicting and conflicting alternative subsets has more\n   * than one alternative. We are uncertain about which alternative to predict.\n   *\n   * The complete set of alternatives, `[i for (_,i,_)]`, tells us which alternatives are still in the running for\n   * the amount of input we've consumed at this point. The conflicting sets let us to strip away configurations that\n   * won't lead to more states because we resolve conflicts to the configuration with a minimum alternate for the\n   * conflicting set.\n   *\n   * **CASES**\n   *\n   * - no conflicts and more than 1 alternative in set => continue\n   * -  `(s, 1, x)`, `(s, 2, x)`, `(s, 3, z)`, `(s', 1, y)`, `(s', 2, y)` yields non-conflicting set `{3`} U\n   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1,3`} => continue\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)`, `(s'', 1, z)` yields non-conflicting set `{1`} U\n   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1`} => stop and predict 1\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)` yields conflicting, reduced sets `{1`} U\n   *   `{1`} = `{1`} => stop and predict 1, can announce ambiguity `{1,2`}\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 2, y)`, `(s', 3, y)` yields conflicting, reduced sets `{1`} U\n   *   `{2`} = `{1,2`} => continue\n   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 3, y)`, `(s', 4, y)` yields conflicting, reduced sets `{1`} U\n   *   `{3`} = `{1,3`} => continue\n   *\n   * **EXACT AMBIGUITY DETECTION**\n   *\n   *If all states report the same conflicting set of alternatives, then we\n   *know we have the exact ambiguity set.\n   *\n   * `|A_*i*|>1` and `A_*i* = A_*j*` for all *i*, *j*.\n   *\n   * In other words, we continue examining lookahead until all `A_i` have more than one alternative and all `A_i`\n   * are the same. If `A={{1,2`, {1,3}}}, then regular LL prediction would terminate because the resolved set\n   * is `{1`}. To determine what the real ambiguity is, we have to know whether the ambiguity is between one and\n   * two or one and three so we keep going. We can only stop prediction when we need exact ambiguity detection when\n   * the sets look like `A={{1,2`}} or `{{1,2`,{1,2}}}, etc...\n   */\n  static resolvesToJustOneViableAlt(altSets) {\n    return _PredictionMode.getSingleViableAlt(altSets);\n  }\n  /**\n   * Determines if every alternative subset in `altSets` contains more\n   * than one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if every {@link BitSet} in `altSets` has\n   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`\n   */\n  static allSubsetsConflict(altSets) {\n    return !_PredictionMode.hasNonConflictingAltSet(altSets);\n  }\n  /**\n   * Determines if any single alternative subset in `altSets` contains\n   * exactly one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if `altSets` contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} 1, otherwise `false`\n   */\n  static hasNonConflictingAltSet(altSets) {\n    for (const alts of altSets) {\n      if (alts.length === 1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Determines if any single alternative subset in `altSets` contains\n   * more than one alternative.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if `altSets` contains a {@link BitSet} with\n   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`\n   */\n  static hasConflictingAltSet(altSets) {\n    for (const alts of altSets) {\n      if (alts.length > 1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Determines if every alternative subset in `altSets` is equivalent.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns `true` if every member of `altSets` is equal to the\n   * others, otherwise `false`\n   */\n  static allSubsetsEqual(altSets) {\n    let first = null;\n    for (const alts of altSets) {\n      if (first === null) {\n        first = alts;\n      } else if (alts !== first) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns the unique alternative predicted by all alternative subsets in\n   * `altSets`. If no such alternative exists, this method returns\n   * {@link ATN.INVALID_ALT_NUMBER}.\n   *\n   * @param altSets a collection of alternative subsets\n   */\n  static getUniqueAlt(altSets) {\n    const all = _PredictionMode.getAlts(altSets);\n    if (all.length === 1) {\n      return all.nextSetBit(0);\n    } else {\n      return ATN.INVALID_ALT_NUMBER;\n    }\n  }\n  /**\n   * Gets the complete set of represented alternatives for a collection of\n   * alternative subsets. This method returns the union of each {@link BitSet}\n   * in `altSets`.\n   *\n   * @param altSets a collection of alternative subsets\n   * @returns the set of represented alternatives in `altSets`\n   */\n  static getAlts(altSets) {\n    const all = new BitSet();\n    altSets.forEach((alts) => {\n      all.or(alts);\n    });\n    return all;\n  }\n  /**\n   * This function gets the conflicting alt subsets from a configuration set.\n   * For each configuration `c` in `configs`:\n   *\n   * ```\n   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not\n   * alt and not pred\n   * ```\n   */\n  static getConflictingAltSubsets(configs) {\n    const configToAlts = new HashMap(SubsetEqualityComparer.instance);\n    for (const cfg of configs) {\n      let alts = configToAlts.get(cfg);\n      if (!alts) {\n        alts = new BitSet();\n        configToAlts.set(cfg, alts);\n      }\n      alts.set(cfg.alt);\n    }\n    return Array.from(configToAlts.values());\n  }\n  /**\n   * Get a map from state to alt subset from a configuration set. For each configuration `c` in `configs`:\n   *\n   * ```\n   * map[c.state] = c.alt\n   * ```\n   */\n  static getStateToAltMap(configs) {\n    const m2 = new HashMap(ObjectEqualityComparator.instance);\n    for (const c of configs) {\n      let alts = m2.get(c.state);\n      if (!alts) {\n        alts = new BitSet();\n        m2.set(c.state, alts);\n      }\n      alts.set(c.alt);\n    }\n    return m2;\n  }\n  static hasStateAssociatedWithOneAlt(configs) {\n    const counts = {};\n    for (const c of configs) {\n      const stateNumber = c.state.stateNumber;\n      if (!counts[stateNumber]) {\n        counts[stateNumber] = 0;\n      }\n      counts[stateNumber]++;\n    }\n    return Object.values(counts).some((count) => {\n      return count === 1;\n    });\n  }\n  static getSingleViableAlt(altSets) {\n    let result = null;\n    for (const alts of altSets) {\n      const minAlt = alts.nextSetBit(0);\n      if (result === null) {\n        result = minAlt;\n      } else if (result !== minAlt) {\n        return ATN.INVALID_ALT_NUMBER;\n      }\n    }\n    return result ?? 0;\n  }\n};\n\n// src/atn/ParserATNSimulator.ts\nvar ParserATNSimulator = class _ParserATNSimulator extends ATNSimulator {\n  static {\n    __name(this, \"ParserATNSimulator\");\n  }\n  static traceATNSimulator = false;\n  static debug;\n  static debugAdd = false;\n  static debugClosure = false;\n  static dfaDebug = false;\n  static retryDebug = false;\n  /** SLL, LL, or LL + exact ambig detection? */\n  predictionMode;\n  decisionToDFA;\n  parser;\n  /**\n   * Each prediction operation uses a cache for merge of prediction contexts.\n   * Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n   * isn't synchronized but we're ok since two threads shouldn't reuse same\n   * parser/atn sim object because it can only handle one input at a time.\n   * This maps graphs a and b to merged result c. (a,b)->c. We can avoid\n   * the merge if we ever see a and b again.  Note that (b,a)->c should\n   * also be examined during cache lookup.\n   */\n  mergeCache = new DoubleDict();\n  // Used also in the profiling ATN simulator.\n  predictionState;\n  constructor(recog, atn, decisionToDFA, sharedContextCache) {\n    super(atn, sharedContextCache);\n    this.parser = recog;\n    this.decisionToDFA = decisionToDFA;\n  }\n  static getUniqueAlt(configs) {\n    let alt = ATN.INVALID_ALT_NUMBER;\n    for (const c of configs) {\n      if (alt === ATN.INVALID_ALT_NUMBER) {\n        alt = c.alt;\n      } else if (c.alt !== alt) {\n        return ATN.INVALID_ALT_NUMBER;\n      }\n    }\n    return alt;\n  }\n  reset() {\n  }\n  clearDFA() {\n    for (let d = 0; d < this.decisionToDFA.length; d++) {\n      this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);\n    }\n  }\n  // TODO: make outerContext an optional parameter, not optional null.\n  adaptivePredict(input, decision, outerContext) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {\n      console.log(\"adaptivePredict decision \" + decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n    }\n    const dfa = this.decisionToDFA[decision];\n    this.predictionState = {\n      input,\n      startIndex: input.index,\n      outerContext: outerContext ?? void 0,\n      dfa\n    };\n    const m2 = input.mark();\n    const index = input.index;\n    try {\n      let s0;\n      if (dfa.isPrecedenceDfa) {\n        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n      } else {\n        s0 = dfa.s0;\n      }\n      if (!s0) {\n        if (!outerContext) {\n          outerContext = ParserRuleContext.empty;\n        }\n        if (_ParserATNSimulator.debug) {\n          console.log(\"predictATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n        }\n        const fullCtx = false;\n        let s0_closure = this.computeStartState(dfa.atnStartState, ParserRuleContext.empty, fullCtx);\n        if (dfa.isPrecedenceDfa) {\n          s0_closure = this.applyPrecedenceFilter(s0_closure);\n          s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));\n          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n        } else {\n          s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));\n          dfa.s0 = s0;\n        }\n      }\n      const alt = this.execATN(dfa, s0, input, index, outerContext);\n      if (_ParserATNSimulator.debug) {\n        console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.vocabulary));\n      }\n      return alt;\n    } finally {\n      this.predictionState.dfa = void 0;\n      this.mergeCache = new DoubleDict();\n      input.seek(index);\n      input.release(m2);\n    }\n  }\n  /**\n   * Performs ATN simulation to compute a predicted alternative based\n   *  upon the remaining input, but also updates the DFA cache to avoid\n   *  having to traverse the ATN again for the same input sequence.\n   *\n   * There are some key conditions we're looking for after computing a new\n   * set of ATN configs (proposed DFA state):\n   *       if the set is empty, there is no viable alternative for current symbol\n   *       does the state uniquely predict an alternative?\n   *       does the state have a conflict that would prevent us from\n   *         putting it on the work list?\n   *\n   * We also have some key operations to do:\n   *       add an edge from previous DFA state to potentially new DFA state, D,\n   *         upon current symbol but only if adding to work list, which means in all\n   *         cases except no viable alternative (and possibly non-greedy decisions?)\n   *       collecting predicates and adding semantic context to DFA accept states\n   *       adding rule context to context-sensitive DFA accept states\n   *       consuming an input symbol\n   *       reporting a conflict\n   *       reporting an ambiguity\n   *       reporting a context sensitivity\n   *       reporting insufficient predicates\n   *\n   * cover these cases:\n   *    dead end\n   *    single alt\n   *    single alt + preds\n   *    conflict\n   *    conflict + preds\n   */\n  execATN(dfa, s0, input, startIndex, outerContext) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {\n      console.log(\"execATN decision \" + dfa.decision + \", DFA state \" + s0 + \", LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n    }\n    let alt;\n    let previousState = s0;\n    let t = input.LA(1);\n    while (true) {\n      let nextState = this.getExistingTargetState(previousState, t);\n      if (!nextState) {\n        nextState = this.computeTargetState(dfa, previousState, t);\n      }\n      if (nextState === ATNSimulator.ERROR) {\n        const e = this.noViableAlt(input, outerContext, previousState.configs, startIndex);\n        input.seek(startIndex);\n        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousState.configs, outerContext);\n        if (alt !== ATN.INVALID_ALT_NUMBER) {\n          return alt;\n        } else {\n          throw e;\n        }\n      }\n      if (nextState.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n        let conflictingAlts = null;\n        if (nextState.predicates !== null) {\n          if (_ParserATNSimulator.debug) {\n            console.log(\"DFA state has preds in DFA sim LL failover\");\n          }\n          const conflictIndex = input.index;\n          if (conflictIndex !== startIndex) {\n            input.seek(startIndex);\n          }\n          conflictingAlts = this.evalSemanticContext(nextState.predicates, outerContext, true);\n          if (conflictingAlts.length === 1) {\n            if (_ParserATNSimulator.debug) {\n              console.log(\"Full LL avoided\");\n            }\n            return conflictingAlts.nextSetBit(0);\n          }\n          if (conflictIndex !== startIndex) {\n            input.seek(conflictIndex);\n          }\n        }\n        if (_ParserATNSimulator.dfaDebug) {\n          console.log(\"ctx sensitive state \" + outerContext + \" in \" + nextState);\n        }\n        const fullCtx = true;\n        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n        this.reportAttemptingFullContext(dfa, conflictingAlts, nextState.configs, startIndex, input.index);\n        alt = this.execATNWithFullContext(dfa, nextState, s0_closure, input, startIndex, outerContext);\n        return alt;\n      }\n      if (nextState.isAcceptState) {\n        if (nextState.predicates === null) {\n          return nextState.prediction;\n        }\n        const stopIndex = input.index;\n        input.seek(startIndex);\n        const alts = this.evalSemanticContext(nextState.predicates, outerContext, true);\n        if (alts.length === 0) {\n          throw this.noViableAlt(input, outerContext, nextState.configs, startIndex);\n        }\n        if (alts.length === 1) {\n          return alts.nextSetBit(0);\n        }\n        this.reportAmbiguity(dfa, nextState, startIndex, stopIndex, false, alts, nextState.configs);\n        return alts.nextSetBit(0);\n      }\n      previousState = nextState;\n      if (t !== Token.EOF) {\n        input.consume();\n        t = input.LA(1);\n      }\n    }\n  }\n  /**\n   * Get an existing target state for an edge in the DFA. If the target state\n   * for the edge has not yet been computed or is otherwise not available,\n   * this method returns `null`.\n   *\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   * @returns The existing target DFA state for the given input symbol\n   * `t`, or `null` if the target state for this edge is not\n   * already cached\n   */\n  getExistingTargetState(previousD, t) {\n    return previousD.edges[t + 1];\n  }\n  /**\n   * Compute a target state for an edge in the DFA, and attempt to add the\n   * computed state and corresponding edge to the DFA.\n   *\n   * @param dfa The DFA\n   * @param previousD The current DFA state\n   * @param t The next input symbol\n   *\n   * @returns The computed target DFA state for the given input symbol\n   * `t`. If `t` does not lead to a valid DFA state, this method\n   * returns {@link ERROR\n   */\n  computeTargetState(dfa, previousD, t) {\n    const reach = this.computeReachSet(previousD.configs, t, false);\n    if (reach === null) {\n      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n      return ATNSimulator.ERROR;\n    }\n    let D = DFAState.fromConfigs(reach);\n    const predictedAlt = _ParserATNSimulator.getUniqueAlt(reach);\n    if (_ParserATNSimulator.debug) {\n      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n      console.log(\"SLL altSubSets=\" + arrayToString(altSubSets) + /*\", previous=\" + previousD.configs + */\n      \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + this.getConflictingAlts(reach));\n    }\n    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n      D.isAcceptState = true;\n      D.configs.uniqueAlt = predictedAlt;\n      D.prediction = predictedAlt;\n    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n      D.configs.conflictingAlts = this.getConflictingAlts(reach);\n      D.requiresFullContext = true;\n      D.isAcceptState = true;\n      D.prediction = D.configs.conflictingAlts.nextSetBit(0);\n    }\n    if (D.isAcceptState && D.configs.hasSemanticContext) {\n      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n      if (D.predicates !== null) {\n        D.prediction = ATN.INVALID_ALT_NUMBER;\n      }\n    }\n    D = this.addDFAEdge(dfa, previousD, t, D);\n    return D;\n  }\n  getRuleName(index) {\n    if (this.parser !== null && index >= 0) {\n      return this.parser.ruleNames[index];\n    } else {\n      return \"<rule \" + index + \">\";\n    }\n  }\n  getTokenName(t) {\n    if (t === Token.EOF) {\n      return \"EOF\";\n    }\n    const vocabulary = this.parser?.vocabulary ?? Vocabulary.EMPTY_VOCABULARY;\n    const displayName = vocabulary.getDisplayName(t);\n    if (displayName === t.toString()) {\n      return displayName;\n    }\n    return displayName + \"<\" + t + \">\";\n  }\n  getLookaheadName(input) {\n    return this.getTokenName(input.LA(1));\n  }\n  /**\n   * Used for debugging in adaptivePredict around execATN but I cut\n   * it out for clarity now that alg. works well. We can leave this\n   * \"dead\" code for a bit\n   */\n  dumpDeadEndConfigs(e) {\n    console.log(\"dead end configs: \");\n    const decs = e.deadEndConfigs;\n    for (const c of decs) {\n      let trans = \"no edges\";\n      if (c.state.transitions.length > 0) {\n        const t = c.state.transitions[0];\n        if (t instanceof AtomTransition) {\n          trans = \"Atom \" + this.getTokenName(t.labelValue);\n        } else if (t instanceof SetTransition) {\n          const neg = t instanceof NotSetTransition;\n          trans = (neg ? \"~\" : \"\") + \"Set \" + t.label;\n        }\n      }\n      console.error(c.toString(this.parser, true) + \":\" + trans);\n    }\n  }\n  predicateDFAState(dfaState, decisionState) {\n    const altCount = decisionState.transitions.length;\n    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, altCount);\n    if (altToPred !== null) {\n      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n      dfaState.prediction = ATN.INVALID_ALT_NUMBER;\n    } else {\n      dfaState.prediction = altsToCollectPredsFrom.nextSetBit(0);\n    }\n  }\n  // comes back with reach.uniqueAlt set to a valid alt\n  execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {\n      console.log(\"execATNWithFullContext \" + s0);\n    }\n    const fullCtx = true;\n    let foundExactAmbig = false;\n    let reach;\n    let previous = s0;\n    input.seek(startIndex);\n    let t = input.LA(1);\n    let predictedAlt = -1;\n    for (; ; ) {\n      reach = this.computeReachSet(previous, t, fullCtx);\n      if (reach === null) {\n        const e = this.noViableAlt(input, outerContext, previous, startIndex);\n        input.seek(startIndex);\n        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n        if (alt !== ATN.INVALID_ALT_NUMBER) {\n          return alt;\n        } else {\n          throw e;\n        }\n      }\n      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n      if (_ParserATNSimulator.debug) {\n        console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n      }\n      reach.uniqueAlt = _ParserATNSimulator.getUniqueAlt(reach);\n      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n        predictedAlt = reach.uniqueAlt;\n        break;\n      } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n        predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n          break;\n        }\n      } else {\n        if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n          foundExactAmbig = true;\n          predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n          break;\n        }\n      }\n      previous = reach;\n      if (t !== Token.EOF) {\n        input.consume();\n        t = input.LA(1);\n      }\n    }\n    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n      return predictedAlt;\n    }\n    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, reach.getAlts(), reach);\n    return predictedAlt;\n  }\n  computeReachSet(closure, t, fullCtx) {\n    if (_ParserATNSimulator.debug) {\n      console.log(\"in computeReachSet, starting closure: \" + closure);\n    }\n    const intermediate = new ATNConfigSet(fullCtx);\n    let skippedStopStates = null;\n    for (const c of closure) {\n      if (_ParserATNSimulator.debug) {\n        console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n      }\n      if (c.state instanceof RuleStopState) {\n        if (fullCtx || t === Token.EOF) {\n          if (skippedStopStates === null) {\n            skippedStopStates = [];\n          }\n          skippedStopStates.push(c);\n        }\n        continue;\n      }\n      for (const trans of c.state.transitions) {\n        const target = this.getReachableTarget(trans, t);\n        if (target !== null) {\n          const cfg = ATNConfig.createWithConfig(target, c);\n          intermediate.add(cfg, this.mergeCache);\n          if (_ParserATNSimulator.debugAdd) {\n            console.log(\"added \" + cfg + \" to intermediate\");\n          }\n        }\n      }\n    }\n    let reach = null;\n    if (skippedStopStates === null && t !== Token.EOF) {\n      if (intermediate.length === 1) {\n        reach = intermediate;\n      } else if (_ParserATNSimulator.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {\n        reach = intermediate;\n      }\n    }\n    if (reach === null) {\n      reach = new ATNConfigSet(fullCtx);\n      const closureBusy = new HashSet();\n      const treatEofAsEpsilon = t === Token.EOF;\n      for (const config of intermediate) {\n        this.closure(config, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n      }\n    }\n    if (t === Token.EOF) {\n      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n    }\n    if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n      for (const config of skippedStopStates) {\n        reach.add(config, this.mergeCache);\n      }\n    }\n    if (_ParserATNSimulator.traceATNSimulator) {\n      console.log(\"computeReachSet \" + closure + \" -> \" + reach);\n    }\n    if (reach.length === 0) {\n      return null;\n    } else {\n      return reach;\n    }\n  }\n  /**\n   * Return a configuration set containing only the configurations from\n   * `configs` which are in a {@link RuleStopState}. If all\n   * configurations in `configs` are already in a rule stop state, this\n   * method simply returns `configs`.\n   *\n   * When `lookToEndOfRule` is true, this method uses\n   * {@link ATN.nextTokens} for each configuration in `configs` which is\n   * not already in a rule stop state to see if a rule stop state is reachable\n   * from the configuration via epsilon-only transitions.\n   *\n   * @param configs the configuration set to update\n   * @param lookToEndOfRule when true, this method checks for rule stop states\n   * reachable by epsilon-only transitions from each configuration in\n   * `configs`.\n   *\n   * @returns `configs` if all configurations in `configs` are in a\n   * rule stop state, otherwise return a new configuration set containing only\n   * the configurations from `configs` which are in a rule stop state\n   */\n  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n    if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n      return configs;\n    }\n    const result = new ATNConfigSet(configs.fullCtx);\n    for (const config of configs) {\n      if (config.state instanceof RuleStopState) {\n        result.add(config, this.mergeCache);\n        continue;\n      }\n      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n        const nextTokens = this.atn.nextTokens(config.state);\n        if (nextTokens.contains(Token.EPSILON)) {\n          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n          result.add(ATNConfig.createWithConfig(endOfRuleState, config), this.mergeCache);\n        }\n      }\n    }\n    return result;\n  }\n  computeStartState(p, ctx, fullCtx) {\n    const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n    const configs = new ATNConfigSet(fullCtx);\n    if (_ParserATNSimulator.traceATNSimulator) {\n      console.log(\"computeStartState from ATN state \" + p + \" initialContext=\" + initialContext.toString(this.parser));\n    }\n    for (let i = 0; i < p.transitions.length; i++) {\n      const target = p.transitions[i].target;\n      const c = ATNConfig.createWithContext(target, i + 1, initialContext);\n      const closureBusy = new HashSet();\n      this.closure(c, configs, closureBusy, true, fullCtx, false);\n    }\n    return configs;\n  }\n  /**\n   * This method transforms the start state computed by\n   * {@link computeStartState} to the special start state used by a\n   * precedence DFA for a particular precedence value. The transformation\n   * process applies the following changes to the start state's configuration\n   * set.\n   *\n   * 1. Evaluate the precedence predicates for each configuration using\n   * {@link SemanticContext//evalPrecedence}.\n   * 2. Remove all configurations which predict an alternative greater than\n   * 1, for which another configuration that predicts alternative 1 is in the\n   * same ATN state with the same prediction context. This transformation is\n   * valid for the following reasons:\n   * 3. The closure block cannot contain any epsilon transitions which bypass\n   * the body of the closure, so all states reachable via alternative 1 are\n   * part of the precedence alternatives of the transformed left-recursive\n   * rule.\n   * 4. The \"primary\" portion of a left recursive rule cannot contain an\n   * epsilon transition, so the only way an alternative other than 1 can exist\n   * in a state that is also reachable via alternative 1 is by nesting calls\n   * to the left-recursive rule, with the outer calls not being at the\n   * preferred precedence level.\n   *\n   *\n   * The prediction context must be considered by this filter to address\n   * situations like the following.\n   *\n   * `\n   * ```\n   * grammar TA;\n   * prog: statement* EOF;\n   * statement: letterA | statement letterA 'b' ;\n   * letterA: 'a';\n   * ```\n   * `\n   *\n   * If the above grammar, the ATN state immediately before the token\n   * reference `'a'` in `letterA` is reachable from the left edge\n   * of both the primary and closure blocks of the left-recursive rule\n   * `statement`. The prediction context associated with each of these\n   * configurations distinguishes between them, and prevents the alternative\n   * which stepped out to `prog` (and then back in to `statement`\n   * from being eliminated by the filter.\n   *\n   * @param configs The configuration set computed by\n   * {@link computeStartState} as the start state for the DFA.\n   * @returns The transformed configuration set representing the start state\n   * for a precedence DFA at a particular precedence level (determined by\n   * calling {@link Parser//getPrecedence})\n   */\n  applyPrecedenceFilter(configs) {\n    const statesFromAlt1 = [];\n    const configSet = new ATNConfigSet(configs.fullCtx);\n    for (const config of configs) {\n      if (config.alt !== 1) {\n        continue;\n      }\n      const updatedContext = config.semanticContext.evalPrecedence(\n        this.parser,\n        this.predictionState.outerContext\n      );\n      if (updatedContext === null) {\n        continue;\n      }\n      statesFromAlt1[config.state.stateNumber] = config.context;\n      if (updatedContext !== config.semanticContext) {\n        configSet.add(ATNConfig.duplicate(config, updatedContext), this.mergeCache);\n      } else {\n        configSet.add(config, this.mergeCache);\n      }\n    }\n    for (const config of configs) {\n      if (config.alt === 1) {\n        continue;\n      }\n      if (!config.precedenceFilterSuppressed) {\n        const context = statesFromAlt1[config.state.stateNumber] || null;\n        if (context !== null && context.equals(config.context)) {\n          continue;\n        }\n      }\n      configSet.add(config, this.mergeCache);\n    }\n    return configSet;\n  }\n  getReachableTarget(trans, ttype) {\n    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n      return trans.target;\n    } else {\n      return null;\n    }\n  }\n  getPredsForAmbigAlts(ambigAlts, configs, altCount) {\n    let altToPred = [];\n    for (const c of configs) {\n      if (ambigAlts.get(c.alt)) {\n        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] ?? null, c.semanticContext);\n      }\n    }\n    let nPredAlts = 0;\n    for (let i = 1; i < altCount + 1; i++) {\n      const pred = altToPred[i] ?? null;\n      if (pred === null) {\n        altToPred[i] = SemanticContext.NONE;\n      } else if (pred !== SemanticContext.NONE) {\n        nPredAlts += 1;\n      }\n    }\n    if (nPredAlts === 0) {\n      altToPred = null;\n    }\n    if (_ParserATNSimulator.debug) {\n      console.log(\"getPredsForAmbigAlts result \" + arrayToString(altToPred));\n    }\n    return altToPred;\n  }\n  getPredicatePredictions(ambigAlts, altToPred) {\n    const pairs = [];\n    let containsPredicate = false;\n    for (let i = 1; i < altToPred.length; i++) {\n      const pred = altToPred[i];\n      if (ambigAlts.get(i)) {\n        pairs.push({ pred, alt: i });\n      }\n      if (pred !== SemanticContext.NONE) {\n        containsPredicate = true;\n      }\n    }\n    if (!containsPredicate) {\n      return null;\n    }\n    return pairs;\n  }\n  /**\n   * This method is used to improve the localization of error messages by\n   * choosing an alternative rather than throwing a\n   * {@link NoViableAltException} in particular prediction scenarios where the\n   * {@link ERROR} state was reached during ATN simulation.\n   *\n   *\n   * The default implementation of this method uses the following\n   * algorithm to identify an ATN configuration which successfully parsed the\n   * decision entry rule. Choosing such an alternative ensures that the\n   * {@link ParserRuleContext} returned by the calling rule will be complete\n   * and valid, and the syntax error will be reported later at a more\n   * localized location.\n   *\n   * - If a syntactically valid path or paths reach the end of the decision rule and\n   * they are semantically valid if predicated, return the min associated alt.\n   * - Else, if a semantically invalid but syntactically valid path exist\n   * or paths exist, return the minimum associated alt.\n   *\n   * - Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.\n   *\n   *\n   * In some scenarios, the algorithm described above could predict an\n   * alternative which will result in a {@link FailedPredicateException} in\n   * the parser. Specifically, this could occur if the *only* configuration\n   * capable of successfully parsing to the end of the decision rule is\n   * blocked by a semantic predicate. By choosing this alternative within\n   * {@link adaptivePredict} instead of throwing a\n   * {@link NoViableAltException}, the resulting\n   * {@link FailedPredicateException} in the parser will identify the specific\n   * predicate which is preventing the parser from successfully parsing the\n   * decision rule, which helps developers identify and correct logic errors\n   * in semantic predicates.\n   *\n   * @param configs The ATN configurations which were valid immediately before\n   * the {@link ERROR} state was reached\n   * @param outerContext The is the \\gamma_0 initial parser context from the paper\n   * or the parser stack at the instant before prediction commences.\n   *\n   * @returns The value to return from {@link adaptivePredict}, or\n   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n   * identified and {@link adaptivePredict} should report an error instead\n   */\n  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n    const splitConfigs = this.splitAccordingToSemanticValidity(configs, outerContext);\n    const semValidConfigs = splitConfigs[0];\n    const semInvalidConfigs = splitConfigs[1];\n    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n    if (alt !== ATN.INVALID_ALT_NUMBER) {\n      return alt;\n    }\n    if (semInvalidConfigs.length > 0) {\n      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n      if (alt !== ATN.INVALID_ALT_NUMBER) {\n        return alt;\n      }\n    }\n    return ATN.INVALID_ALT_NUMBER;\n  }\n  getAltThatFinishedDecisionEntryRule(configs) {\n    const alts = [];\n    for (const c of configs) {\n      if (c.reachesIntoOuterContext || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {\n        if (alts.indexOf(c.alt) < 0) {\n          alts.push(c.alt);\n        }\n      }\n    }\n    if (alts.length === 0) {\n      return ATN.INVALID_ALT_NUMBER;\n    } else {\n      return Math.min(...alts);\n    }\n  }\n  /**\n   * Walk the list of configurations and split them according to\n   * those that have preds evaluating to true/false.  If no pred, assume\n   * true pred and include in succeeded set.  Returns Pair of sets.\n   *\n   * Create a new set so as not to alter the incoming parameter.\n   *\n   * Assumption: the input stream has been restored to the starting point\n   * prediction, which is where predicates need to evaluate.\n   */\n  splitAccordingToSemanticValidity(configs, outerContext) {\n    const succeeded = new ATNConfigSet(configs.fullCtx);\n    const failed = new ATNConfigSet(configs.fullCtx);\n    for (const c of configs) {\n      if (c.semanticContext !== SemanticContext.NONE) {\n        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n        if (predicateEvaluationResult) {\n          succeeded.add(c);\n        } else {\n          failed.add(c);\n        }\n      } else {\n        succeeded.add(c);\n      }\n    }\n    return [succeeded, failed];\n  }\n  /**\n   * Look through a list of predicate/alt pairs, returning alts for the\n   * pairs that win. A `NONE` predicate indicates an alt containing an\n   * unpredicated config which behaves as \"always true.\" If !complete\n   * then we stop at the first predicate that evaluates to true. This\n   * includes pairs with null predicates.\n   */\n  evalSemanticContext(predPredictions, outerContext, complete) {\n    const predictions = new BitSet();\n    for (const pair of predPredictions) {\n      if (pair.pred === SemanticContext.NONE) {\n        predictions.set(pair.alt);\n        if (!complete) {\n          break;\n        }\n        continue;\n      }\n      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n      if (_ParserATNSimulator.debug || _ParserATNSimulator.dfaDebug) {\n        console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n      }\n      if (predicateEvaluationResult) {\n        predictions.set(pair.alt);\n        if (!complete) {\n          break;\n        }\n      }\n    }\n    return predictions;\n  }\n  // TODO: If we are doing predicates, there is no point in pursuing\n  //     closure operations if we reach a DFA state that uniquely predicts\n  //     alternative. We will not be caching that DFA state and it is a\n  //     waste to pursue the closure. Might have to advance when we do\n  //     ambig detection thought :(\n  //\n  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n    const initialDepth = 0;\n    this.closureCheckingStopState(\n      config,\n      configs,\n      closureBusy,\n      collectPredicates,\n      fullCtx,\n      initialDepth,\n      treatEofAsEpsilon\n    );\n  }\n  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    if (_ParserATNSimulator.traceATNSimulator || _ParserATNSimulator.debugClosure) {\n      console.log(\"closure(\" + config.toString(this.parser, true) + \")\");\n    }\n    if (config.state instanceof RuleStopState) {\n      if (config.context && !config.context.isEmpty()) {\n        for (let i = 0; i < config.context.length; i++) {\n          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n            if (fullCtx) {\n              configs.add(\n                ATNConfig.createWithConfig(\n                  config.state,\n                  config,\n                  EmptyPredictionContext.instance\n                ),\n                this.mergeCache\n              );\n              continue;\n            } else {\n              if (_ParserATNSimulator.debug) {\n                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n              }\n              this.closure_(\n                config,\n                configs,\n                closureBusy,\n                collectPredicates,\n                fullCtx,\n                depth,\n                treatEofAsEpsilon\n              );\n            }\n            continue;\n          }\n          const returnState = this.atn.states[config.context.getReturnState(i)];\n          const newContext = config.context.getParent(i);\n          const c = ATNConfig.createWithContext(returnState, config.alt, newContext, config.semanticContext);\n          c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n          this.closureCheckingStopState(\n            c,\n            configs,\n            closureBusy,\n            collectPredicates,\n            fullCtx,\n            depth - 1,\n            treatEofAsEpsilon\n          );\n        }\n        return;\n      } else if (fullCtx) {\n        configs.add(config, this.mergeCache);\n        return;\n      } else {\n        if (_ParserATNSimulator.debug) {\n          console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n        }\n      }\n    }\n    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n  }\n  // Do the actual work of walking epsilon edges//\n  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n    const p = config.state;\n    if (!p.epsilonOnlyTransitions) {\n      configs.add(config, this.mergeCache);\n    }\n    for (let i = 0; i < p.transitions.length; i++) {\n      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) {\n        continue;\n      }\n      const t = p.transitions[i];\n      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n      if (c) {\n        let newDepth = depth;\n        if (config.state.constructor.stateType === ATNState.RULE_STOP) {\n          if (this.predictionState.dfa && this.predictionState?.dfa.isPrecedenceDfa) {\n            const outermostPrecedenceReturn = t.outermostPrecedenceReturn;\n            if (outermostPrecedenceReturn === this.predictionState?.dfa.atnStartState?.ruleIndex) {\n              c.precedenceFilterSuppressed = true;\n            }\n          }\n          c.reachesIntoOuterContext = true;\n          if (closureBusy.getOrAdd(c) !== c) {\n            continue;\n          }\n          configs.dipsIntoOuterContext = true;\n          newDepth -= 1;\n          if (_ParserATNSimulator.debug) {\n            console.log(\"dips into outer ctx: \" + c);\n          }\n        } else {\n          if (!t.isEpsilon && closureBusy.getOrAdd(c) !== c) {\n            continue;\n          }\n          if (t instanceof RuleTransition) {\n            if (newDepth >= 0) {\n              newDepth += 1;\n            }\n          }\n        }\n        this.closureCheckingStopState(\n          c,\n          configs,\n          closureBusy,\n          continueCollecting,\n          fullCtx,\n          newDepth,\n          treatEofAsEpsilon\n        );\n      }\n    }\n  }\n  canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n    const p = config.state;\n    if (p.constructor.stateType !== ATNState.STAR_LOOP_ENTRY || !config.context) {\n      return false;\n    }\n    if (!p.precedenceRuleDecision || config.context.isEmpty() || config.context.hasEmptyPath()) {\n      return false;\n    }\n    const numCtxs = config.context.length;\n    for (let i = 0; i < numCtxs; i++) {\n      const returnState = this.atn.states[config.context.getReturnState(i)];\n      if (returnState.ruleIndex !== p.ruleIndex) {\n        return false;\n      }\n    }\n    const decisionStartState = p.transitions[0].target;\n    const blockEndStateNum = decisionStartState.endState.stateNumber;\n    const blockEndState = this.atn.states[blockEndStateNum];\n    for (let i = 0; i < numCtxs; i++) {\n      const returnStateNumber = config.context.getReturnState(i);\n      const returnState = this.atn.states[returnStateNumber];\n      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) {\n        return false;\n      }\n      const returnStateTarget = returnState.transitions[0].target;\n      if (returnState.constructor.stateType === ATNState.BLOCK_END && returnStateTarget === p) {\n        continue;\n      }\n      if (returnState === blockEndState) {\n        continue;\n      }\n      if (returnStateTarget === blockEndState) {\n        continue;\n      }\n      if (returnStateTarget.constructor.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n    switch (t.transitionType) {\n      case Transition.RULE: {\n        return this.ruleTransition(config, t);\n      }\n      case Transition.PRECEDENCE: {\n        return this.precedenceTransition(\n          config,\n          t,\n          collectPredicates,\n          inContext,\n          fullCtx\n        );\n      }\n      case Transition.PREDICATE: {\n        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n      }\n      case Transition.ACTION: {\n        if (_ParserATNSimulator.debug) {\n          const at = t;\n          const index = at.actionIndex === -1 ? 65535 : at.actionIndex;\n          console.log(\"ACTION edge \" + at.ruleIndex + \":\" + index);\n        }\n        return ATNConfig.createWithConfig(t.target, config);\n      }\n      case Transition.EPSILON: {\n        return ATNConfig.createWithConfig(t.target, config);\n      }\n      case Transition.ATOM:\n      case Transition.RANGE:\n      case Transition.SET: {\n        if (treatEofAsEpsilon) {\n          if (t.matches(Token.EOF, 0, 1)) {\n            return ATNConfig.createWithConfig(t.target, config);\n          }\n        }\n        return null;\n      }\n      default:\n        return null;\n    }\n  }\n  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n    if (_ParserATNSimulator.debug) {\n      console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n      if (this.parser !== null) {\n        console.log(\"context surrounding pred is \" + arrayToString(this.parser.getRuleInvocationStack()));\n      }\n    }\n    let c = null;\n    if (collectPredicates && inContext) {\n      if (fullCtx && this.predictionState?.input) {\n        const currentPosition = this.predictionState.input.index;\n        this.predictionState.input.seek(this.predictionState.startIndex);\n        const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);\n        this.predictionState.input.seek(currentPosition);\n        if (predSucceeds) {\n          c = ATNConfig.createWithConfig(pt.target, config);\n        }\n      } else {\n        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n        c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);\n      }\n    } else {\n      c = ATNConfig.createWithConfig(pt.target, config);\n    }\n    if (_ParserATNSimulator.debug) {\n      console.log(\"config from pred transition=\" + c);\n    }\n    return c;\n  }\n  predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n    if (_ParserATNSimulator.debug) {\n      console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n      if (this.parser !== null) {\n        console.log(\"context surrounding pred is \" + arrayToString(this.parser.getRuleInvocationStack()));\n      }\n    }\n    let c = null;\n    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {\n      if (fullCtx && this.predictionState?.input) {\n        const currentPosition = this.predictionState.input.index;\n        this.predictionState.input.seek(this.predictionState.startIndex);\n        const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);\n        this.predictionState.input.seek(currentPosition);\n        if (predSucceeds) {\n          c = ATNConfig.createWithConfig(pt.target, config);\n        }\n      } else {\n        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n        c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);\n      }\n    } else {\n      c = ATNConfig.createWithConfig(pt.target, config);\n    }\n    if (_ParserATNSimulator.debug) {\n      console.log(\"config from pred transition=\" + c);\n    }\n    return c;\n  }\n  ruleTransition(config, t) {\n    if (_ParserATNSimulator.debug) {\n      console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n    }\n    const returnState = t.followState;\n    const newContext = createSingletonPredictionContext(config.context ?? void 0, returnState.stateNumber);\n    return ATNConfig.createWithConfig(t.target, config, newContext);\n  }\n  getConflictingAlts(configs) {\n    const altSets = PredictionMode.getConflictingAltSubsets(configs);\n    return PredictionMode.getAlts(altSets);\n  }\n  /**\n   * Sam pointed out a problem with the previous definition, v3, of\n   * ambiguous states. If we have another state associated with conflicting\n   * alternatives, we should keep going. For example, the following grammar\n   *\n   * s : (ID | ID ID?) ';' ;\n   *\n   * When the ATN simulation reaches the state before ';', it has a DFA\n   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n   * because alternative to has another way to continue, via [6|2|[]].\n   * The key is that we have a single state that has config's only associated\n   * with a single alternative, 2, and crucially the state transitions\n   * among the configurations are all non-epsilon transitions. That means\n   * we don't consider any conflicts that include alternative 2. So, we\n   * ignore the conflict between alts 1 and 2. We ignore a set of\n   * conflicting alts when there is an intersection with an alternative\n   * associated with a single alt state in the state -> config-list map.\n   *\n   * It's also the case that we might have two conflicting configurations but\n   * also a 3rd nonconflicting configuration for a different alternative:\n   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n   *\n   * a : A | A | A B ;\n   *\n   * After matching input A, we reach the stop state for rule A, state 1.\n   * State 8 is the state right before B. Clearly alternatives 1 and 2\n   * conflict and no amount of further lookahead will separate the two.\n   * However, alternative 3 will be able to continue and so we do not\n   * stop working on this state. In the previous example, we're concerned\n   * with states associated with the conflicting alternatives. Here alt\n   * 3 is not associated with the conflicting configs, but since we can continue\n   * looking for input reasonably, I don't declare the state done. We\n   * ignore a set of conflicting alts when we have an alternative\n   * that we still need to pursue\n   */\n  getConflictingAltsOrUniqueAlt(configs) {\n    let conflictingAlts;\n    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n      conflictingAlts = new BitSet();\n      conflictingAlts.set(configs.uniqueAlt);\n    } else {\n      conflictingAlts = configs.conflictingAlts;\n    }\n    return conflictingAlts;\n  }\n  noViableAlt(input, outerContext, configs, startIndex) {\n    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n  }\n  /**\n   * Add an edge to the DFA, if possible. This method calls\n   * {@link addDFAState} to ensure the `to` state is present in the\n   * DFA. If `from` is `null`, or if `t` is outside the\n   * range of edges that can be represented in the DFA tables, this method\n   * returns without adding the edge to the DFA.\n   *\n   * If `to` is `null`, this method returns `null`.\n   * Otherwise, this method returns the {@link DFAState} returned by calling\n   * {@link addDFAState} for the `to` state.\n   *\n   * @param dfa The DFA\n   * @param from The source state for the edge\n   * @param t The input symbol\n   * @param to The target state for the edge\n   *\n   * @returns If `to` is `null`, this method returns `null`;\n   * otherwise this method returns the result of calling {@link addDFAState}\n   * on `to`\n   */\n  addDFAEdge(dfa, from, t, to) {\n    if (_ParserATNSimulator.debug) {\n      console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\n    }\n    to = this.addDFAState(dfa, to);\n    if (t < -1 || t > this.atn.maxTokenType) {\n      return to;\n    }\n    if (_ParserATNSimulator.debug) {\n      console.log(\"DFA=\\n\" + dfa.toString(this.parser != null ? this.parser.vocabulary : Vocabulary.EMPTY_VOCABULARY));\n    }\n    from.edges[t + 1] = to;\n    return to;\n  }\n  /**\n   * Add state `D` to the DFA if it is not already present, and return\n   * the actual instance stored in the DFA. If a state equivalent to `D`\n   * is already in the DFA, the existing state is returned. Otherwise this\n   * method returns `D` after adding it to the DFA.\n   *\n   * If `D` is {@link ERROR}, this method returns {@link ERROR} and\n   * does not change the DFA.\n   *\n   * @param dfa The dfa.\n   * @param newState The DFA state to add.\n   *\n   * @returns The state stored in the DFA. This will be either the existing state if `newState` is already in\n   *          the DFA, or `newState` itself if the state was not already present.\n   */\n  addDFAState(dfa, newState) {\n    if (newState === ATNSimulator.ERROR) {\n      return newState;\n    }\n    const existing = dfa.getState(newState);\n    if (existing !== null) {\n      return existing;\n    }\n    if (!newState.configs.readOnly) {\n      newState.configs.optimizeConfigs(this);\n      newState.configs.setReadonly(true);\n    }\n    if (_ParserATNSimulator.traceATNSimulator) {\n      console.log(\"addDFAState new \" + newState);\n    }\n    dfa.addState(newState);\n    return newState;\n  }\n  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n    }\n    this.parser.errorListenerDispatch.reportAttemptingFullContext(\n      this.parser,\n      dfa,\n      startIndex,\n      stopIndex,\n      conflictingAlts,\n      configs\n    );\n  }\n  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n    }\n    this.parser.errorListenerDispatch.reportContextSensitivity(\n      this.parser,\n      dfa,\n      startIndex,\n      stopIndex,\n      prediction,\n      configs\n    );\n  }\n  // If context sensitive parsing, we know it's ambiguity not conflict.\n  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {\n      const interval = new Interval(startIndex, stopIndex + 1);\n      console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this.parser.tokenStream.getTextFromInterval(interval));\n    }\n    this.parser.errorListenerDispatch.reportAmbiguity(\n      this.parser,\n      dfa,\n      startIndex,\n      stopIndex,\n      exact,\n      ambigAlts,\n      configs\n    );\n  }\n};\n\n// src/atn/PredictionContextCache.ts\nvar PredictionContextCache = class {\n  static {\n    __name(this, \"PredictionContextCache\");\n  }\n  cache = new HashMap(ObjectEqualityComparator.instance);\n  /**\n   * Add a context to the cache and return it. If the context already exists,\n   * return that one instead and do not add a new context to the cache.\n   * Protect shared cache from unsafe thread access.\n   *\n   * @param ctx tbd\n   * @returns tbd\n   */\n  add(ctx) {\n    if (ctx === EmptyPredictionContext.instance) {\n      return ctx;\n    }\n    const existing = this.cache.get(ctx);\n    if (existing) {\n      return existing;\n    }\n    this.cache.set(ctx, ctx);\n    return ctx;\n  }\n  get(ctx) {\n    return this.cache.get(ctx);\n  }\n  get length() {\n    return this.cache.size;\n  }\n};\n\n// src/atn/ProfilingATNSimulator.ts\nvar ProfilingATNSimulator = class extends ParserATNSimulator {\n  static {\n    __name(this, \"ProfilingATNSimulator\");\n  }\n  decisions;\n  numDecisions = 0;\n  currentDecision = 0;\n  currentState;\n  /**\n   * At the point of LL failover, we record how SLL would resolve the conflict so that\n   *  we can determine whether or not a decision / input pair is context-sensitive.\n   *  If LL gives a different result than SLL's predicted alternative, we have a\n   *  context sensitivity for sure. The converse is not necessarily true, however.\n   *  It's possible that after conflict resolution chooses minimum alternatives,\n   *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\n   *  an ambiguity, it is not treated as a context sensitivity because LL prediction\n   *  was not required in order to produce a correct prediction for this decision and input sequence.\n   *  It may in fact still be a context sensitivity but we don't know by looking at the\n   *  minimum alternatives for the current input.\n   */\n  conflictingAltResolvedBySLL;\n  sllStopIndex = 0;\n  llStopIndex = 0;\n  constructor(parser) {\n    const sharedContextCache = parser.interpreter.sharedContextCache;\n    super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA, sharedContextCache);\n    if (sharedContextCache) {\n      this.numDecisions = this.atn.decisionToState.length;\n      this.decisions = new Array(this.numDecisions);\n      for (let i = 0; i < this.numDecisions; i++) {\n        this.decisions[i] = new DecisionInfo(i);\n      }\n    }\n  }\n  adaptivePredict(input, decision, outerContext) {\n    try {\n      this.sllStopIndex = -1;\n      this.llStopIndex = -1;\n      this.currentDecision = decision;\n      const start = performance.now();\n      const alt = super.adaptivePredict(input, decision, outerContext);\n      const stop = performance.now();\n      this.decisions[decision].timeInPrediction += stop - start;\n      this.decisions[decision].invocations++;\n      const sllLook = this.sllStopIndex - this.predictionState.startIndex + 1;\n      this.decisions[decision].sllTotalLook += sllLook;\n      this.decisions[decision].sllMinLook = this.decisions[decision].sllMinLook === 0 ? sllLook : Math.min(this.decisions[decision].sllMinLook, sllLook);\n      if (sllLook > this.decisions[decision].sllMaxLook) {\n        this.decisions[decision].sllMaxLook = sllLook;\n        this.decisions[decision].sllMaxLookEvent = {\n          decision,\n          configs: null,\n          predictedAlt: alt,\n          input,\n          startIndex: this.predictionState.startIndex,\n          stopIndex: this.sllStopIndex,\n          fullCtx: false\n        };\n      }\n      if (this.llStopIndex >= 0) {\n        const llLook = this.llStopIndex - this.predictionState.startIndex + 1;\n        this.decisions[decision].llTotalLook += llLook;\n        this.decisions[decision].llMinLook = this.decisions[decision].llMinLook === 0 ? llLook : Math.min(this.decisions[decision].llMinLook, llLook);\n        if (llLook > this.decisions[decision].llMaxLook) {\n          this.decisions[decision].llMaxLook = llLook;\n          this.decisions[decision].llMaxLookEvent = {\n            decision,\n            configs: null,\n            predictedAlt: alt,\n            input,\n            startIndex: this.predictionState.startIndex,\n            stopIndex: this.llStopIndex,\n            fullCtx: true\n          };\n        }\n      }\n      return alt;\n    } finally {\n      this.currentDecision = -1;\n    }\n  }\n  getExistingTargetState(previousD, t) {\n    this.sllStopIndex = this.predictionState.input.index;\n    const existingTargetState = super.getExistingTargetState(previousD, t);\n    if (existingTargetState !== void 0) {\n      this.decisions[this.currentDecision].sllDFATransitions++;\n      if (existingTargetState === ATNSimulator.ERROR) {\n        this.decisions[this.currentDecision].errors.push({\n          decision: this.currentDecision,\n          configs: previousD.configs,\n          input: this.predictionState.input,\n          startIndex: this.predictionState.startIndex,\n          stopIndex: this.sllStopIndex,\n          fullCtx: false\n        });\n      }\n    }\n    this.currentState = existingTargetState;\n    return existingTargetState;\n  }\n  computeTargetState(dfa, previousD, t) {\n    const state = super.computeTargetState(dfa, previousD, t);\n    this.currentState = state;\n    return state;\n  }\n  computeReachSet(closure, t, fullCtx) {\n    if (fullCtx && this.predictionState?.input) {\n      this.llStopIndex = this.predictionState.input.index;\n    }\n    const reachConfigs = super.computeReachSet(closure, t, fullCtx);\n    if (this.predictionState?.input) {\n      if (fullCtx) {\n        this.decisions[this.currentDecision].llATNTransitions++;\n        if (reachConfigs === null) {\n          this.decisions[this.currentDecision].errors.push({\n            decision: this.currentDecision,\n            configs: closure,\n            input: this.predictionState.input,\n            startIndex: this.predictionState.startIndex,\n            stopIndex: this.sllStopIndex,\n            fullCtx: true\n          });\n        }\n      } else {\n        this.decisions[this.currentDecision].sllATNTransitions++;\n        if (reachConfigs === null) {\n          this.decisions[this.currentDecision].errors.push({\n            decision: this.currentDecision,\n            configs: closure,\n            input: this.predictionState.input,\n            startIndex: this.predictionState.startIndex,\n            stopIndex: this.sllStopIndex,\n            fullCtx: false\n          });\n        }\n      }\n    }\n    return reachConfigs;\n  }\n  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n    if (conflictingAlts !== null) {\n      this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\n    } else {\n      this.conflictingAltResolvedBySLL = configs.getAlts().nextSetBit(0);\n    }\n    this.decisions[this.currentDecision].llFallback++;\n    if (conflictingAlts) {\n      super.reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex);\n    }\n  }\n  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n    if (prediction !== this.conflictingAltResolvedBySLL && this.predictionState.input) {\n      this.decisions[this.currentDecision].contextSensitivities.push({\n        decision: this.currentDecision,\n        configs,\n        input: this.predictionState.input,\n        startIndex,\n        stopIndex,\n        fullCtx: true\n      });\n    }\n    super.reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex);\n  }\n  reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs) {\n    let prediction;\n    if (ambigAlts) {\n      prediction = ambigAlts.nextSetBit(0);\n    } else {\n      prediction = configs.getAlts().nextSetBit(0);\n    }\n    if (this.predictionState?.input) {\n      if (configs.fullCtx && prediction !== this.conflictingAltResolvedBySLL) {\n        this.decisions[this.currentDecision].contextSensitivities.push({\n          decision: this.currentDecision,\n          configs,\n          input: this.predictionState.input,\n          startIndex,\n          stopIndex,\n          fullCtx: true\n        });\n      }\n      this.decisions[this.currentDecision].ambiguities.push({\n        ambigAlts,\n        decision: this.currentDecision,\n        configs,\n        input: this.predictionState.input,\n        startIndex,\n        stopIndex,\n        fullCtx: configs.fullCtx\n      });\n    }\n    super.reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs);\n  }\n  getDecisionInfo() {\n    return this.decisions;\n  }\n  getCurrentState() {\n    return this.currentState;\n  }\n};\n\n// src/dfa/PredPrediction.ts\nvar PredPrediction;\n((PredPrediction2) => {\n  PredPrediction2.toString = /* @__PURE__ */ __name((prediction) => {\n    return `(${prediction.pred}, ${prediction.alt})`;\n  }, \"toString\");\n})(PredPrediction || (PredPrediction = {}));\n\n// src/misc/ParseCancellationException.ts\nvar ParseCancellationException = class extends Error {\n  static {\n    __name(this, \"ParseCancellationException\");\n  }\n  constructor(e) {\n    super();\n    this.cause = e;\n  }\n};\n\n// src/misc/InterpreterDataReader.ts\nvar InterpreterDataReader = class {\n  static {\n    __name(this, \"InterpreterDataReader\");\n  }\n  /**\n   * The structure of the data file is very simple. Everything is line based with empty lines\n   * separating the different parts. For lexers the layout is:\n   * token literal names:\n   * ...\n   *\n   * token symbolic names:\n   * ...\n   *\n   * rule names:\n   * ...\n   *\n   * channel names:\n   * ...\n   *\n   * mode names:\n   * ...\n   *\n   * atn:\n   * a single line with comma separated int values, enclosed in a pair of squared brackets.\n   *\n   * Data for a parser does not contain channel and mode names.\n   */\n  static parseInterpreterData(source) {\n    const ruleNames = [];\n    const channels = [];\n    const modes = [];\n    const literalNames = [];\n    const symbolicNames = [];\n    const lines = source.split(\"\\n\");\n    let index = 0;\n    let line = lines[index++];\n    if (line !== \"token literal names:\") {\n      throw new Error(\"Unexpected data entry\");\n    }\n    do {\n      line = lines[index++];\n      if (line.length === 0) {\n        break;\n      }\n      literalNames.push(line === \"null\" ? null : line);\n    } while (true);\n    line = lines[index++];\n    if (line !== \"token symbolic names:\") {\n      throw new Error(\"Unexpected data entry\");\n    }\n    do {\n      line = lines[index++];\n      if (line.length === 0) {\n        break;\n      }\n      symbolicNames.push(line === \"null\" ? null : line);\n    } while (true);\n    line = lines[index++];\n    if (line !== \"rule names:\") {\n      throw new Error(\"Unexpected data entry\");\n    }\n    do {\n      line = lines[index++];\n      if (line.length === 0) {\n        break;\n      }\n      ruleNames.push(line);\n    } while (true);\n    line = lines[index++];\n    if (line === \"channel names:\") {\n      do {\n        line = lines[index++];\n        if (line.length === 0) {\n          break;\n        }\n        channels.push(line);\n      } while (true);\n      line = lines[index++];\n      if (line !== \"mode names:\") {\n        throw new Error(\"Unexpected data entry\");\n      }\n      do {\n        line = lines[index++];\n        if (line.length === 0) {\n          break;\n        }\n        modes.push(line);\n      } while (true);\n    }\n    line = lines[index++];\n    if (line !== \"atn:\") {\n      throw new Error(\"Unexpected data entry\");\n    }\n    line = lines[index++];\n    const elements = line.split(\",\");\n    let value;\n    const serializedATN = [];\n    for (let i = 0; i < elements.length; ++i) {\n      const element = elements[i];\n      if (element.startsWith(\"[\")) {\n        value = Number(element.substring(1).trim());\n      } else if (element.endsWith(\"]\")) {\n        value = Number(element.substring(0, element.length - 1).trim());\n      } else {\n        value = Number(element.trim());\n      }\n      serializedATN[i] = value;\n    }\n    const deserializer = new ATNDeserializer();\n    return {\n      atn: deserializer.deserialize(serializedATN),\n      vocabulary: new Vocabulary(literalNames, symbolicNames, []),\n      ruleNames,\n      channels: channels.length > 0 ? channels : void 0,\n      modes: modes.length > 0 ? modes : void 0\n    };\n  }\n};\n\n// src/tree/AbstractParseTreeVisitor.ts\nvar AbstractParseTreeVisitor = class {\n  static {\n    __name(this, \"AbstractParseTreeVisitor\");\n  }\n  visit(tree) {\n    return tree.accept(this);\n  }\n  visitChildren(node) {\n    let result = this.defaultResult();\n    const n2 = node.getChildCount();\n    for (let i = 0; i < n2; i++) {\n      if (!this.shouldVisitNextChild(node, result)) {\n        break;\n      }\n      const c = node.getChild(i);\n      if (c) {\n        const childResult = c.accept(this);\n        result = this.aggregateResult(result, childResult);\n      }\n    }\n    return result;\n  }\n  visitTerminal(_node) {\n    return this.defaultResult();\n  }\n  visitErrorNode(_node) {\n    return this.defaultResult();\n  }\n  defaultResult() {\n    return null;\n  }\n  shouldVisitNextChild(_node, _currentResult) {\n    return true;\n  }\n  aggregateResult(aggregate, nextResult) {\n    return nextResult;\n  }\n};\n\n// src/tree/ParseTreeWalker.ts\nvar ParseTreeWalker = class _ParseTreeWalker {\n  static {\n    __name(this, \"ParseTreeWalker\");\n  }\n  static DEFAULT = new _ParseTreeWalker();\n  /**\n   * Performs a walk on the given parse tree starting at the root and going down recursively\n   * with depth-first search. On each node, {@link ParseTreeWalker.enterRule} is called before\n   * recursively walking down into child nodes, then\n   * {@link ParseTreeWalker.exitRule} is called after the recursive call to wind up.\n   *\n   * @param listener The listener used by the walker to process grammar rules\n   * @param t The parse tree to be walked on\n   */\n  walk(listener, t) {\n    const errorNode = t instanceof ErrorNode;\n    if (errorNode) {\n      listener.visitErrorNode(t);\n    } else if (t instanceof TerminalNode) {\n      listener.visitTerminal(t);\n    } else {\n      const r = t;\n      this.enterRule(listener, r);\n      for (let i = 0; i < t.getChildCount(); i++) {\n        this.walk(listener, t.getChild(i));\n      }\n      this.exitRule(listener, r);\n    }\n  }\n  /**\n   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener.enterEveryRule}\n   * then by triggering the event specific to the given parse tree node\n   *\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */\n  enterRule(listener, r) {\n    const ctx = r.ruleContext;\n    listener.enterEveryRule(ctx);\n    ctx.enterRule(listener);\n  }\n  /**\n   * Exits a grammar rule by first triggering the event specific to the given parse tree node\n   * then by triggering the generic event {@link ParseTreeListener.exitEveryRule}\n   *\n   * @param listener The listener responding to the trigger events\n   * @param r The grammar rule containing the rule context\n   */\n  exitRule(listener, r) {\n    const ctx = r.ruleContext;\n    ctx.exitRule(listener);\n    listener.exitEveryRule(ctx);\n  }\n};\n\n// src/CharStream.ts\nvar CharStream;\n((CharStream2) => {\n  CharStream2.fromString = /* @__PURE__ */ __name((str) => {\n    return new CharStreamImpl(str);\n  }, \"fromString\");\n})(CharStream || (CharStream = {}));\nvar CharStreamImpl = class {\n  static {\n    __name(this, \"CharStreamImpl\");\n  }\n  name = \"\";\n  index = 0;\n  data;\n  constructor(input) {\n    const codePoints = [];\n    for (const char of input) {\n      codePoints.push(char.codePointAt(0));\n    }\n    this.data = new Uint32Array(codePoints);\n  }\n  /**\n   * Reset the stream so that it's in the same state it was\n   * when the object was created *except* the data array is not\n   * touched.\n   */\n  reset() {\n    this.index = 0;\n  }\n  consume() {\n    if (this.index >= this.data.length) {\n      throw new Error(\"cannot consume EOF\");\n    }\n    this.index += 1;\n  }\n  LA(offset) {\n    if (offset === 0) {\n      return 0;\n    }\n    if (offset < 0) {\n      offset += 1;\n    }\n    const pos = this.index + offset - 1;\n    if (pos < 0 || pos >= this.data.length) {\n      return Token.EOF;\n    }\n    return this.data[pos];\n  }\n  // mark/release do nothing; we have entire buffer\n  mark() {\n    return -1;\n  }\n  release(_marker) {\n  }\n  /**\n   * consume() ahead until p==_index; can't just set p=_index as we must\n   * update line and column. If we seek backwards, just set p\n   */\n  seek(index) {\n    if (index <= this.index) {\n      this.index = index;\n      return;\n    }\n    this.index = Math.min(index, this.data.length);\n  }\n  getTextFromRange(start, stop) {\n    stop = stop ?? this.data.length - 1;\n    if (stop >= this.data.length) {\n      stop = this.data.length - 1;\n    }\n    if (start >= this.data.length) {\n      return \"\";\n    }\n    return this.stringFromRange(start, stop + 1);\n  }\n  getTextFromInterval(interval) {\n    const start = interval.start;\n    let stop = interval.stop;\n    if (stop >= this.data.length) {\n      stop = this.data.length - 1;\n    }\n    if (start >= this.data.length) {\n      return \"\";\n    }\n    return this.stringFromRange(start, stop + 1);\n  }\n  toString() {\n    return this.stringFromRange(0);\n  }\n  get size() {\n    return this.data.length;\n  }\n  getSourceName() {\n    if (this.name) {\n      return this.name;\n    }\n    return IntStream.UNKNOWN_SOURCE_NAME;\n  }\n  stringFromRange(start, stop) {\n    const data = this.data.slice(start, stop);\n    let result = \"\";\n    data.forEach((value) => {\n      result += String.fromCodePoint(value);\n    });\n    return result;\n  }\n};\n\n// src/WritableToken.ts\nvar isWritableToken = /* @__PURE__ */ __name((candidate) => {\n  return candidate.setText !== void 0;\n}, \"isWritableToken\");\n\n// src/BufferedTokenStream.ts\nvar BufferedTokenStream = class {\n  static {\n    __name(this, \"BufferedTokenStream\");\n  }\n  /**\n   * The {@link TokenSource} from which tokens for this stream are fetched.\n   */\n  tokenSource;\n  /**\n   * A collection of all tokens fetched from the token source. The list is\n   * considered a complete view of the input once {@link fetchedEOF} is set\n   * to `true`.\n   */\n  tokens = [];\n  /**\n   * The index into {@link tokens} of the current token (next token to\n   * {@link consume}). {@link tokens}`[p]` should be\n   * {@link LT LT(1)}.\n   *\n   * This field is set to -1 when the stream is first constructed or when\n   * {@link setTokenSource} is called, indicating that the first token has\n   * not yet been fetched from the token source. For additional information,\n   * see the documentation of {@link IntStream} for a description of\n   * Initializing Methods.\n   */\n  p = -1;\n  /**\n   * Indicates whether the {@link Token.EOF} token has been fetched from\n   * {@link tokenSource} and added to {@link tokens}. This field improves\n   * performance for the following cases:\n   *\n   * - {@link consume}: The lookahead check in {@link consume} to prevent\n   * consuming the EOF symbol is optimized by checking the values of\n   * {@link fetchedEOF} and {@link p} instead of calling {@link LA}.\n   * - {@link fetch}: The check to prevent adding multiple EOF symbols into\n   * {@link tokens} is trivial with this field.\n   */\n  fetchedEOF = false;\n  constructor(tokenSource) {\n    this.tokenSource = tokenSource;\n  }\n  mark() {\n    return 0;\n  }\n  release(_marker) {\n  }\n  reset() {\n    this.seek(0);\n  }\n  seek(index) {\n    this.lazyInit();\n    this.p = this.adjustSeekIndex(index);\n  }\n  get size() {\n    return this.tokens.length;\n  }\n  get index() {\n    return this.p;\n  }\n  get(index) {\n    this.lazyInit();\n    return this.tokens[index];\n  }\n  consume() {\n    let skipEofCheck = false;\n    if (this.p >= 0) {\n      if (this.fetchedEOF) {\n        skipEofCheck = this.p < this.tokens.length - 1;\n      } else {\n        skipEofCheck = this.p < this.tokens.length;\n      }\n    } else {\n      skipEofCheck = false;\n    }\n    if (!skipEofCheck && this.LA(1) === Token.EOF) {\n      throw new Error(\"cannot consume EOF\");\n    }\n    if (this.sync(this.p + 1)) {\n      this.p = this.adjustSeekIndex(this.p + 1);\n    }\n  }\n  /**\n   * Make sure index `i` in tokens has a token.\n   *\n   * @returns {boolean} `true` if a token is located at index `i`, otherwise `false`.\n   */\n  sync(i) {\n    const n2 = i - this.tokens.length + 1;\n    if (n2 > 0) {\n      const fetched = this.fetch(n2);\n      return fetched >= n2;\n    }\n    return true;\n  }\n  /**\n   * Add `n` elements to buffer.\n   *\n   * @returns {number} The actual number of elements added to the buffer.\n   */\n  fetch(n2) {\n    if (this.fetchedEOF) {\n      return 0;\n    }\n    for (let i = 0; i < n2; i++) {\n      const t = this.tokenSource.nextToken();\n      if (isWritableToken(t)) {\n        t.tokenIndex = this.tokens.length;\n      }\n      this.tokens.push(t);\n      if (t.type === Token.EOF) {\n        this.fetchedEOF = true;\n        return i + 1;\n      }\n    }\n    return n2;\n  }\n  /** Get all tokens from start..stop, inclusively. */\n  getTokens(start, stop, types) {\n    this.lazyInit();\n    if (start === void 0 && stop === void 0) {\n      return this.tokens;\n    }\n    start ??= 0;\n    if (stop === void 0) {\n      stop = this.tokens.length - 1;\n    }\n    if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {\n      throw new RangeError(\"start \" + start + \" or stop \" + stop + \" not in 0..\" + (this.tokens.length - 1));\n    }\n    if (start > stop) {\n      return [];\n    }\n    if (types === void 0) {\n      return this.tokens.slice(start, stop + 1);\n    }\n    const subset = [];\n    if (stop >= this.tokens.length) {\n      stop = this.tokens.length - 1;\n    }\n    for (let i = start; i < stop; i++) {\n      const t = this.tokens[i];\n      if (t.type === Token.EOF) {\n        subset.push(t);\n        break;\n      }\n      if (types.has(t.type)) {\n        subset.push(t);\n      }\n    }\n    return subset;\n  }\n  LA(k) {\n    return this.LT(k)?.type ?? Token.INVALID_TYPE;\n  }\n  LB(k) {\n    if (this.p - k < 0) {\n      return null;\n    }\n    return this.tokens[this.p - k];\n  }\n  LT(k) {\n    this.lazyInit();\n    if (k === 0) {\n      return null;\n    }\n    if (k < 0) {\n      return this.LB(-k);\n    }\n    const i = this.p + k - 1;\n    this.sync(i);\n    if (i >= this.tokens.length) {\n      return this.tokens[this.tokens.length - 1];\n    }\n    return this.tokens[i];\n  }\n  /**\n   * Allowed derived classes to modify the behavior of operations which change\n   * the current stream position by adjusting the target token index of a seek\n   * operation. The default implementation simply returns `i`. If an\n   * exception is thrown in this method, the current stream index should not be\n   * changed.\n   *\n   * For example, {@link CommonTokenStream} overrides this method to ensure that\n   * the seek target is always an on-channel token.\n   *\n   * @param  i The target token index.\n   *\n   * @returns The adjusted target token index.\n   */\n  adjustSeekIndex(i) {\n    return i;\n  }\n  lazyInit() {\n    if (this.p === -1) {\n      this.setup();\n    }\n  }\n  setup() {\n    this.sync(0);\n    this.p = this.adjustSeekIndex(0);\n  }\n  /** Reset this token stream by setting its token source. */\n  setTokenSource(tokenSource) {\n    this.tokenSource = tokenSource;\n    this.tokens = [];\n    this.p = -1;\n    this.fetchedEOF = false;\n  }\n  /**\n   * Given a starting index, return the index of the next token on channel.\n   * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n   * on channel between i and EOF.\n   */\n  nextTokenOnChannel(i, channel) {\n    this.sync(i);\n    if (i >= this.tokens.length) {\n      return -1;\n    }\n    let token = this.tokens[i];\n    while (token.channel !== channel) {\n      if (token.type === Token.EOF) {\n        return -1;\n      }\n      i += 1;\n      this.sync(i);\n      token = this.tokens[i];\n    }\n    return i;\n  }\n  /**\n   * Given a starting index, return the index of the previous token on\n   * channel. Return `i` if `tokens[i]` is on channel. Return -1\n   * if there are no tokens on channel between `i` and 0.\n   *\n   * If `i` specifies an index at or after the EOF token, the EOF token\n   * index is returned. This is due to the fact that the EOF token is treated\n   * as though it were on every channel.\n   */\n  previousTokenOnChannel(i, channel) {\n    if (i >= this.tokens.length) {\n      return this.tokens.length - 1;\n    }\n    while (i >= 0) {\n      const token = this.tokens[i];\n      if (token.type === Token.EOF || token.channel === channel) {\n        return i;\n      }\n      --i;\n    }\n    return i;\n  }\n  /**\n   * Collect all tokens on specified channel to the right of\n   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n   * EOF. If channel is -1, find any non default channel token.\n   */\n  getHiddenTokensToRight(tokenIndex, channel) {\n    if (channel === void 0) {\n      channel = -1;\n    }\n    this.lazyInit();\n    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n      throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);\n    }\n    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n    const from = tokenIndex + 1;\n    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n    return this.filterForChannel(from, to, channel);\n  }\n  /**\n   * Collect all tokens on specified channel to the left of\n   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n   * If channel is -1, find any non default channel token.\n   */\n  getHiddenTokensToLeft(tokenIndex, channel) {\n    if (channel === void 0) {\n      channel = -1;\n    }\n    this.lazyInit();\n    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n      throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);\n    }\n    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n    if (prevOnChannel === tokenIndex - 1) {\n      return void 0;\n    }\n    const from = prevOnChannel + 1;\n    const to = tokenIndex - 1;\n    return this.filterForChannel(from, to, channel);\n  }\n  filterForChannel(left, right, channel) {\n    const hidden = [];\n    for (let i = left; i < right + 1; i++) {\n      const t = this.tokens[i];\n      if (channel === -1) {\n        if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n          hidden.push(t);\n        }\n      } else if (t.channel === channel) {\n        hidden.push(t);\n      }\n    }\n    if (hidden.length === 0) {\n      return void 0;\n    }\n    return hidden;\n  }\n  getSourceName() {\n    return this.tokenSource.sourceName;\n  }\n  /** Get the text of all tokens in this buffer. */\n  getText() {\n    return this.getTextFromInterval(Interval.of(0, this.size - 1));\n  }\n  getTextFromInterval(interval) {\n    const start = interval.start;\n    let stop = interval.stop;\n    if (start < 0 || stop < 0) {\n      return \"\";\n    }\n    this.sync(stop);\n    if (stop >= this.tokens.length) {\n      stop = this.tokens.length - 1;\n    }\n    let result = \"\";\n    for (let i = start; i <= stop; ++i) {\n      const t = this.tokens[i];\n      if (t.type === Token.EOF) {\n        break;\n      }\n      result += t.text;\n    }\n    return result;\n  }\n  getTextFromContext(ctx) {\n    return this.getTextFromInterval(ctx.getSourceInterval());\n  }\n  getTextFromRange(start, stop) {\n    if (start !== null && stop !== null) {\n      return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));\n    }\n    return \"\";\n  }\n  /** Get all tokens from lexer until EOF. */\n  fill() {\n    this.lazyInit();\n    while (this.fetch(1e3) === 1e3) {\n      ;\n    }\n  }\n  setLine(line) {\n    this.tokenSource.line = line;\n  }\n  setColumn(column) {\n    this.tokenSource.column = column;\n  }\n};\n\n// src/CommonTokenStream.ts\nvar CommonTokenStream = class extends BufferedTokenStream {\n  static {\n    __name(this, \"CommonTokenStream\");\n  }\n  /**\n   * Specifies the channel to use for filtering tokens.\n   *\n   *\n   * The default value is {@link Token.DEFAULT_CHANNEL}, which matches the\n   * default channel assigned to tokens created by the lexer.\n   */\n  channel = Token.DEFAULT_CHANNEL;\n  constructor(lexer, channel) {\n    super(lexer);\n    this.channel = channel ?? Token.DEFAULT_CHANNEL;\n  }\n  adjustSeekIndex(i) {\n    return this.nextTokenOnChannel(i, this.channel);\n  }\n  LB(k) {\n    if (k === 0 || this.index - k < 0) {\n      return null;\n    }\n    let i = this.index;\n    let n2 = 1;\n    while (n2 <= k) {\n      i = this.previousTokenOnChannel(i - 1, this.channel);\n      n2 += 1;\n    }\n    if (i < 0) {\n      return null;\n    }\n    return this.tokens[i];\n  }\n  LT(k) {\n    this.lazyInit();\n    if (k === 0) {\n      return null;\n    }\n    if (k < 0) {\n      return this.LB(-k);\n    }\n    let i = this.index;\n    let n2 = 1;\n    while (n2 < k) {\n      if (this.sync(i + 1)) {\n        i = this.nextTokenOnChannel(i + 1, this.channel);\n      }\n      n2 += 1;\n    }\n    return this.tokens[i];\n  }\n  // Count EOF just once.\n  getNumberOfOnChannelTokens() {\n    let n2 = 0;\n    this.fill();\n    for (const t of this.tokens) {\n      if (t.channel === this.channel) {\n        n2 += 1;\n      }\n      if (t.type === Token.EOF) {\n        break;\n      }\n    }\n    return n2;\n  }\n};\n\n// src/tree/xpath/XPathLexer.ts\nvar XPathLexer = class _XPathLexer extends Lexer {\n  static {\n    __name(this, \"XPathLexer\");\n  }\n  static TOKEN_REF = 1;\n  static RULE_REF = 2;\n  static ANYWHERE = 3;\n  static ROOT = 4;\n  static WILDCARD = 5;\n  static BANG = 6;\n  static ID = 7;\n  static STRING = 8;\n  static channelNames = [\n    \"DEFAULT_TOKEN_CHANNEL\",\n    \"HIDDEN\"\n  ];\n  static literalNames = [\n    null,\n    null,\n    null,\n    \"'//'\",\n    \"'/'\",\n    \"'*'\",\n    \"'!'\"\n  ];\n  static symbolicNames = [\n    null,\n    \"TOKEN_REF\",\n    \"RULE_REF\",\n    \"ANYWHERE\",\n    \"ROOT\",\n    \"WILDCARD\",\n    \"BANG\",\n    \"ID\",\n    \"STRING\"\n  ];\n  static modeNames = [\n    \"DEFAULT_MODE\"\n  ];\n  static ruleNames = [\n    \"ANYWHERE\",\n    \"ROOT\",\n    \"WILDCARD\",\n    \"BANG\",\n    \"ID\",\n    \"NameChar\",\n    \"NameStartChar\",\n    \"STRING\"\n  ];\n  constructor(input) {\n    super(input);\n    this.interpreter = new LexerATNSimulator(this, _XPathLexer._ATN, _XPathLexer.decisionsToDFA, new PredictionContextCache());\n  }\n  get grammarFileName() {\n    return \"XPathLexer.g4\";\n  }\n  get literalNames() {\n    return _XPathLexer.literalNames;\n  }\n  get symbolicNames() {\n    return _XPathLexer.symbolicNames;\n  }\n  get ruleNames() {\n    return _XPathLexer.ruleNames;\n  }\n  get serializedATN() {\n    return _XPathLexer._serializedATN;\n  }\n  get channelNames() {\n    return _XPathLexer.channelNames;\n  }\n  get modeNames() {\n    return _XPathLexer.modeNames;\n  }\n  action(localContext, ruleIndex, actionIndex) {\n    switch (ruleIndex) {\n      case 4:\n        this.ID_action(localContext, actionIndex);\n        break;\n    }\n  }\n  ID_action(localContext, actionIndex) {\n    switch (actionIndex) {\n      case 0:\n        const text = this.text;\n        if (text.charAt(0) === text.charAt(0).toUpperCase()) {\n          this.type = _XPathLexer.TOKEN_REF;\n        } else {\n          this.type = _XPathLexer.RULE_REF;\n        }\n        break;\n    }\n  }\n  static _serializedATN = [\n    4,\n    0,\n    8,\n    48,\n    6,\n    -1,\n    2,\n    0,\n    7,\n    0,\n    2,\n    1,\n    7,\n    1,\n    2,\n    2,\n    7,\n    2,\n    2,\n    3,\n    7,\n    3,\n    2,\n    4,\n    7,\n    4,\n    2,\n    5,\n    7,\n    5,\n    2,\n    6,\n    7,\n    6,\n    2,\n    7,\n    7,\n    7,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    2,\n    1,\n    2,\n    1,\n    3,\n    1,\n    3,\n    1,\n    4,\n    1,\n    4,\n    5,\n    4,\n    29,\n    8,\n    4,\n    10,\n    4,\n    12,\n    4,\n    32,\n    9,\n    4,\n    1,\n    4,\n    1,\n    4,\n    1,\n    5,\n    1,\n    5,\n    1,\n    6,\n    1,\n    6,\n    1,\n    7,\n    1,\n    7,\n    5,\n    7,\n    42,\n    8,\n    7,\n    10,\n    7,\n    12,\n    7,\n    45,\n    9,\n    7,\n    1,\n    7,\n    1,\n    7,\n    1,\n    43,\n    0,\n    8,\n    1,\n    3,\n    3,\n    4,\n    5,\n    5,\n    7,\n    6,\n    9,\n    7,\n    11,\n    0,\n    13,\n    0,\n    15,\n    8,\n    1,\n    0,\n    2,\n    784,\n    0,\n    0,\n    8,\n    14,\n    27,\n    48,\n    57,\n    65,\n    90,\n    95,\n    95,\n    97,\n    122,\n    127,\n    159,\n    170,\n    170,\n    173,\n    173,\n    181,\n    181,\n    186,\n    186,\n    192,\n    214,\n    216,\n    246,\n    248,\n    705,\n    710,\n    721,\n    736,\n    740,\n    748,\n    748,\n    750,\n    750,\n    768,\n    884,\n    886,\n    887,\n    890,\n    893,\n    895,\n    895,\n    902,\n    902,\n    904,\n    906,\n    908,\n    908,\n    910,\n    929,\n    931,\n    1013,\n    1015,\n    1153,\n    1155,\n    1159,\n    1162,\n    1327,\n    1329,\n    1366,\n    1369,\n    1369,\n    1376,\n    1416,\n    1425,\n    1469,\n    1471,\n    1471,\n    1473,\n    1474,\n    1476,\n    1477,\n    1479,\n    1479,\n    1488,\n    1514,\n    1519,\n    1522,\n    1536,\n    1541,\n    1552,\n    1562,\n    1564,\n    1564,\n    1568,\n    1641,\n    1646,\n    1747,\n    1749,\n    1757,\n    1759,\n    1768,\n    1770,\n    1788,\n    1791,\n    1791,\n    1807,\n    1866,\n    1869,\n    1969,\n    1984,\n    2037,\n    2042,\n    2042,\n    2045,\n    2045,\n    2048,\n    2093,\n    2112,\n    2139,\n    2144,\n    2154,\n    2160,\n    2183,\n    2185,\n    2190,\n    2192,\n    2193,\n    2200,\n    2403,\n    2406,\n    2415,\n    2417,\n    2435,\n    2437,\n    2444,\n    2447,\n    2448,\n    2451,\n    2472,\n    2474,\n    2480,\n    2482,\n    2482,\n    2486,\n    2489,\n    2492,\n    2500,\n    2503,\n    2504,\n    2507,\n    2510,\n    2519,\n    2519,\n    2524,\n    2525,\n    2527,\n    2531,\n    2534,\n    2545,\n    2556,\n    2556,\n    2558,\n    2558,\n    2561,\n    2563,\n    2565,\n    2570,\n    2575,\n    2576,\n    2579,\n    2600,\n    2602,\n    2608,\n    2610,\n    2611,\n    2613,\n    2614,\n    2616,\n    2617,\n    2620,\n    2620,\n    2622,\n    2626,\n    2631,\n    2632,\n    2635,\n    2637,\n    2641,\n    2641,\n    2649,\n    2652,\n    2654,\n    2654,\n    2662,\n    2677,\n    2689,\n    2691,\n    2693,\n    2701,\n    2703,\n    2705,\n    2707,\n    2728,\n    2730,\n    2736,\n    2738,\n    2739,\n    2741,\n    2745,\n    2748,\n    2757,\n    2759,\n    2761,\n    2763,\n    2765,\n    2768,\n    2768,\n    2784,\n    2787,\n    2790,\n    2799,\n    2809,\n    2815,\n    2817,\n    2819,\n    2821,\n    2828,\n    2831,\n    2832,\n    2835,\n    2856,\n    2858,\n    2864,\n    2866,\n    2867,\n    2869,\n    2873,\n    2876,\n    2884,\n    2887,\n    2888,\n    2891,\n    2893,\n    2901,\n    2903,\n    2908,\n    2909,\n    2911,\n    2915,\n    2918,\n    2927,\n    2929,\n    2929,\n    2946,\n    2947,\n    2949,\n    2954,\n    2958,\n    2960,\n    2962,\n    2965,\n    2969,\n    2970,\n    2972,\n    2972,\n    2974,\n    2975,\n    2979,\n    2980,\n    2984,\n    2986,\n    2990,\n    3001,\n    3006,\n    3010,\n    3014,\n    3016,\n    3018,\n    3021,\n    3024,\n    3024,\n    3031,\n    3031,\n    3046,\n    3055,\n    3072,\n    3084,\n    3086,\n    3088,\n    3090,\n    3112,\n    3114,\n    3129,\n    3132,\n    3140,\n    3142,\n    3144,\n    3146,\n    3149,\n    3157,\n    3158,\n    3160,\n    3162,\n    3165,\n    3165,\n    3168,\n    3171,\n    3174,\n    3183,\n    3200,\n    3203,\n    3205,\n    3212,\n    3214,\n    3216,\n    3218,\n    3240,\n    3242,\n    3251,\n    3253,\n    3257,\n    3260,\n    3268,\n    3270,\n    3272,\n    3274,\n    3277,\n    3285,\n    3286,\n    3293,\n    3294,\n    3296,\n    3299,\n    3302,\n    3311,\n    3313,\n    3315,\n    3328,\n    3340,\n    3342,\n    3344,\n    3346,\n    3396,\n    3398,\n    3400,\n    3402,\n    3406,\n    3412,\n    3415,\n    3423,\n    3427,\n    3430,\n    3439,\n    3450,\n    3455,\n    3457,\n    3459,\n    3461,\n    3478,\n    3482,\n    3505,\n    3507,\n    3515,\n    3517,\n    3517,\n    3520,\n    3526,\n    3530,\n    3530,\n    3535,\n    3540,\n    3542,\n    3542,\n    3544,\n    3551,\n    3558,\n    3567,\n    3570,\n    3571,\n    3585,\n    3642,\n    3648,\n    3662,\n    3664,\n    3673,\n    3713,\n    3714,\n    3716,\n    3716,\n    3718,\n    3722,\n    3724,\n    3747,\n    3749,\n    3749,\n    3751,\n    3773,\n    3776,\n    3780,\n    3782,\n    3782,\n    3784,\n    3790,\n    3792,\n    3801,\n    3804,\n    3807,\n    3840,\n    3840,\n    3864,\n    3865,\n    3872,\n    3881,\n    3893,\n    3893,\n    3895,\n    3895,\n    3897,\n    3897,\n    3902,\n    3911,\n    3913,\n    3948,\n    3953,\n    3972,\n    3974,\n    3991,\n    3993,\n    4028,\n    4038,\n    4038,\n    4096,\n    4169,\n    4176,\n    4253,\n    4256,\n    4293,\n    4295,\n    4295,\n    4301,\n    4301,\n    4304,\n    4346,\n    4348,\n    4680,\n    4682,\n    4685,\n    4688,\n    4694,\n    4696,\n    4696,\n    4698,\n    4701,\n    4704,\n    4744,\n    4746,\n    4749,\n    4752,\n    4784,\n    4786,\n    4789,\n    4792,\n    4798,\n    4800,\n    4800,\n    4802,\n    4805,\n    4808,\n    4822,\n    4824,\n    4880,\n    4882,\n    4885,\n    4888,\n    4954,\n    4957,\n    4959,\n    4992,\n    5007,\n    5024,\n    5109,\n    5112,\n    5117,\n    5121,\n    5740,\n    5743,\n    5759,\n    5761,\n    5786,\n    5792,\n    5866,\n    5870,\n    5880,\n    5888,\n    5909,\n    5919,\n    5940,\n    5952,\n    5971,\n    5984,\n    5996,\n    5998,\n    6e3,\n    6002,\n    6003,\n    6016,\n    6099,\n    6103,\n    6103,\n    6108,\n    6109,\n    6112,\n    6121,\n    6155,\n    6169,\n    6176,\n    6264,\n    6272,\n    6314,\n    6320,\n    6389,\n    6400,\n    6430,\n    6432,\n    6443,\n    6448,\n    6459,\n    6470,\n    6509,\n    6512,\n    6516,\n    6528,\n    6571,\n    6576,\n    6601,\n    6608,\n    6617,\n    6656,\n    6683,\n    6688,\n    6750,\n    6752,\n    6780,\n    6783,\n    6793,\n    6800,\n    6809,\n    6823,\n    6823,\n    6832,\n    6845,\n    6847,\n    6862,\n    6912,\n    6988,\n    6992,\n    7001,\n    7019,\n    7027,\n    7040,\n    7155,\n    7168,\n    7223,\n    7232,\n    7241,\n    7245,\n    7293,\n    7296,\n    7304,\n    7312,\n    7354,\n    7357,\n    7359,\n    7376,\n    7378,\n    7380,\n    7418,\n    7424,\n    7957,\n    7960,\n    7965,\n    7968,\n    8005,\n    8008,\n    8013,\n    8016,\n    8023,\n    8025,\n    8025,\n    8027,\n    8027,\n    8029,\n    8029,\n    8031,\n    8061,\n    8064,\n    8116,\n    8118,\n    8124,\n    8126,\n    8126,\n    8130,\n    8132,\n    8134,\n    8140,\n    8144,\n    8147,\n    8150,\n    8155,\n    8160,\n    8172,\n    8178,\n    8180,\n    8182,\n    8188,\n    8203,\n    8207,\n    8234,\n    8238,\n    8255,\n    8256,\n    8276,\n    8276,\n    8288,\n    8292,\n    8294,\n    8303,\n    8305,\n    8305,\n    8319,\n    8319,\n    8336,\n    8348,\n    8400,\n    8412,\n    8417,\n    8417,\n    8421,\n    8432,\n    8450,\n    8450,\n    8455,\n    8455,\n    8458,\n    8467,\n    8469,\n    8469,\n    8473,\n    8477,\n    8484,\n    8484,\n    8486,\n    8486,\n    8488,\n    8488,\n    8490,\n    8493,\n    8495,\n    8505,\n    8508,\n    8511,\n    8517,\n    8521,\n    8526,\n    8526,\n    8544,\n    8584,\n    11264,\n    11492,\n    11499,\n    11507,\n    11520,\n    11557,\n    11559,\n    11559,\n    11565,\n    11565,\n    11568,\n    11623,\n    11631,\n    11631,\n    11647,\n    11670,\n    11680,\n    11686,\n    11688,\n    11694,\n    11696,\n    11702,\n    11704,\n    11710,\n    11712,\n    11718,\n    11720,\n    11726,\n    11728,\n    11734,\n    11736,\n    11742,\n    11744,\n    11775,\n    11823,\n    11823,\n    12293,\n    12295,\n    12321,\n    12335,\n    12337,\n    12341,\n    12344,\n    12348,\n    12353,\n    12438,\n    12441,\n    12442,\n    12445,\n    12447,\n    12449,\n    12538,\n    12540,\n    12543,\n    12549,\n    12591,\n    12593,\n    12686,\n    12704,\n    12735,\n    12784,\n    12799,\n    13312,\n    19903,\n    19968,\n    42124,\n    42192,\n    42237,\n    42240,\n    42508,\n    42512,\n    42539,\n    42560,\n    42607,\n    42612,\n    42621,\n    42623,\n    42737,\n    42775,\n    42783,\n    42786,\n    42888,\n    42891,\n    42954,\n    42960,\n    42961,\n    42963,\n    42963,\n    42965,\n    42969,\n    42994,\n    43047,\n    43052,\n    43052,\n    43072,\n    43123,\n    43136,\n    43205,\n    43216,\n    43225,\n    43232,\n    43255,\n    43259,\n    43259,\n    43261,\n    43309,\n    43312,\n    43347,\n    43360,\n    43388,\n    43392,\n    43456,\n    43471,\n    43481,\n    43488,\n    43518,\n    43520,\n    43574,\n    43584,\n    43597,\n    43600,\n    43609,\n    43616,\n    43638,\n    43642,\n    43714,\n    43739,\n    43741,\n    43744,\n    43759,\n    43762,\n    43766,\n    43777,\n    43782,\n    43785,\n    43790,\n    43793,\n    43798,\n    43808,\n    43814,\n    43816,\n    43822,\n    43824,\n    43866,\n    43868,\n    43881,\n    43888,\n    44010,\n    44012,\n    44013,\n    44016,\n    44025,\n    44032,\n    55203,\n    55216,\n    55238,\n    55243,\n    55291,\n    63744,\n    64109,\n    64112,\n    64217,\n    64256,\n    64262,\n    64275,\n    64279,\n    64285,\n    64296,\n    64298,\n    64310,\n    64312,\n    64316,\n    64318,\n    64318,\n    64320,\n    64321,\n    64323,\n    64324,\n    64326,\n    64433,\n    64467,\n    64829,\n    64848,\n    64911,\n    64914,\n    64967,\n    65008,\n    65019,\n    65024,\n    65039,\n    65056,\n    65071,\n    65075,\n    65076,\n    65101,\n    65103,\n    65136,\n    65140,\n    65142,\n    65276,\n    65279,\n    65279,\n    65296,\n    65305,\n    65313,\n    65338,\n    65343,\n    65343,\n    65345,\n    65370,\n    65382,\n    65470,\n    65474,\n    65479,\n    65482,\n    65487,\n    65490,\n    65495,\n    65498,\n    65500,\n    65529,\n    65531,\n    65536,\n    65547,\n    65549,\n    65574,\n    65576,\n    65594,\n    65596,\n    65597,\n    65599,\n    65613,\n    65616,\n    65629,\n    65664,\n    65786,\n    65856,\n    65908,\n    66045,\n    66045,\n    66176,\n    66204,\n    66208,\n    66256,\n    66272,\n    66272,\n    66304,\n    66335,\n    66349,\n    66378,\n    66384,\n    66426,\n    66432,\n    66461,\n    66464,\n    66499,\n    66504,\n    66511,\n    66513,\n    66517,\n    66560,\n    66717,\n    66720,\n    66729,\n    66736,\n    66771,\n    66776,\n    66811,\n    66816,\n    66855,\n    66864,\n    66915,\n    66928,\n    66938,\n    66940,\n    66954,\n    66956,\n    66962,\n    66964,\n    66965,\n    66967,\n    66977,\n    66979,\n    66993,\n    66995,\n    67001,\n    67003,\n    67004,\n    67072,\n    67382,\n    67392,\n    67413,\n    67424,\n    67431,\n    67456,\n    67461,\n    67463,\n    67504,\n    67506,\n    67514,\n    67584,\n    67589,\n    67592,\n    67592,\n    67594,\n    67637,\n    67639,\n    67640,\n    67644,\n    67644,\n    67647,\n    67669,\n    67680,\n    67702,\n    67712,\n    67742,\n    67808,\n    67826,\n    67828,\n    67829,\n    67840,\n    67861,\n    67872,\n    67897,\n    67968,\n    68023,\n    68030,\n    68031,\n    68096,\n    68099,\n    68101,\n    68102,\n    68108,\n    68115,\n    68117,\n    68119,\n    68121,\n    68149,\n    68152,\n    68154,\n    68159,\n    68159,\n    68192,\n    68220,\n    68224,\n    68252,\n    68288,\n    68295,\n    68297,\n    68326,\n    68352,\n    68405,\n    68416,\n    68437,\n    68448,\n    68466,\n    68480,\n    68497,\n    68608,\n    68680,\n    68736,\n    68786,\n    68800,\n    68850,\n    68864,\n    68903,\n    68912,\n    68921,\n    69248,\n    69289,\n    69291,\n    69292,\n    69296,\n    69297,\n    69373,\n    69404,\n    69415,\n    69415,\n    69424,\n    69456,\n    69488,\n    69509,\n    69552,\n    69572,\n    69600,\n    69622,\n    69632,\n    69702,\n    69734,\n    69749,\n    69759,\n    69818,\n    69821,\n    69821,\n    69826,\n    69826,\n    69837,\n    69837,\n    69840,\n    69864,\n    69872,\n    69881,\n    69888,\n    69940,\n    69942,\n    69951,\n    69956,\n    69959,\n    69968,\n    70003,\n    70006,\n    70006,\n    70016,\n    70084,\n    70089,\n    70092,\n    70094,\n    70106,\n    70108,\n    70108,\n    70144,\n    70161,\n    70163,\n    70199,\n    70206,\n    70209,\n    70272,\n    70278,\n    70280,\n    70280,\n    70282,\n    70285,\n    70287,\n    70301,\n    70303,\n    70312,\n    70320,\n    70378,\n    70384,\n    70393,\n    70400,\n    70403,\n    70405,\n    70412,\n    70415,\n    70416,\n    70419,\n    70440,\n    70442,\n    70448,\n    70450,\n    70451,\n    70453,\n    70457,\n    70459,\n    70468,\n    70471,\n    70472,\n    70475,\n    70477,\n    70480,\n    70480,\n    70487,\n    70487,\n    70493,\n    70499,\n    70502,\n    70508,\n    70512,\n    70516,\n    70656,\n    70730,\n    70736,\n    70745,\n    70750,\n    70753,\n    70784,\n    70853,\n    70855,\n    70855,\n    70864,\n    70873,\n    71040,\n    71093,\n    71096,\n    71104,\n    71128,\n    71133,\n    71168,\n    71232,\n    71236,\n    71236,\n    71248,\n    71257,\n    71296,\n    71352,\n    71360,\n    71369,\n    71424,\n    71450,\n    71453,\n    71467,\n    71472,\n    71481,\n    71488,\n    71494,\n    71680,\n    71738,\n    71840,\n    71913,\n    71935,\n    71942,\n    71945,\n    71945,\n    71948,\n    71955,\n    71957,\n    71958,\n    71960,\n    71989,\n    71991,\n    71992,\n    71995,\n    72003,\n    72016,\n    72025,\n    72096,\n    72103,\n    72106,\n    72151,\n    72154,\n    72161,\n    72163,\n    72164,\n    72192,\n    72254,\n    72263,\n    72263,\n    72272,\n    72345,\n    72349,\n    72349,\n    72368,\n    72440,\n    72704,\n    72712,\n    72714,\n    72758,\n    72760,\n    72768,\n    72784,\n    72793,\n    72818,\n    72847,\n    72850,\n    72871,\n    72873,\n    72886,\n    72960,\n    72966,\n    72968,\n    72969,\n    72971,\n    73014,\n    73018,\n    73018,\n    73020,\n    73021,\n    73023,\n    73031,\n    73040,\n    73049,\n    73056,\n    73061,\n    73063,\n    73064,\n    73066,\n    73102,\n    73104,\n    73105,\n    73107,\n    73112,\n    73120,\n    73129,\n    73440,\n    73462,\n    73472,\n    73488,\n    73490,\n    73530,\n    73534,\n    73538,\n    73552,\n    73561,\n    73648,\n    73648,\n    73728,\n    74649,\n    74752,\n    74862,\n    74880,\n    75075,\n    77712,\n    77808,\n    77824,\n    78933,\n    82944,\n    83526,\n    92160,\n    92728,\n    92736,\n    92766,\n    92768,\n    92777,\n    92784,\n    92862,\n    92864,\n    92873,\n    92880,\n    92909,\n    92912,\n    92916,\n    92928,\n    92982,\n    92992,\n    92995,\n    93008,\n    93017,\n    93027,\n    93047,\n    93053,\n    93071,\n    93760,\n    93823,\n    93952,\n    94026,\n    94031,\n    94087,\n    94095,\n    94111,\n    94176,\n    94177,\n    94179,\n    94180,\n    94192,\n    94193,\n    94208,\n    100343,\n    100352,\n    101589,\n    101632,\n    101640,\n    110576,\n    110579,\n    110581,\n    110587,\n    110589,\n    110590,\n    110592,\n    110882,\n    110898,\n    110898,\n    110928,\n    110930,\n    110933,\n    110933,\n    110948,\n    110951,\n    110960,\n    111355,\n    113664,\n    113770,\n    113776,\n    113788,\n    113792,\n    113800,\n    113808,\n    113817,\n    113821,\n    113822,\n    113824,\n    113827,\n    118528,\n    118573,\n    118576,\n    118598,\n    119141,\n    119145,\n    119149,\n    119170,\n    119173,\n    119179,\n    119210,\n    119213,\n    119362,\n    119364,\n    119808,\n    119892,\n    119894,\n    119964,\n    119966,\n    119967,\n    119970,\n    119970,\n    119973,\n    119974,\n    119977,\n    119980,\n    119982,\n    119993,\n    119995,\n    119995,\n    119997,\n    120003,\n    120005,\n    120069,\n    120071,\n    120074,\n    120077,\n    120084,\n    120086,\n    120092,\n    120094,\n    120121,\n    120123,\n    120126,\n    120128,\n    120132,\n    120134,\n    120134,\n    120138,\n    120144,\n    120146,\n    120485,\n    120488,\n    120512,\n    120514,\n    120538,\n    120540,\n    120570,\n    120572,\n    120596,\n    120598,\n    120628,\n    120630,\n    120654,\n    120656,\n    120686,\n    120688,\n    120712,\n    120714,\n    120744,\n    120746,\n    120770,\n    120772,\n    120779,\n    120782,\n    120831,\n    121344,\n    121398,\n    121403,\n    121452,\n    121461,\n    121461,\n    121476,\n    121476,\n    121499,\n    121503,\n    121505,\n    121519,\n    122624,\n    122654,\n    122661,\n    122666,\n    122880,\n    122886,\n    122888,\n    122904,\n    122907,\n    122913,\n    122915,\n    122916,\n    122918,\n    122922,\n    122928,\n    122989,\n    123023,\n    123023,\n    123136,\n    123180,\n    123184,\n    123197,\n    123200,\n    123209,\n    123214,\n    123214,\n    123536,\n    123566,\n    123584,\n    123641,\n    124112,\n    124153,\n    124896,\n    124902,\n    124904,\n    124907,\n    124909,\n    124910,\n    124912,\n    124926,\n    124928,\n    125124,\n    125136,\n    125142,\n    125184,\n    125259,\n    125264,\n    125273,\n    126464,\n    126467,\n    126469,\n    126495,\n    126497,\n    126498,\n    126500,\n    126500,\n    126503,\n    126503,\n    126505,\n    126514,\n    126516,\n    126519,\n    126521,\n    126521,\n    126523,\n    126523,\n    126530,\n    126530,\n    126535,\n    126535,\n    126537,\n    126537,\n    126539,\n    126539,\n    126541,\n    126543,\n    126545,\n    126546,\n    126548,\n    126548,\n    126551,\n    126551,\n    126553,\n    126553,\n    126555,\n    126555,\n    126557,\n    126557,\n    126559,\n    126559,\n    126561,\n    126562,\n    126564,\n    126564,\n    126567,\n    126570,\n    126572,\n    126578,\n    126580,\n    126583,\n    126585,\n    126588,\n    126590,\n    126590,\n    126592,\n    126601,\n    126603,\n    126619,\n    126625,\n    126627,\n    126629,\n    126633,\n    126635,\n    126651,\n    130032,\n    130041,\n    131072,\n    173791,\n    173824,\n    177977,\n    177984,\n    178205,\n    178208,\n    183969,\n    183984,\n    191456,\n    194560,\n    195101,\n    196608,\n    201546,\n    201552,\n    205743,\n    917505,\n    917505,\n    917536,\n    917631,\n    917760,\n    917999,\n    662,\n    0,\n    65,\n    90,\n    97,\n    122,\n    170,\n    170,\n    181,\n    181,\n    186,\n    186,\n    192,\n    214,\n    216,\n    246,\n    248,\n    705,\n    710,\n    721,\n    736,\n    740,\n    748,\n    748,\n    750,\n    750,\n    880,\n    884,\n    886,\n    887,\n    890,\n    893,\n    895,\n    895,\n    902,\n    902,\n    904,\n    906,\n    908,\n    908,\n    910,\n    929,\n    931,\n    1013,\n    1015,\n    1153,\n    1162,\n    1327,\n    1329,\n    1366,\n    1369,\n    1369,\n    1376,\n    1416,\n    1488,\n    1514,\n    1519,\n    1522,\n    1568,\n    1610,\n    1646,\n    1647,\n    1649,\n    1747,\n    1749,\n    1749,\n    1765,\n    1766,\n    1774,\n    1775,\n    1786,\n    1788,\n    1791,\n    1791,\n    1808,\n    1808,\n    1810,\n    1839,\n    1869,\n    1957,\n    1969,\n    1969,\n    1994,\n    2026,\n    2036,\n    2037,\n    2042,\n    2042,\n    2048,\n    2069,\n    2074,\n    2074,\n    2084,\n    2084,\n    2088,\n    2088,\n    2112,\n    2136,\n    2144,\n    2154,\n    2160,\n    2183,\n    2185,\n    2190,\n    2208,\n    2249,\n    2308,\n    2361,\n    2365,\n    2365,\n    2384,\n    2384,\n    2392,\n    2401,\n    2417,\n    2432,\n    2437,\n    2444,\n    2447,\n    2448,\n    2451,\n    2472,\n    2474,\n    2480,\n    2482,\n    2482,\n    2486,\n    2489,\n    2493,\n    2493,\n    2510,\n    2510,\n    2524,\n    2525,\n    2527,\n    2529,\n    2544,\n    2545,\n    2556,\n    2556,\n    2565,\n    2570,\n    2575,\n    2576,\n    2579,\n    2600,\n    2602,\n    2608,\n    2610,\n    2611,\n    2613,\n    2614,\n    2616,\n    2617,\n    2649,\n    2652,\n    2654,\n    2654,\n    2674,\n    2676,\n    2693,\n    2701,\n    2703,\n    2705,\n    2707,\n    2728,\n    2730,\n    2736,\n    2738,\n    2739,\n    2741,\n    2745,\n    2749,\n    2749,\n    2768,\n    2768,\n    2784,\n    2785,\n    2809,\n    2809,\n    2821,\n    2828,\n    2831,\n    2832,\n    2835,\n    2856,\n    2858,\n    2864,\n    2866,\n    2867,\n    2869,\n    2873,\n    2877,\n    2877,\n    2908,\n    2909,\n    2911,\n    2913,\n    2929,\n    2929,\n    2947,\n    2947,\n    2949,\n    2954,\n    2958,\n    2960,\n    2962,\n    2965,\n    2969,\n    2970,\n    2972,\n    2972,\n    2974,\n    2975,\n    2979,\n    2980,\n    2984,\n    2986,\n    2990,\n    3001,\n    3024,\n    3024,\n    3077,\n    3084,\n    3086,\n    3088,\n    3090,\n    3112,\n    3114,\n    3129,\n    3133,\n    3133,\n    3160,\n    3162,\n    3165,\n    3165,\n    3168,\n    3169,\n    3200,\n    3200,\n    3205,\n    3212,\n    3214,\n    3216,\n    3218,\n    3240,\n    3242,\n    3251,\n    3253,\n    3257,\n    3261,\n    3261,\n    3293,\n    3294,\n    3296,\n    3297,\n    3313,\n    3314,\n    3332,\n    3340,\n    3342,\n    3344,\n    3346,\n    3386,\n    3389,\n    3389,\n    3406,\n    3406,\n    3412,\n    3414,\n    3423,\n    3425,\n    3450,\n    3455,\n    3461,\n    3478,\n    3482,\n    3505,\n    3507,\n    3515,\n    3517,\n    3517,\n    3520,\n    3526,\n    3585,\n    3632,\n    3634,\n    3635,\n    3648,\n    3654,\n    3713,\n    3714,\n    3716,\n    3716,\n    3718,\n    3722,\n    3724,\n    3747,\n    3749,\n    3749,\n    3751,\n    3760,\n    3762,\n    3763,\n    3773,\n    3773,\n    3776,\n    3780,\n    3782,\n    3782,\n    3804,\n    3807,\n    3840,\n    3840,\n    3904,\n    3911,\n    3913,\n    3948,\n    3976,\n    3980,\n    4096,\n    4138,\n    4159,\n    4159,\n    4176,\n    4181,\n    4186,\n    4189,\n    4193,\n    4193,\n    4197,\n    4198,\n    4206,\n    4208,\n    4213,\n    4225,\n    4238,\n    4238,\n    4256,\n    4293,\n    4295,\n    4295,\n    4301,\n    4301,\n    4304,\n    4346,\n    4348,\n    4680,\n    4682,\n    4685,\n    4688,\n    4694,\n    4696,\n    4696,\n    4698,\n    4701,\n    4704,\n    4744,\n    4746,\n    4749,\n    4752,\n    4784,\n    4786,\n    4789,\n    4792,\n    4798,\n    4800,\n    4800,\n    4802,\n    4805,\n    4808,\n    4822,\n    4824,\n    4880,\n    4882,\n    4885,\n    4888,\n    4954,\n    4992,\n    5007,\n    5024,\n    5109,\n    5112,\n    5117,\n    5121,\n    5740,\n    5743,\n    5759,\n    5761,\n    5786,\n    5792,\n    5866,\n    5870,\n    5880,\n    5888,\n    5905,\n    5919,\n    5937,\n    5952,\n    5969,\n    5984,\n    5996,\n    5998,\n    6e3,\n    6016,\n    6067,\n    6103,\n    6103,\n    6108,\n    6108,\n    6176,\n    6264,\n    6272,\n    6276,\n    6279,\n    6312,\n    6314,\n    6314,\n    6320,\n    6389,\n    6400,\n    6430,\n    6480,\n    6509,\n    6512,\n    6516,\n    6528,\n    6571,\n    6576,\n    6601,\n    6656,\n    6678,\n    6688,\n    6740,\n    6823,\n    6823,\n    6917,\n    6963,\n    6981,\n    6988,\n    7043,\n    7072,\n    7086,\n    7087,\n    7098,\n    7141,\n    7168,\n    7203,\n    7245,\n    7247,\n    7258,\n    7293,\n    7296,\n    7304,\n    7312,\n    7354,\n    7357,\n    7359,\n    7401,\n    7404,\n    7406,\n    7411,\n    7413,\n    7414,\n    7418,\n    7418,\n    7424,\n    7615,\n    7680,\n    7957,\n    7960,\n    7965,\n    7968,\n    8005,\n    8008,\n    8013,\n    8016,\n    8023,\n    8025,\n    8025,\n    8027,\n    8027,\n    8029,\n    8029,\n    8031,\n    8061,\n    8064,\n    8116,\n    8118,\n    8124,\n    8126,\n    8126,\n    8130,\n    8132,\n    8134,\n    8140,\n    8144,\n    8147,\n    8150,\n    8155,\n    8160,\n    8172,\n    8178,\n    8180,\n    8182,\n    8188,\n    8305,\n    8305,\n    8319,\n    8319,\n    8336,\n    8348,\n    8450,\n    8450,\n    8455,\n    8455,\n    8458,\n    8467,\n    8469,\n    8469,\n    8473,\n    8477,\n    8484,\n    8484,\n    8486,\n    8486,\n    8488,\n    8488,\n    8490,\n    8493,\n    8495,\n    8505,\n    8508,\n    8511,\n    8517,\n    8521,\n    8526,\n    8526,\n    8544,\n    8584,\n    11264,\n    11492,\n    11499,\n    11502,\n    11506,\n    11507,\n    11520,\n    11557,\n    11559,\n    11559,\n    11565,\n    11565,\n    11568,\n    11623,\n    11631,\n    11631,\n    11648,\n    11670,\n    11680,\n    11686,\n    11688,\n    11694,\n    11696,\n    11702,\n    11704,\n    11710,\n    11712,\n    11718,\n    11720,\n    11726,\n    11728,\n    11734,\n    11736,\n    11742,\n    11823,\n    11823,\n    12293,\n    12295,\n    12321,\n    12329,\n    12337,\n    12341,\n    12344,\n    12348,\n    12353,\n    12438,\n    12445,\n    12447,\n    12449,\n    12538,\n    12540,\n    12543,\n    12549,\n    12591,\n    12593,\n    12686,\n    12704,\n    12735,\n    12784,\n    12799,\n    13312,\n    19903,\n    19968,\n    42124,\n    42192,\n    42237,\n    42240,\n    42508,\n    42512,\n    42527,\n    42538,\n    42539,\n    42560,\n    42606,\n    42623,\n    42653,\n    42656,\n    42735,\n    42775,\n    42783,\n    42786,\n    42888,\n    42891,\n    42954,\n    42960,\n    42961,\n    42963,\n    42963,\n    42965,\n    42969,\n    42994,\n    43009,\n    43011,\n    43013,\n    43015,\n    43018,\n    43020,\n    43042,\n    43072,\n    43123,\n    43138,\n    43187,\n    43250,\n    43255,\n    43259,\n    43259,\n    43261,\n    43262,\n    43274,\n    43301,\n    43312,\n    43334,\n    43360,\n    43388,\n    43396,\n    43442,\n    43471,\n    43471,\n    43488,\n    43492,\n    43494,\n    43503,\n    43514,\n    43518,\n    43520,\n    43560,\n    43584,\n    43586,\n    43588,\n    43595,\n    43616,\n    43638,\n    43642,\n    43642,\n    43646,\n    43695,\n    43697,\n    43697,\n    43701,\n    43702,\n    43705,\n    43709,\n    43712,\n    43712,\n    43714,\n    43714,\n    43739,\n    43741,\n    43744,\n    43754,\n    43762,\n    43764,\n    43777,\n    43782,\n    43785,\n    43790,\n    43793,\n    43798,\n    43808,\n    43814,\n    43816,\n    43822,\n    43824,\n    43866,\n    43868,\n    43881,\n    43888,\n    44002,\n    44032,\n    55203,\n    55216,\n    55238,\n    55243,\n    55291,\n    63744,\n    64109,\n    64112,\n    64217,\n    64256,\n    64262,\n    64275,\n    64279,\n    64285,\n    64285,\n    64287,\n    64296,\n    64298,\n    64310,\n    64312,\n    64316,\n    64318,\n    64318,\n    64320,\n    64321,\n    64323,\n    64324,\n    64326,\n    64433,\n    64467,\n    64829,\n    64848,\n    64911,\n    64914,\n    64967,\n    65008,\n    65019,\n    65136,\n    65140,\n    65142,\n    65276,\n    65313,\n    65338,\n    65345,\n    65370,\n    65382,\n    65470,\n    65474,\n    65479,\n    65482,\n    65487,\n    65490,\n    65495,\n    65498,\n    65500,\n    65536,\n    65547,\n    65549,\n    65574,\n    65576,\n    65594,\n    65596,\n    65597,\n    65599,\n    65613,\n    65616,\n    65629,\n    65664,\n    65786,\n    65856,\n    65908,\n    66176,\n    66204,\n    66208,\n    66256,\n    66304,\n    66335,\n    66349,\n    66378,\n    66384,\n    66421,\n    66432,\n    66461,\n    66464,\n    66499,\n    66504,\n    66511,\n    66513,\n    66517,\n    66560,\n    66717,\n    66736,\n    66771,\n    66776,\n    66811,\n    66816,\n    66855,\n    66864,\n    66915,\n    66928,\n    66938,\n    66940,\n    66954,\n    66956,\n    66962,\n    66964,\n    66965,\n    66967,\n    66977,\n    66979,\n    66993,\n    66995,\n    67001,\n    67003,\n    67004,\n    67072,\n    67382,\n    67392,\n    67413,\n    67424,\n    67431,\n    67456,\n    67461,\n    67463,\n    67504,\n    67506,\n    67514,\n    67584,\n    67589,\n    67592,\n    67592,\n    67594,\n    67637,\n    67639,\n    67640,\n    67644,\n    67644,\n    67647,\n    67669,\n    67680,\n    67702,\n    67712,\n    67742,\n    67808,\n    67826,\n    67828,\n    67829,\n    67840,\n    67861,\n    67872,\n    67897,\n    67968,\n    68023,\n    68030,\n    68031,\n    68096,\n    68096,\n    68112,\n    68115,\n    68117,\n    68119,\n    68121,\n    68149,\n    68192,\n    68220,\n    68224,\n    68252,\n    68288,\n    68295,\n    68297,\n    68324,\n    68352,\n    68405,\n    68416,\n    68437,\n    68448,\n    68466,\n    68480,\n    68497,\n    68608,\n    68680,\n    68736,\n    68786,\n    68800,\n    68850,\n    68864,\n    68899,\n    69248,\n    69289,\n    69296,\n    69297,\n    69376,\n    69404,\n    69415,\n    69415,\n    69424,\n    69445,\n    69488,\n    69505,\n    69552,\n    69572,\n    69600,\n    69622,\n    69635,\n    69687,\n    69745,\n    69746,\n    69749,\n    69749,\n    69763,\n    69807,\n    69840,\n    69864,\n    69891,\n    69926,\n    69956,\n    69956,\n    69959,\n    69959,\n    69968,\n    70002,\n    70006,\n    70006,\n    70019,\n    70066,\n    70081,\n    70084,\n    70106,\n    70106,\n    70108,\n    70108,\n    70144,\n    70161,\n    70163,\n    70187,\n    70207,\n    70208,\n    70272,\n    70278,\n    70280,\n    70280,\n    70282,\n    70285,\n    70287,\n    70301,\n    70303,\n    70312,\n    70320,\n    70366,\n    70405,\n    70412,\n    70415,\n    70416,\n    70419,\n    70440,\n    70442,\n    70448,\n    70450,\n    70451,\n    70453,\n    70457,\n    70461,\n    70461,\n    70480,\n    70480,\n    70493,\n    70497,\n    70656,\n    70708,\n    70727,\n    70730,\n    70751,\n    70753,\n    70784,\n    70831,\n    70852,\n    70853,\n    70855,\n    70855,\n    71040,\n    71086,\n    71128,\n    71131,\n    71168,\n    71215,\n    71236,\n    71236,\n    71296,\n    71338,\n    71352,\n    71352,\n    71424,\n    71450,\n    71488,\n    71494,\n    71680,\n    71723,\n    71840,\n    71903,\n    71935,\n    71942,\n    71945,\n    71945,\n    71948,\n    71955,\n    71957,\n    71958,\n    71960,\n    71983,\n    71999,\n    71999,\n    72001,\n    72001,\n    72096,\n    72103,\n    72106,\n    72144,\n    72161,\n    72161,\n    72163,\n    72163,\n    72192,\n    72192,\n    72203,\n    72242,\n    72250,\n    72250,\n    72272,\n    72272,\n    72284,\n    72329,\n    72349,\n    72349,\n    72368,\n    72440,\n    72704,\n    72712,\n    72714,\n    72750,\n    72768,\n    72768,\n    72818,\n    72847,\n    72960,\n    72966,\n    72968,\n    72969,\n    72971,\n    73008,\n    73030,\n    73030,\n    73056,\n    73061,\n    73063,\n    73064,\n    73066,\n    73097,\n    73112,\n    73112,\n    73440,\n    73458,\n    73474,\n    73474,\n    73476,\n    73488,\n    73490,\n    73523,\n    73648,\n    73648,\n    73728,\n    74649,\n    74752,\n    74862,\n    74880,\n    75075,\n    77712,\n    77808,\n    77824,\n    78895,\n    78913,\n    78918,\n    82944,\n    83526,\n    92160,\n    92728,\n    92736,\n    92766,\n    92784,\n    92862,\n    92880,\n    92909,\n    92928,\n    92975,\n    92992,\n    92995,\n    93027,\n    93047,\n    93053,\n    93071,\n    93760,\n    93823,\n    93952,\n    94026,\n    94032,\n    94032,\n    94099,\n    94111,\n    94176,\n    94177,\n    94179,\n    94179,\n    94208,\n    100343,\n    100352,\n    101589,\n    101632,\n    101640,\n    110576,\n    110579,\n    110581,\n    110587,\n    110589,\n    110590,\n    110592,\n    110882,\n    110898,\n    110898,\n    110928,\n    110930,\n    110933,\n    110933,\n    110948,\n    110951,\n    110960,\n    111355,\n    113664,\n    113770,\n    113776,\n    113788,\n    113792,\n    113800,\n    113808,\n    113817,\n    119808,\n    119892,\n    119894,\n    119964,\n    119966,\n    119967,\n    119970,\n    119970,\n    119973,\n    119974,\n    119977,\n    119980,\n    119982,\n    119993,\n    119995,\n    119995,\n    119997,\n    120003,\n    120005,\n    120069,\n    120071,\n    120074,\n    120077,\n    120084,\n    120086,\n    120092,\n    120094,\n    120121,\n    120123,\n    120126,\n    120128,\n    120132,\n    120134,\n    120134,\n    120138,\n    120144,\n    120146,\n    120485,\n    120488,\n    120512,\n    120514,\n    120538,\n    120540,\n    120570,\n    120572,\n    120596,\n    120598,\n    120628,\n    120630,\n    120654,\n    120656,\n    120686,\n    120688,\n    120712,\n    120714,\n    120744,\n    120746,\n    120770,\n    120772,\n    120779,\n    122624,\n    122654,\n    122661,\n    122666,\n    122928,\n    122989,\n    123136,\n    123180,\n    123191,\n    123197,\n    123214,\n    123214,\n    123536,\n    123565,\n    123584,\n    123627,\n    124112,\n    124139,\n    124896,\n    124902,\n    124904,\n    124907,\n    124909,\n    124910,\n    124912,\n    124926,\n    124928,\n    125124,\n    125184,\n    125251,\n    125259,\n    125259,\n    126464,\n    126467,\n    126469,\n    126495,\n    126497,\n    126498,\n    126500,\n    126500,\n    126503,\n    126503,\n    126505,\n    126514,\n    126516,\n    126519,\n    126521,\n    126521,\n    126523,\n    126523,\n    126530,\n    126530,\n    126535,\n    126535,\n    126537,\n    126537,\n    126539,\n    126539,\n    126541,\n    126543,\n    126545,\n    126546,\n    126548,\n    126548,\n    126551,\n    126551,\n    126553,\n    126553,\n    126555,\n    126555,\n    126557,\n    126557,\n    126559,\n    126559,\n    126561,\n    126562,\n    126564,\n    126564,\n    126567,\n    126570,\n    126572,\n    126578,\n    126580,\n    126583,\n    126585,\n    126588,\n    126590,\n    126590,\n    126592,\n    126601,\n    126603,\n    126619,\n    126625,\n    126627,\n    126629,\n    126633,\n    126635,\n    126651,\n    131072,\n    173791,\n    173824,\n    177977,\n    177984,\n    178205,\n    178208,\n    183969,\n    183984,\n    191456,\n    194560,\n    195101,\n    196608,\n    201546,\n    201552,\n    205743,\n    47,\n    0,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    3,\n    1,\n    0,\n    0,\n    0,\n    0,\n    5,\n    1,\n    0,\n    0,\n    0,\n    0,\n    7,\n    1,\n    0,\n    0,\n    0,\n    0,\n    9,\n    1,\n    0,\n    0,\n    0,\n    0,\n    15,\n    1,\n    0,\n    0,\n    0,\n    1,\n    17,\n    1,\n    0,\n    0,\n    0,\n    3,\n    20,\n    1,\n    0,\n    0,\n    0,\n    5,\n    22,\n    1,\n    0,\n    0,\n    0,\n    7,\n    24,\n    1,\n    0,\n    0,\n    0,\n    9,\n    26,\n    1,\n    0,\n    0,\n    0,\n    11,\n    35,\n    1,\n    0,\n    0,\n    0,\n    13,\n    37,\n    1,\n    0,\n    0,\n    0,\n    15,\n    39,\n    1,\n    0,\n    0,\n    0,\n    17,\n    18,\n    5,\n    47,\n    0,\n    0,\n    18,\n    19,\n    5,\n    47,\n    0,\n    0,\n    19,\n    2,\n    1,\n    0,\n    0,\n    0,\n    20,\n    21,\n    5,\n    47,\n    0,\n    0,\n    21,\n    4,\n    1,\n    0,\n    0,\n    0,\n    22,\n    23,\n    5,\n    42,\n    0,\n    0,\n    23,\n    6,\n    1,\n    0,\n    0,\n    0,\n    24,\n    25,\n    5,\n    33,\n    0,\n    0,\n    25,\n    8,\n    1,\n    0,\n    0,\n    0,\n    26,\n    30,\n    3,\n    13,\n    6,\n    0,\n    27,\n    29,\n    3,\n    11,\n    5,\n    0,\n    28,\n    27,\n    1,\n    0,\n    0,\n    0,\n    29,\n    32,\n    1,\n    0,\n    0,\n    0,\n    30,\n    28,\n    1,\n    0,\n    0,\n    0,\n    30,\n    31,\n    1,\n    0,\n    0,\n    0,\n    31,\n    33,\n    1,\n    0,\n    0,\n    0,\n    32,\n    30,\n    1,\n    0,\n    0,\n    0,\n    33,\n    34,\n    6,\n    4,\n    0,\n    0,\n    34,\n    10,\n    1,\n    0,\n    0,\n    0,\n    35,\n    36,\n    7,\n    0,\n    0,\n    0,\n    36,\n    12,\n    1,\n    0,\n    0,\n    0,\n    37,\n    38,\n    7,\n    1,\n    0,\n    0,\n    38,\n    14,\n    1,\n    0,\n    0,\n    0,\n    39,\n    43,\n    5,\n    39,\n    0,\n    0,\n    40,\n    42,\n    9,\n    0,\n    0,\n    0,\n    41,\n    40,\n    1,\n    0,\n    0,\n    0,\n    42,\n    45,\n    1,\n    0,\n    0,\n    0,\n    43,\n    44,\n    1,\n    0,\n    0,\n    0,\n    43,\n    41,\n    1,\n    0,\n    0,\n    0,\n    44,\n    46,\n    1,\n    0,\n    0,\n    0,\n    45,\n    43,\n    1,\n    0,\n    0,\n    0,\n    46,\n    47,\n    5,\n    39,\n    0,\n    0,\n    47,\n    16,\n    1,\n    0,\n    0,\n    0,\n    3,\n    0,\n    30,\n    43,\n    1,\n    1,\n    4,\n    0\n  ];\n  static __ATN;\n  static get _ATN() {\n    if (!_XPathLexer.__ATN) {\n      _XPathLexer.__ATN = new ATNDeserializer().deserialize(_XPathLexer._serializedATN);\n    }\n    return _XPathLexer.__ATN;\n  }\n  static vocabulary = new Vocabulary(_XPathLexer.literalNames, _XPathLexer.symbolicNames, []);\n  get vocabulary() {\n    return _XPathLexer.vocabulary;\n  }\n  static decisionsToDFA = _XPathLexer._ATN.decisionToState.map((ds, index) => {\n    return new DFA(ds, index);\n  });\n};\n\n// src/tree/xpath/XPathLexerErrorListener.ts\nvar XPathLexerErrorListener = class extends BaseErrorListener {\n  static {\n    __name(this, \"XPathLexerErrorListener\");\n  }\n  syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {\n  }\n};\n\n// src/tree/xpath/XPathElement.ts\nvar XPathElement = class {\n  static {\n    __name(this, \"XPathElement\");\n  }\n  invert;\n  nodeName;\n  /**\n   * Construct element like `/ID` or `ID` or `/*` etc... `nodeName` is undefined if just node\n   *\n   * @param nodeName The name of the node; may be undefined for any node.\n   */\n  constructor(nodeName) {\n    this.nodeName = nodeName;\n    this.invert = false;\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathRuleAnywhereElement.ts\nvar XPathRuleAnywhereElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathRuleAnywhereElement\");\n  }\n  ruleIndex;\n  constructor(ruleName, ruleIndex) {\n    super(ruleName);\n    this.ruleIndex = ruleIndex;\n  }\n  evaluate(t) {\n    return Trees.findAllRuleNodes(t, this.ruleIndex);\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathRuleAnywhereElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathRuleElement.ts\nvar XPathRuleElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathRuleElement\");\n  }\n  ruleIndex;\n  constructor(ruleName, ruleIndex) {\n    super(ruleName);\n    this.ruleIndex = ruleIndex;\n  }\n  evaluate(t) {\n    const nodes = [];\n    for (const c of Trees.getChildren(t)) {\n      if (c instanceof ParserRuleContext) {\n        if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {\n          nodes.push(c);\n        }\n      }\n    }\n    return nodes;\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathRuleElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathTokenAnywhereElement.ts\nvar XPathTokenAnywhereElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathTokenAnywhereElement\");\n  }\n  tokenType;\n  constructor(tokenName, tokenType) {\n    super(tokenName);\n    this.tokenType = tokenType;\n  }\n  evaluate(t) {\n    return Trees.findAllTokenNodes(t, this.tokenType);\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathTokenAnywhereElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathTokenElement.ts\nvar XPathTokenElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathTokenElement\");\n  }\n  tokenType;\n  constructor(tokenName, tokenType) {\n    super(tokenName);\n    this.tokenType = tokenType;\n  }\n  evaluate(t) {\n    const nodes = [];\n    for (const c of Trees.getChildren(t)) {\n      if (c instanceof TerminalNode && c.symbol) {\n        if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {\n          nodes.push(c);\n        }\n      }\n    }\n    return nodes;\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathTokenElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathWildcardAnywhereElement.ts\nvar XPathWildcardAnywhereElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathWildcardAnywhereElement\");\n  }\n  constructor() {\n    super(XPath.WILDCARD);\n  }\n  evaluate(t) {\n    if (this.invert) {\n      return [];\n    }\n    return Trees.descendants(t);\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathWildcardAnywhereElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPathWildcardElement.ts\nvar XPathWildcardElement = class extends XPathElement {\n  static {\n    __name(this, \"XPathWildcardElement\");\n  }\n  constructor() {\n    super(XPath.WILDCARD);\n  }\n  evaluate(t) {\n    const kids = [];\n    if (this.invert) {\n      return kids;\n    }\n    for (const c of Trees.getChildren(t)) {\n      kids.push(c);\n    }\n    return kids;\n  }\n  toString() {\n    const inv = this.invert ? \"!\" : \"\";\n    return \"XPathWildcardElement[\" + inv + this.nodeName + \"]\";\n  }\n};\n\n// src/tree/xpath/XPath.ts\nvar XPath = class _XPath {\n  static {\n    __name(this, \"XPath\");\n  }\n  static WILDCARD = \"*\";\n  // word not operator/separator\n  static NOT = \"!\";\n  // word for invert operator\n  path;\n  elements;\n  parser;\n  constructor(parser, path) {\n    this.parser = parser;\n    this.path = path;\n    this.elements = this.split(path);\n  }\n  static findAll(tree, xpath, parser) {\n    const p = new _XPath(parser, xpath);\n    return p.evaluate(tree);\n  }\n  // TODO: check for invalid token/rule names, bad syntax\n  split(path) {\n    const lexer = new XPathLexer(CharStream.fromString(path));\n    lexer.recover = (e) => {\n      throw e;\n    };\n    lexer.removeErrorListeners();\n    lexer.addErrorListener(new XPathLexerErrorListener());\n    const tokenStream = new CommonTokenStream(lexer);\n    try {\n      tokenStream.fill();\n    } catch (e) {\n      if (e instanceof LexerNoViableAltException) {\n        const pos = lexer.column;\n        const msg = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\n        throw new RangeError(msg);\n      }\n      throw e;\n    }\n    const tokens = tokenStream.getTokens();\n    const elements = [];\n    const n2 = tokens.length;\n    let i = 0;\n    loop:\n      while (i < n2) {\n        const el = tokens[i];\n        let next;\n        switch (el.type) {\n          case XPathLexer.ROOT:\n          case XPathLexer.ANYWHERE:\n            const anywhere = el.type === XPathLexer.ANYWHERE;\n            i++;\n            next = tokens[i];\n            const invert = next.type === XPathLexer.BANG;\n            if (invert) {\n              i++;\n              next = tokens[i];\n            }\n            const pathElement = this.getXPathElement(next, anywhere);\n            pathElement.invert = invert;\n            elements.push(pathElement);\n            i++;\n            break;\n          case XPathLexer.TOKEN_REF:\n          case XPathLexer.RULE_REF:\n          case XPathLexer.WILDCARD:\n            elements.push(this.getXPathElement(el, false));\n            ++i;\n            break;\n          case Token.EOF:\n            break loop;\n          default:\n            throw new Error(\"Unknown path element \" + el);\n        }\n      }\n    return elements;\n  }\n  /**\n   * Return a list of all nodes starting at `t` as root that satisfy the\n   * path. The root `/` is relative to the node passed to {@link evaluate}.\n   */\n  evaluate(t) {\n    const dummyRoot = new ParserRuleContext(null);\n    dummyRoot.addChild(t);\n    let work = /* @__PURE__ */ new Set([dummyRoot]);\n    let i = 0;\n    while (i < this.elements.length) {\n      const next = /* @__PURE__ */ new Set();\n      for (const node of work) {\n        if (node.getChildCount() > 0) {\n          const matching = this.elements[i].evaluate(node);\n          matching.forEach((tree) => {\n            next.add(tree);\n          }, next);\n        }\n      }\n      i++;\n      work = next;\n    }\n    return work;\n  }\n  /**\n   * Convert word like `*` or `ID` or `expr` to a path\n   * element. `anywhere` is `true` if `//` precedes the\n   * word.\n   */\n  getXPathElement(wordToken, anywhere) {\n    if (wordToken.type === Token.EOF) {\n      throw new Error(\"Missing path element at end of path\");\n    }\n    const word = wordToken.text;\n    if (word == null) {\n      throw new Error(\"Expected wordToken to have text content.\");\n    }\n    const ttype = this.parser.getTokenType(word);\n    const ruleIndex = this.parser.getRuleIndex(word);\n    switch (wordToken.type) {\n      case XPathLexer.WILDCARD:\n        return anywhere ? new XPathWildcardAnywhereElement() : new XPathWildcardElement();\n      case XPathLexer.TOKEN_REF:\n      case XPathLexer.STRING:\n        if (ttype === Token.INVALID_TYPE) {\n          throw new Error(word + \" at index \" + wordToken.start + \" isn't a valid token name\");\n        }\n        return anywhere ? new XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement(word, ttype);\n      default:\n        if (ruleIndex === -1) {\n          throw new Error(word + \" at index \" + wordToken.start + \" isn't a valid rule name\");\n        }\n        return anywhere ? new XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement(word, ruleIndex);\n    }\n  }\n};\n\n// src/tree/pattern/Chunk.ts\nvar Chunk = class {\n  static {\n    __name(this, \"Chunk\");\n  }\n};\n\n// src/tree/pattern/ParseTreeMatch.ts\nvar ParseTreeMatch = class {\n  static {\n    __name(this, \"ParseTreeMatch\");\n  }\n  /**\n   * This is the backing field for {@link #getTree()}.\n   */\n  tree;\n  /**\n   * This is the backing field for {@link #getPattern()}.\n   */\n  pattern;\n  /**\n   * This is the backing field for {@link #getLabels()}.\n   */\n  labels;\n  /**\n   * This is the backing field for {@link #getMismatchedNode()}.\n   */\n  mismatchedNode;\n  /**\n   * Constructs a new instance of {@link ParseTreeMatch} from the specified\n   * parse tree and pattern.\n   *\n   * @param tree The parse tree to match against the pattern.\n   * @param pattern The parse tree pattern.\n   * @param labels A mapping from label names to collections of\n   * {@link ParseTree} objects located by the tree pattern matching process.\n   * @param mismatchedNode The first node which failed to match the tree\n   * pattern during the matching process.\n   */\n  constructor(tree, pattern, labels, mismatchedNode) {\n    this.tree = tree;\n    this.pattern = pattern;\n    this.labels = labels;\n    this.mismatchedNode = mismatchedNode;\n  }\n  /**\n   * Get the last node associated with a specific `label`.\n   *\n   * For example, for pattern `<id:ID>`, `get(\"id\")` returns the\n   * node matched for that `ID`. If more than one node\n   * matched the specified label, only the last is returned. If there is\n   * no node associated with the label, this returns `null`.\n   *\n   * Pattern tags like `<ID>` and `<expr>` without labels are\n   * considered to be labeled with `ID` and `expr`, respectively.\n   *\n   * @param label The label to check.\n   *\n   * @returns The last {@link ParseTree} to match a tag with the specified\n   * label, or `null` if no parse tree matched a tag with the label.\n   */\n  get(label) {\n    const parseTrees = this.labels.get(label);\n    if (!parseTrees || parseTrees.length === 0) {\n      return null;\n    }\n    return parseTrees[parseTrees.length - 1];\n  }\n  /**\n   * Return all nodes matching a rule or token tag with the specified label.\n   *\n   * If the `label` is the name of a parser rule or token in the\n   * grammar, the resulting list will contain both the parse trees matching\n   * rule or tags explicitly labeled with the label and the complete set of\n   * parse trees matching the labeled and unlabeled tags in the pattern for\n   * the parser rule or token. For example, if `label` is `\"foo\"`,\n   * the result will contain *all* of the following.\n   *\n   * - Parse tree nodes matching tags of the form `<foo:anyRuleName>` and\n   * `<foo:AnyTokenName>`.\n   * - Parse tree nodes matching tags of the form `<anyLabel:foo>`.\n   * - Parse tree nodes matching tags of the form `<foo>`.\n   *\n   * @param label The label.\n   *\n   * @returns A collection of all {@link ParseTree} nodes matching tags with\n   * the specified `label`. If no nodes matched the label, an empty list\n   * is returned.\n   */\n  getAll(label) {\n    const nodes = this.labels.get(label);\n    return nodes ?? [];\n  }\n  /**\n   * Return a mapping from label -> [list of nodes].\n   *\n   * The map includes special entries corresponding to the names of rules and\n   * tokens referenced in tags in the original pattern. For additional\n   * information, see the description of {@link getAll(String)}.\n   *\n   * @returns A mapping from labels to parse tree nodes. If the parse tree\n   * pattern did not contain any rule or token tags, this map will be empty.\n   */\n  getLabels() {\n    return this.labels;\n  }\n  /**\n   * Get the node at which we first detected a mismatch.\n   *\n   * @returns the node at which we first detected a mismatch, or `null`\n   * if the match was successful.\n   */\n  getMismatchedNode() {\n    return this.mismatchedNode;\n  }\n  /**\n   * Gets a value indicating whether the match operation succeeded.\n   *\n   * @returns `true` if the match operation succeeded; otherwise, `false`.\n   */\n  succeeded() {\n    return !this.mismatchedNode;\n  }\n  /**\n   * Get the tree pattern we are matching against.\n   *\n   * @returns The tree pattern we are matching against.\n   */\n  getPattern() {\n    return this.pattern;\n  }\n  /**\n   * Get the parse tree we are trying to match to a pattern.\n   *\n   * @returns The {@link ParseTree} we are trying to match to a pattern.\n   */\n  getTree() {\n    return this.tree;\n  }\n  toString() {\n    return `Match ${this.succeeded() ? \"succeeded\" : \"failed\"}; found ${this.getLabels().size} labels`;\n  }\n};\n\n// src/tree/pattern/ParseTreePattern.ts\nvar ParseTreePattern = class {\n  static {\n    __name(this, \"ParseTreePattern\");\n  }\n  /**\n   * This is the backing field for {@link #getPatternRuleIndex()}.\n   */\n  patternRuleIndex;\n  /**\n   * This is the backing field for {@link #getPattern()}.\n   */\n  pattern;\n  /**\n   * This is the backing field for {@link #getPatternTree()}.\n   */\n  patternTree;\n  /**\n   * This is the backing field for {@link #getMatcher()}.\n   */\n  matcher;\n  /**\n   * Construct a new instance of the {@link ParseTreePattern} class.\n   *\n   * @param matcher The {@link ParseTreePatternMatcher} which created this\n   * tree pattern.\n   * @param pattern The tree pattern in concrete syntax form.\n   * @param patternRuleIndex The parser rule which serves as the root of the\n   * tree pattern.\n   * @param patternTree The tree pattern in {@link ParseTree} form.\n   */\n  constructor(matcher, pattern, patternRuleIndex, patternTree) {\n    this.matcher = matcher;\n    this.patternRuleIndex = patternRuleIndex;\n    this.pattern = pattern;\n    this.patternTree = patternTree;\n  }\n  /**\n   * Match a specific parse tree against this tree pattern.\n   *\n   * @param tree The parse tree to match against this tree pattern.\n   * @returns A {@link ParseTreeMatch} object describing the result of the\n   * match operation. The {@link ParseTreeMatch#succeeded()} method can be\n   * used to determine whether or not the match was successful.\n   */\n  match(tree) {\n    return this.matcher.match(tree, this);\n  }\n  /**\n   * Determine whether or not a parse tree matches this tree pattern.\n   *\n   * @param tree The parse tree to match against this tree pattern.\n   * @returns `true` if `tree` is a match for the current tree\n   * pattern; otherwise, `false`.\n   */\n  matches(tree) {\n    return this.matcher.match(tree, this).succeeded();\n  }\n  /**\n   * Find all nodes using XPath and then try to match those subtrees against\n   * this tree pattern.\n   *\n   * @param tree The {@link ParseTree} to match against this pattern.\n   * @param xpath An expression matching the nodes\n   *\n   * @returns A collection of {@link ParseTreeMatch} objects describing the\n   * successful matches. Unsuccessful matches are omitted from the result,\n   * regardless of the reason for the failure.\n   */\n  findAll(tree, xpath) {\n    const subtrees = XPath.findAll(tree, xpath, this.matcher.getParser());\n    const matches = new Array();\n    for (const t of subtrees) {\n      const match = this.match(t);\n      if (match.succeeded()) {\n        matches.push(match);\n      }\n    }\n    return matches;\n  }\n  /**\n   * Get the {@link ParseTreePatternMatcher} which created this tree pattern.\n   *\n   * @returns The {@link ParseTreePatternMatcher} which created this tree\n   * pattern.\n   */\n  getMatcher() {\n    return this.matcher;\n  }\n  /**\n   * Get the tree pattern in concrete syntax form.\n   *\n   * @returns The tree pattern in concrete syntax form.\n   */\n  getPattern() {\n    return this.pattern;\n  }\n  /**\n   * Get the parser rule which serves as the outermost rule for the tree\n   * pattern.\n   *\n   * @returns The parser rule which serves as the outermost rule for the tree\n   * pattern.\n   */\n  getPatternRuleIndex() {\n    return this.patternRuleIndex;\n  }\n  /**\n   * Get the tree pattern as a {@link ParseTree}. The rule and token tags from\n   * the pattern are present in the parse tree as terminal nodes with a symbol\n   * of type {@link RuleTagToken} or {@link TokenTagToken}.\n   *\n   * @returns The tree pattern as a {@link ParseTree}.\n   */\n  getPatternTree() {\n    return this.patternTree;\n  }\n};\n\n// src/InputMismatchException.ts\nvar InputMismatchException = class extends RecognitionException {\n  static {\n    __name(this, \"InputMismatchException\");\n  }\n  constructor(recognizer) {\n    super({ message: \"\", recognizer, input: recognizer.inputStream, ctx: recognizer.context });\n    this.offendingToken = recognizer.getCurrentToken();\n  }\n};\n\n// src/FailedPredicateException.ts\nvar FailedPredicateException = class extends RecognitionException {\n  static {\n    __name(this, \"FailedPredicateException\");\n  }\n  ruleIndex = 0;\n  predicateIndex = 0;\n  predicate;\n  constructor(recognizer, predicate, message = null) {\n    super({\n      message: formatMessage(predicate ?? \"no predicate\", message ?? null),\n      recognizer,\n      input: recognizer.inputStream,\n      ctx: recognizer.context\n    });\n    const s = recognizer.atn.states[recognizer.state];\n    const trans = s.transitions[0];\n    if (trans instanceof PredicateTransition) {\n      this.ruleIndex = trans.ruleIndex;\n      this.predicateIndex = trans.predIndex;\n    } else {\n      this.ruleIndex = 0;\n      this.predicateIndex = 0;\n    }\n    this.predicate = predicate;\n    this.offendingToken = recognizer.getCurrentToken();\n  }\n};\nvar formatMessage = /* @__PURE__ */ __name((predicate, message) => {\n  if (message !== null) {\n    return message;\n  }\n  return \"failed predicate: {\" + predicate + \"}?\";\n}, \"formatMessage\");\n\n// src/DefaultErrorStrategy.ts\nvar DefaultErrorStrategy = class {\n  static {\n    __name(this, \"DefaultErrorStrategy\");\n  }\n  /**\n   * Indicates whether the error strategy is currently \"recovering from an\n   * error\". This is used to suppress reporting multiple error messages while\n   * attempting to recover from a detected syntax error.\n   *\n   * @see #inErrorRecoveryMode\n   */\n  errorRecoveryMode = false;\n  /**\n   * The index into the input stream where the last error occurred.\n   * \tThis is used to prevent infinite loops where an error is found\n   *  but no token is consumed during recovery...another error is found,\n   *  ad nauseam.  This is a failsafe mechanism to guarantee that at least\n   *  one token/tree node is consumed for two errors.\n   */\n  lastErrorIndex = -1;\n  lastErrorStates = new IntervalSet();\n  /**\n   * This field is used to propagate information about the lookahead following\n   * the previous match. Since prediction prefers completing the current rule\n   * to error recovery efforts, error reporting may occur later than the\n   * original point where it was discoverable. The original context is used to\n   * compute the true expected sets as though the reporting occurred as early\n   * as possible.\n   */\n  nextTokensContext = null;\n  nextTokenState = 0;\n  /**\n   * The default implementation simply calls {@link endErrorCondition} to\n   * ensure that the handler is not in error recovery mode.\n   */\n  reset(recognizer) {\n    this.endErrorCondition(recognizer);\n  }\n  /**\n   * This method is called to enter error recovery mode when a recognition\n   * exception is reported.\n   *\n   * @param _recognizer the parser instance\n   */\n  beginErrorCondition(_recognizer) {\n    this.errorRecoveryMode = true;\n  }\n  inErrorRecoveryMode(_recognizer) {\n    return this.errorRecoveryMode;\n  }\n  /**\n   * This method is called to leave error recovery mode after recovering from\n   * a recognition exception.\n   */\n  endErrorCondition(_recognizer) {\n    this.errorRecoveryMode = false;\n    this.lastErrorStates = new IntervalSet();\n    this.lastErrorIndex = -1;\n  }\n  /**\n   * The default implementation simply calls {@link endErrorCondition}.\n   */\n  reportMatch(recognizer) {\n    this.endErrorCondition(recognizer);\n  }\n  /**\n   * The default implementation returns immediately if the handler is already\n   * in error recovery mode. Otherwise, it calls {@link beginErrorCondition}\n   * and dispatches the reporting task based on the runtime type of `e`\n   * according to the following table.\n   *\n   * - {@link NoViableAltException}: Dispatches the call to {@link reportNoViableAlternative}\n   * - {@link InputMismatchException}: Dispatches the call to {@link reportInputMismatch}\n   * - {@link FailedPredicateException}: Dispatches the call to {@link reportFailedPredicate}\n   * - All other types: calls {@link Parser.notifyErrorListeners} to report the exception\n   */\n  reportError(recognizer, e) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n    this.beginErrorCondition(recognizer);\n    if (e instanceof NoViableAltException) {\n      this.reportNoViableAlternative(recognizer, e);\n    } else if (e instanceof InputMismatchException) {\n      this.reportInputMismatch(recognizer, e);\n    } else if (e instanceof FailedPredicateException) {\n      this.reportFailedPredicate(recognizer, e);\n    } else {\n      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n    }\n  }\n  /**\n   * The default implementation resynchronizes the parser by consuming tokens\n   * until we find one in the resynchronization set--loosely the set of tokens\n   * that can follow the current rule.\n   *\n   */\n  recover(recognizer, _e) {\n    if (this.lastErrorIndex === recognizer.inputStream?.index && this.lastErrorStates.contains(recognizer.state)) {\n      recognizer.consume();\n    }\n    this.lastErrorIndex = recognizer.inputStream?.index ?? 0;\n    this.lastErrorStates.addOne(recognizer.state);\n    const followSet = this.getErrorRecoverySet(recognizer);\n    this.consumeUntil(recognizer, followSet);\n  }\n  /**\n   * The default implementation of {@link ANTLRErrorStrategy.sync} makes sure\n   * that the current lookahead symbol is consistent with what were expecting\n   * at this point in the ATN. You can call this anytime but ANTLR only\n   * generates code to check before subrules/loops and each iteration.\n   *\n   * Implements Jim Idle's magic sync mechanism in closures and optional\n   * subrules. E.g.,\n   *\n   * ```\n   * a : sync ( stuff sync )* ;\n   * sync : {consume to what can follow sync} ;\n   * ```\n   *\n   * At the start of a sub rule upon error, {@link sync} performs single\n   * token deletion, if possible. If it can't do that, it bails on the current\n   * rule and uses the default error recovery, which consumes until the\n   * resynchronization set of the current rule.\n   *\n   * If the sub rule is optional (`(...)?`, `(...)*`, or block\n   * with an empty alternative), then the expected set includes what follows\n   * the subrule.\n   *\n   * During loop iteration, it consumes until it sees a token that can start a\n   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n   * stay in the loop as long as possible.\n   *\n   * **ORIGINS**\n   *\n   * Previous versions of ANTLR did a poor job of their recovery within loops.\n   * A single mismatch token or missing token would force the parser to bail\n   * out of the entire rules surrounding the loop. So, for rule\n   *\n   * ```\n   * classDef : 'class' ID '{' member* '}'\n   * ```\n   *\n   * input with an extra token between members would force the parser to\n   * consume until it found the next class definition rather than the next\n   * member definition of the current class.\n   *\n   * This functionality cost a little bit of effort because the parser has to\n   * compare token set at the start of the loop and at each iteration. If for\n   * some reason speed is suffering for you, you can turn off this\n   * functionality by simply overriding this method as a blank { }.\n   *\n   */\n  sync(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n    const s = recognizer.atn.states[recognizer.state];\n    const la = recognizer.tokenStream.LA(1);\n    const nextTokens = recognizer.atn.nextTokens(s);\n    if (nextTokens.contains(la)) {\n      this.nextTokensContext = null;\n      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n      return;\n    }\n    if (nextTokens.contains(Token.EPSILON)) {\n      if (this.nextTokensContext === null) {\n        this.nextTokensContext = recognizer.context;\n        this.nextTokenState = recognizer.state;\n      }\n      return;\n    }\n    switch (s.constructor.stateType) {\n      case ATNState.BLOCK_START:\n      case ATNState.STAR_BLOCK_START:\n      case ATNState.PLUS_BLOCK_START:\n      case ATNState.STAR_LOOP_ENTRY: {\n        if (this.singleTokenDeletion(recognizer) !== null) {\n          return;\n        }\n        throw new InputMismatchException(recognizer);\n      }\n      case ATNState.PLUS_LOOP_BACK:\n      case ATNState.STAR_LOOP_BACK: {\n        this.reportUnwantedToken(recognizer);\n        const expecting = new IntervalSet();\n        expecting.addSet(recognizer.getExpectedTokens());\n        const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n        break;\n      }\n      default:\n    }\n  }\n  /**\n   * This is called by {@link reportError} when the exception is a\n   * {@link NoViableAltException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n  reportNoViableAlternative(recognizer, e) {\n    if (e.message.length > 0) {\n      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n      return;\n    }\n    const tokens = recognizer.tokenStream;\n    let input;\n    if (tokens !== null && e.startToken) {\n      if (e.startToken.type === Token.EOF) {\n        input = \"<EOF>\";\n      } else {\n        input = tokens.getTextFromRange(e.startToken, e.offendingToken);\n      }\n    } else {\n      input = \"<unknown input>\";\n    }\n    const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This is called by {@link reportError} when the exception is an {@link InputMismatchException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n  reportInputMismatch(recognizer, e) {\n    if (e.message.length > 0) {\n      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);\n      return;\n    }\n    const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) + \" expecting \" + e.getExpectedTokens().toStringWithVocabulary(recognizer.vocabulary);\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This is called by {@link reportError} when the exception is a\n   * {@link FailedPredicateException}.\n   *\n   * @see reportError\n   *\n   * @param recognizer the parser instance\n   * @param e the recognition exception\n   */\n  reportFailedPredicate(recognizer, e) {\n    const ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];\n    const msg = \"rule \" + ruleName + \" \" + e.message;\n    recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n  }\n  /**\n   * This method is called to report a syntax error which requires the removal\n   * of a token from the input stream. At the time this method is called, the\n   * erroneous symbol is current `LT(1)` symbol and has not yet been\n   * removed from the input stream. When this method returns,\n   * `recognizer` is in error recovery mode.\n   *\n   * This method is called when {@link singleTokenDeletion} identifies\n   * single-token deletion as a viable recovery strategy for a mismatched\n   * input error.\n   *\n   * The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser.notifyErrorListeners}.\n   *\n   * @param recognizer the parser instance\n   */\n  reportUnwantedToken(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n    this.beginErrorCondition(recognizer);\n    const t = recognizer.getCurrentToken();\n    const tokenName = this.getTokenErrorDisplay(t);\n    const expecting = this.getExpectedTokens(recognizer);\n    const msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toStringWithVocabulary(recognizer.vocabulary);\n    recognizer.notifyErrorListeners(msg, t, null);\n  }\n  /**\n   * This method is called to report a syntax error which requires the\n   * insertion of a missing token into the input stream. At the time this\n   * method is called, the missing token has not yet been inserted. When this\n   * method returns, `recognizer` is in error recovery mode.\n   *\n   * This method is called when {@link singleTokenInsertion} identifies\n   * single-token insertion as a viable recovery strategy for a mismatched\n   * input error.\n   *\n   * The default implementation simply returns if the handler is already in\n   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to\n   * enter error recovery mode, followed by calling\n   * {@link Parser.notifyErrorListeners}.\n   *\n   * @param recognizer the parser instance\n   */\n  reportMissingToken(recognizer) {\n    if (this.inErrorRecoveryMode(recognizer)) {\n      return;\n    }\n    this.beginErrorCondition(recognizer);\n    const t = recognizer.getCurrentToken();\n    const expecting = this.getExpectedTokens(recognizer);\n    const msg = \"missing \" + expecting.toStringWithVocabulary(recognizer.vocabulary) + \" at \" + this.getTokenErrorDisplay(t);\n    recognizer.notifyErrorListeners(msg, t, null);\n  }\n  /**\n   * The default implementation attempts to recover from the mismatched input\n   * by using single token insertion and deletion as described below. If the\n   * recovery attempt fails, this method throws an\n   * {@link InputMismatchException}.\n   *\n   * **EXTRA TOKEN** (single token deletion)\n   *\n   * `LA(1)` is not what we are looking for. If `LA(2)` has the\n   * right token, however, then assume `LA(1)` is some extra spurious\n   * token and delete it. Then consume and return the next token (which was\n   * the `LA(2)` token) as the successful result of the match operation.\n   *\n   * This recovery strategy is implemented by {@link singleTokenDeletion}.\n   *\n   * **MISSING TOKEN** (single token insertion)\n   *\n   * If current token (at `LA(1)`) is consistent with what could come\n   * after the expected `LA(1)` token, then assume the token is missing\n   * and use the parser's {@link TokenFactory} to create it on the fly. The\n   * \"insertion\" is performed by returning the created token as the successful\n   * result of the match operation.\n   *\n   * This recovery strategy is implemented by {@link singleTokenInsertion}.\n   *\n   * **EXAMPLE**\n   *\n   * For example, Input `i=(3;` is clearly missing the `')'`. When\n   * the parser returns from the nested call to `expr`, it will have\n   * call chain:\n   *\n   * ```\n   * stat -> expr -> atom\n   * ```\n   *\n   * and it will be trying to match the `')'` at this point in the\n   * derivation:\n   *\n   * ```\n   * => ID '=' '(' INT ')' ('+' atom)* ';'\n   * ^\n   * ```\n   *\n   * The attempt to match `')'` will fail when it sees `';'` and\n   * call {@link recoverInline}. To recover, it sees that `LA(1)==';'`\n   * is in the set of tokens that can follow the `')'` token reference\n   * in rule `atom`. It can assume that you forgot the `')'`.\n   */\n  recoverInline(recognizer) {\n    const matchedSymbol = this.singleTokenDeletion(recognizer);\n    if (matchedSymbol) {\n      recognizer.consume();\n      return matchedSymbol;\n    }\n    if (this.singleTokenInsertion(recognizer)) {\n      return this.getMissingSymbol(recognizer);\n    }\n    throw new InputMismatchException(recognizer);\n  }\n  /**\n   * This method implements the single-token insertion inline error recovery\n   * strategy. It is called by {@link recoverInline} if the single-token\n   * deletion strategy fails to recover from the mismatched input. If this\n   * method returns `true`, `recognizer` will be in error recovery\n   * mode.\n   *\n   * This method determines whether or not single-token insertion is viable by\n   * checking if the `LA(1)` input symbol could be successfully matched\n   * if it were instead the `LA(2)` symbol. If this method returns\n   * `true`, the caller is responsible for creating and inserting a\n   * token with the correct type to produce this behavior.\n   *\n   * @param recognizer the parser instance\n   * @returns `true` if single-token insertion is a viable recovery\n   * strategy for the current mismatched input, otherwise `false`\n   */\n  singleTokenInsertion(recognizer) {\n    const currentSymbolType = recognizer.tokenStream?.LA(1) ?? -1;\n    const atn = recognizer.atn;\n    const currentState = atn.states[recognizer.state];\n    const next = currentState.transitions[0].target;\n    const expectingAtLL2 = atn.nextTokens(next, recognizer.context ?? void 0);\n    if (expectingAtLL2.contains(currentSymbolType)) {\n      this.reportMissingToken(recognizer);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * This method implements the single-token deletion inline error recovery\n   * strategy. It is called by {@link recoverInline} to attempt to recover\n   * from mismatched input. If this method returns null, the parser and error\n   * handler state will not have changed. If this method returns non-null,\n   * `recognizer` will *not* be in error recovery mode since the\n   * returned token was a successful match.\n   *\n   * If the single-token deletion is successful, this method calls\n   * {@link reportUnwantedToken} to report the error, followed by\n   * {@link Parser.consume} to actually \"delete\" the extraneous token. Then,\n   * before returning {@link reportMatch} is called to signal a successful\n   * match.\n   *\n   * @param recognizer the parser instance\n   * @returns the successfully matched {@link Token} instance if single-token\n   * deletion successfully recovers from the mismatched input, otherwise\n   * `null`\n   */\n  singleTokenDeletion(recognizer) {\n    const nextTokenType = recognizer.tokenStream?.LA(2) ?? -1;\n    const expecting = this.getExpectedTokens(recognizer);\n    if (expecting.contains(nextTokenType)) {\n      this.reportUnwantedToken(recognizer);\n      recognizer.consume();\n      const matchedSymbol = recognizer.getCurrentToken();\n      this.reportMatch(recognizer);\n      return matchedSymbol;\n    }\n    return null;\n  }\n  /**\n   * Conjure up a missing token during error recovery.\n   *\n   * The recognizer attempts to recover from single missing\n   * symbols. But, actions might refer to that missing symbol.\n   * For example, x=ID {f($x);}. The action clearly assumes\n   * that there has been an identifier matched previously and that\n   * $x points at that token. If that token is missing, but\n   * the next token in the stream is what we want we assume that\n   * this token is missing and we keep going. Because we\n   * have to return some token to replace the missing token,\n   * we have to conjure one up. This method gives the user control\n   * over the tokens returned for missing tokens. Mostly,\n   * you will want to create something special for identifier\n   * tokens. For literals such as '{' and ',', the default\n   * action in the parser or tree parser works. It simply creates\n   * a CommonToken of the appropriate type. The text will be the token.\n   * If you change what tokens must be created by the lexer,\n   * override this method to create the appropriate tokens.\n   */\n  getMissingSymbol(recognizer) {\n    const currentSymbol = recognizer.getCurrentToken();\n    const expecting = this.getExpectedTokens(recognizer);\n    let expectedTokenType = Token.INVALID_TYPE;\n    if (expecting.length !== 0) {\n      expectedTokenType = expecting.minElement;\n    }\n    let tokenText;\n    if (expectedTokenType === Token.EOF) {\n      tokenText = \"<missing EOF>\";\n    } else {\n      tokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\n    }\n    let current = currentSymbol;\n    const lookBack = recognizer.tokenStream?.LT(-1);\n    if (current.type === Token.EOF && lookBack !== null) {\n      current = lookBack;\n    }\n    return recognizer.getTokenFactory().create(\n      current.source,\n      expectedTokenType,\n      tokenText,\n      Token.DEFAULT_CHANNEL,\n      -1,\n      -1,\n      current.line,\n      current.column\n    );\n  }\n  getExpectedTokens(recognizer) {\n    return recognizer.getExpectedTokens();\n  }\n  /**\n   * How should a token be displayed in an error message? The default\n   * is to display just the text, but during development you might\n   * want to have a lot of information spit out. Override in that case\n   * to use t.toString() (which, for CommonToken, dumps everything about\n   * the token). This is better than forcing you to override a method in\n   * your token objects because you don't have to go modify your lexer\n   * so that it creates a new Java type.\n   */\n  getTokenErrorDisplay(t) {\n    if (t === null) {\n      return \"<no token>\";\n    }\n    let s = t.text;\n    if (!s) {\n      if (t.type === Token.EOF) {\n        s = \"<EOF>\";\n      } else {\n        s = \"<\" + t.type + \">\";\n      }\n    }\n    return this.escapeWSAndQuote(s);\n  }\n  escapeWSAndQuote(s) {\n    s = s.replace(/\\n/g, \"\\\\n\");\n    s = s.replace(/\\r/g, \"\\\\r\");\n    s = s.replace(/\\t/g, \"\\\\t\");\n    return \"'\" + s + \"'\";\n  }\n  /**\n   * Compute the error recovery set for the current rule. During\n   * rule invocation, the parser pushes the set of tokens that can\n   * follow that rule reference on the stack; this amounts to\n   * computing FIRST of what follows the rule reference in the\n   * enclosing rule. See LinearApproximator.FIRST().\n   * This local follow set only includes tokens\n   * from within the rule; i.e., the FIRST computation done by\n   * ANTLR stops at the end of a rule.\n   *\n   * EXAMPLE\n   *\n   * When you find a \"no viable alt exception\", the input is not\n   * consistent with any of the alternatives for rule r. The best\n   * thing to do is to consume tokens until you see something that\n   * can legally follow a call to r//or* any rule that called r.\n   * You don't want the exact set of viable next tokens because the\n   * input might just be missing a token--you might consume the\n   * rest of the input looking for one of the missing tokens.\n   *\n   * Consider grammar:\n   *\n   * a : '[' b ']'\n   * | '(' b ')'\n   * ;\n   * b : c '^' INT ;\n   * c : ID\n   * | INT\n   * ;\n   *\n   * At each rule invocation, the set of tokens that could follow\n   * that rule is pushed on a stack. Here are the various\n   * context-sensitive follow sets:\n   *\n   * FOLLOW(b1_in_a) = FIRST(']') = ']'\n   * FOLLOW(b2_in_a) = FIRST(')') = ')'\n   * FOLLOW(c_in_b) = FIRST('^') = '^'\n   *\n   * Upon erroneous input \"[]\", the call chain is\n   *\n   * a -> b -> c\n   *\n   * and, hence, the follow context stack is:\n   *\n   * depth follow set start of rule execution\n   * 0 <EOF> a (from main())\n   * 1 ']' b\n   * 2 '^' c\n   *\n   * Notice that ')' is not included, because b would have to have\n   * been called from a different context in rule a for ')' to be\n   * included.\n   *\n   * For error recovery, we cannot consider FOLLOW(c)\n   * (context-sensitive or otherwise). We need the combined set of\n   * all context-sensitive FOLLOW sets--the set of all tokens that\n   * could follow any reference in the call chain. We need to\n   * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n   * we resync'd to that token, we'd consume until EOF. We need to\n   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n   * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n   * not consume anything. After printing an error, rule c would\n   * return normally. Rule b would not find the required '^' though.\n   * At this point, it gets a mismatched token error and throws an\n   * exception (since LA(1) is not in the viable following token\n   * set). The rule exception handler tries to recover, but finds\n   * the same recovery set and doesn't consume anything. Rule b\n   * exits normally returning to rule a. Now it finds the ']' (and\n   * with the successful match exits errorRecovery mode).\n   *\n   * So, you can see that the parser walks up the call chain looking\n   * for the token that was a member of the recovery set.\n   *\n   * Errors are not generated in errorRecovery mode.\n   *\n   * ANTLR's error recovery mechanism is based upon original ideas:\n   *\n   * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n   *\n   * and\n   *\n   * \"A note on error recovery in recursive descent parsers\":\n   * http://portal.acm.org/citation.cfm?id=947902.947905\n   *\n   * Later, Josef Grosch had some good ideas:\n   *\n   * \"Efficient and Comfortable Error Recovery in Recursive Descent\n   * Parsers\":\n   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n   *\n   * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n   * at run-time upon error to avoid overhead during parsing.\n   */\n  getErrorRecoverySet(recognizer) {\n    const atn = recognizer.atn;\n    let ctx = recognizer.context;\n    const recoverSet = new IntervalSet();\n    while (ctx !== null && ctx.invokingState >= 0) {\n      const invokingState = atn.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      const follow = atn.nextTokens(rt.followState);\n      recoverSet.addSet(follow);\n      ctx = ctx.parent;\n    }\n    recoverSet.removeOne(Token.EPSILON);\n    return recoverSet;\n  }\n  /** Consume tokens until one matches the given token set. */\n  consumeUntil(recognizer, set) {\n    let ttype = recognizer.tokenStream?.LA(1) ?? -1;\n    while (ttype !== Token.EOF && !set.contains(ttype)) {\n      recognizer.consume();\n      ttype = recognizer.tokenStream?.LA(1) ?? -1;\n    }\n  }\n};\n\n// src/BailErrorStrategy.ts\nvar BailErrorStrategy = class extends DefaultErrorStrategy {\n  static {\n    __name(this, \"BailErrorStrategy\");\n  }\n  /**\n   * Instead of recovering from exception `e`, re-throw it wrapped\n   * in a {@link ParseCancellationException} so it is not caught by the\n   * rule function catches. Use {@link Exception//getCause()} to get the\n   * original {@link RecognitionException}.\n   */\n  recover(recognizer, e) {\n    throw new ParseCancellationException(e);\n  }\n  /**\n   * Make sure we don't attempt to recover inline; if the parser\n   * successfully recovers, it won't throw an exception.\n   */\n  recoverInline(recognizer) {\n    const exception = new InputMismatchException(recognizer);\n    throw new ParseCancellationException(exception);\n  }\n  // Make sure we don't attempt to recover from problems in subrules.\n  sync(_recognizer) {\n  }\n};\n\n// src/ListTokenSource.ts\nvar ListTokenSource = class {\n  static {\n    __name(this, \"ListTokenSource\");\n  }\n  /**\n   * The name of the input source. If this value is `null`, a call to\n   * {@link #getSourceName} should return the source name used to create the\n   * the next token in {@link #tokens} (or the previous token if the end of\n   * the input has been reached).\n   */\n  sourceName;\n  tokenFactory = CommonTokenFactory.DEFAULT;\n  /**\n   * The wrapped collection of {@link Token} objects to return.\n   */\n  tokens = [];\n  /**\n   * The index into {@link tokens} of token to return by the next call to\n   * {@link #nextToken}. The end of the input is indicated by this value\n   * being greater than or equal to the number of items in {@link #tokens}.\n   */\n  i = 0;\n  /**\n   * This field caches the EOF token for the token source.\n   */\n  eofToken = null;\n  constructor(tokens, sourceName) {\n    this.tokens = tokens;\n    this.sourceName = sourceName ?? \"\";\n  }\n  get column() {\n    if (this.i < this.tokens.length) {\n      return this.tokens[this.i].column;\n    }\n    if (this.eofToken !== null) {\n      return this.eofToken.column;\n    }\n    if (this.tokens.length > 0) {\n      const lastToken = this.tokens[this.tokens.length - 1];\n      const tokenText = lastToken.text;\n      if (tokenText) {\n        const lastNewLine = tokenText.lastIndexOf(\"\\n\");\n        if (lastNewLine >= 0) {\n          return tokenText.length - lastNewLine - 1;\n        }\n      }\n      return lastToken.column + lastToken.stop - lastToken.start + 1;\n    }\n    return 0;\n  }\n  nextToken() {\n    if (this.i >= this.tokens.length) {\n      if (this.eofToken === null) {\n        let start = -1;\n        if (this.tokens.length > 0) {\n          const previousStop = this.tokens[this.tokens.length - 1].stop;\n          if (previousStop !== -1) {\n            start = previousStop + 1;\n          }\n        }\n        const stop = Math.max(-1, start - 1);\n        this.eofToken = this.tokenFactory.create(\n          [this, this.inputStream],\n          Token.EOF,\n          \"EOF\",\n          Token.DEFAULT_CHANNEL,\n          start,\n          stop,\n          this.line,\n          this.column\n        );\n      }\n      return this.eofToken;\n    }\n    const t = this.tokens[this.i];\n    if (this.i === this.tokens.length - 1 && t.type === Token.EOF) {\n      this.eofToken = t;\n    }\n    this.i++;\n    return t;\n  }\n  get line() {\n    if (this.i < this.tokens.length) {\n      return this.tokens[this.i].line;\n    }\n    if (this.eofToken !== null) {\n      return this.eofToken.line;\n    }\n    if (this.tokens.length > 0) {\n      const lastToken = this.tokens[this.tokens.length - 1];\n      let line = lastToken.line;\n      const tokenText = lastToken.text;\n      if (tokenText) {\n        for (const char of tokenText) {\n          if (char === \"\\n\") {\n            line++;\n          }\n        }\n      }\n      return line;\n    }\n    return 1;\n  }\n  get inputStream() {\n    if (this.i < this.tokens.length) {\n      return this.tokens[this.i].inputStream;\n    }\n    if (this.eofToken !== null) {\n      return this.eofToken.inputStream;\n    }\n    if (this.tokens.length > 0) {\n      return this.tokens[this.tokens.length - 1].inputStream;\n    }\n    return null;\n  }\n  getSourceName() {\n    if (this.sourceName !== null) {\n      return this.sourceName;\n    }\n    const inputStream = this.inputStream;\n    if (inputStream !== null) {\n      return inputStream.getSourceName();\n    }\n    return \"List\";\n  }\n};\n\n// src/InterpreterRuleContext.ts\nvar InterpreterRuleContext = class extends ParserRuleContext {\n  static {\n    __name(this, \"InterpreterRuleContext\");\n  }\n  /** This is the backing field for {@link #getRuleIndex}. */\n  #ruleIndex;\n  constructor(ruleIndex, parent, invokingStateNumber) {\n    super(parent, invokingStateNumber);\n    this.#ruleIndex = ruleIndex;\n  }\n  get ruleIndex() {\n    return this.#ruleIndex;\n  }\n};\n\n// src/TraceListener.ts\nvar TraceListener = class {\n  static {\n    __name(this, \"TraceListener\");\n  }\n  parser;\n  constructor(parser) {\n    this.parser = parser;\n  }\n  enterEveryRule(ctx) {\n    console.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser.inputStream?.LT(1)?.text);\n  }\n  visitTerminal(node) {\n    console.log(\"consume \" + node.getSymbol() + \" rule \" + this.parser.ruleNames[this.parser.context.ruleIndex]);\n  }\n  exitEveryRule(ctx) {\n    console.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser.inputStream?.LT(1)?.text);\n  }\n  visitErrorNode(_node) {\n  }\n};\n\n// src/Parser.ts\nvar Parser = class extends Recognizer {\n  static {\n    __name(this, \"Parser\");\n  }\n  /** For testing only. */\n  printer = null;\n  /**\n   * Specifies whether or not the parser should construct a parse tree during\n   * the parsing process. The default value is `true`.\n   *\n   * @see #getBuildParseTree\n   * @see #setBuildParseTree\n   */\n  buildParseTrees = true;\n  /**\n   * The error handling strategy for the parser. The default value is a new\n   * instance of {@link DefaultErrorStrategy}.\n   *\n   * @see #getErrorHandler\n   * @see #setErrorHandler\n   */\n  errorHandler = new DefaultErrorStrategy();\n  /**\n   * The {@link ParserRuleContext} object for the currently executing rule.\n   * This is always non-null during the parsing process.\n   */\n  // TODO: make private\n  context = null;\n  precedenceStack = [];\n  /**\n   * The list of {@link ParseTreeListener} listeners registered to receive\n   * events during the parse.\n   *\n   * @see #addParseListener\n   */\n  parseListeners = null;\n  /**\n   * The number of syntax errors reported during parsing. This value is\n   * incremented each time {@link #notifyErrorListeners} is called.\n   */\n  syntaxErrors = 0;\n  /** Indicates parser has matched EOF token. See {@link #exitRule()}. */\n  matchedEOF = false;\n  /**\n   * When {@link #setTrace}`(true)` is called, a reference to the\n   * {@link TraceListener} is stored here so it can be easily removed in a\n   * later call to {@link #setTrace}`(false)`. The listener itself is\n   * implemented as a parser listener so this field is not directly used by\n   * other parser methods.\n   */\n  tracer = null;\n  /**\n   * This field holds the deserialized {@link ATN} with bypass alternatives, created\n   * lazily upon first demand. In 4.10 I changed from map<serializedATNString, ATN>\n   * since we only need one per parser object and also it complicates other targets\n   * that don't use ATN strings.\n   *\n   * @see ATNDeserializationOptions#isGenerateRuleBypassTransitions()\n   */\n  bypassAltsAtnCache = null;\n  #inputStream;\n  /**\n   * This is all the parsing support code essentially. Most of it is error recovery stuff.\n   */\n  constructor(input) {\n    super();\n    this.precedenceStack.push(0);\n    this.syntaxErrors = 0;\n    this.#inputStream = input;\n  }\n  /** reset the parser's state */\n  reset(rewindInputStream = true) {\n    if (rewindInputStream) {\n      this.inputStream.seek(0);\n    }\n    this.errorHandler.reset(this);\n    this.context = null;\n    this.syntaxErrors = 0;\n    this.matchedEOF = false;\n    this.setTrace(false);\n    this.precedenceStack = [];\n    this.precedenceStack.push(0);\n    if (this.interpreter) {\n      this.interpreter.reset();\n    }\n  }\n  /**\n   * Match current input symbol against `ttype`. If the symbol type\n   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link consume} are\n   * called to complete the match process.\n   *\n   * If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link buildParseTree} is\n   * `true` and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.\n   *\n   * @param ttype the token type to match\n   * @returns the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * `ttype` and the error strategy could not recover from the\n   * mismatched symbol\n   */\n  match(ttype) {\n    let t = this.getCurrentToken();\n    if (t.type === ttype) {\n      if (ttype === Token.EOF) {\n        this.matchedEOF = true;\n      }\n      this.errorHandler.reportMatch(this);\n      this.consume();\n    } else {\n      t = this.errorHandler.recoverInline(this);\n      if (this.buildParseTrees && t.tokenIndex === -1) {\n        this.context.addErrorNode(this.createErrorNode(this.context, t));\n      }\n    }\n    return t;\n  }\n  /**\n   * Match current input symbol as a wildcard. If the symbol type matches\n   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n   * and {@link consume} are called to complete the match process.\n   *\n   * If the symbol type does not match,\n   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n   * strategy to attempt recovery. If {@link buildParseTree} is\n   * `true` and the token index of the symbol returned by\n   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.\n   *\n   * @returns the matched symbol\n   * @throws RecognitionException if the current input symbol did not match\n   * a wildcard and the error strategy could not recover from the mismatched\n   * symbol\n   */\n  matchWildcard() {\n    let t = this.getCurrentToken();\n    if (t.type > 0) {\n      this.errorHandler.reportMatch(this);\n      this.consume();\n    } else {\n      t = this.errorHandler.recoverInline(this);\n      if (this.buildParseTrees && t.tokenIndex === -1) {\n        this.context.addErrorNode(this.createErrorNode(this.context, t));\n      }\n    }\n    return t;\n  }\n  getParseListeners() {\n    return this.parseListeners ?? [];\n  }\n  /**\n   * Registers `listener` to receive events during the parsing process.\n   *\n   * To support output-preserving grammar transformations (including but not\n   * limited to left-recursion removal, automated left-factoring, and\n   * optimized code generation), calls to listener methods during the parse\n   * may differ substantially from calls made by\n   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n   * particular, rule entry and exit events may occur in a different order\n   * during the parse than after the parser. In addition, calls to certain\n   * rule entry methods may be omitted.\n   *\n   * With the following specific exceptions, calls to listener events are\n   * deterministic*, i.e. for identical input the calls to listener\n   * methods will be the same.\n   *\n   * - Alterations to the grammar used to generate code may change the\n   * behavior of the listener calls.\n   * - Alterations to the command line options passed to ANTLR 4 when\n   * generating the parser may change the behavior of the listener calls.\n   * - Changing the version of the ANTLR Tool used to generate the parser\n   * may change the behavior of the listener calls.\n   *\n   * @param listener the listener to add\n   *\n   * @throws NullPointerException if {@code} listener is `null`\n   */\n  addParseListener(listener) {\n    if (listener === null) {\n      throw new Error(\"listener\");\n    }\n    if (this.parseListeners === null) {\n      this.parseListeners = [];\n    }\n    this.parseListeners.push(listener);\n  }\n  /**\n   * Remove `listener` from the list of parse listeners.\n   *\n   * If `listener` is `null` or has not been added as a parse\n   * listener, this method does nothing.\n   *\n   * @param listener the listener to remove\n   */\n  removeParseListener(listener) {\n    if (this.parseListeners !== null && listener !== null) {\n      const idx = this.parseListeners.indexOf(listener);\n      if (idx >= 0) {\n        this.parseListeners.splice(idx, 1);\n      }\n      if (this.parseListeners.length === 0) {\n        this.parseListeners = null;\n      }\n    }\n  }\n  // Remove all parse listeners.\n  removeParseListeners() {\n    this.parseListeners = null;\n  }\n  // Notify any parse listeners of an enter rule event.\n  triggerEnterRuleEvent() {\n    if (this.parseListeners !== null) {\n      const ctx = this.context;\n      this.parseListeners.forEach((listener) => {\n        listener.enterEveryRule(ctx);\n        ctx.enterRule(listener);\n      });\n    }\n  }\n  /**\n   * Notify any parse listeners of an exit rule event.\n   *\n   * @see //addParseListener\n   */\n  triggerExitRuleEvent() {\n    if (this.parseListeners !== null) {\n      const ctx = this.context;\n      this.parseListeners.slice(0).reverse().forEach((listener) => {\n        ctx.exitRule(listener);\n        listener.exitEveryRule(ctx);\n      });\n    }\n  }\n  getTokenFactory() {\n    return this.inputStream.tokenSource.tokenFactory;\n  }\n  // Tell our token source and error strategy about a new way to create tokens.\n  setTokenFactory(factory) {\n    this.inputStream.tokenSource.tokenFactory = factory;\n  }\n  /**\n   * The preferred method of getting a tree pattern. For example, here's a\n   * sample use:\n   *\n   * ```\n   * const t = parser.expr();\n   * const p = parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\n   * const m = p.match(t);\n   * const id = m.get(\"ID\");\n   * ```\n   */\n  compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n    if (!lexer) {\n      if (this.tokenStream !== null) {\n        const tokenSource = this.tokenStream.tokenSource;\n        if (tokenSource instanceof Lexer) {\n          lexer = tokenSource;\n        }\n      }\n    }\n    if (!lexer) {\n      throw new Error(\"Parser can't discover a lexer to use\");\n    }\n    const m2 = new ParseTreePatternMatcher(lexer, this);\n    return m2.compile(pattern, patternRuleIndex);\n  }\n  /**\n   * The ATN with bypass alternatives is expensive to create so we create it\n   * lazily.\n   *\n   * @throws UnsupportedOperationException if the current parser does not\n   * implement the {@link getSerializedATN()} method.\n   */\n  getATNWithBypassAlts() {\n    const serializedAtn = this.serializedATN;\n    if (serializedAtn === null) {\n      throw new Error(\"The current parser does not support an ATN with bypass alternatives.\");\n    }\n    if (this.bypassAltsAtnCache !== null) {\n      return this.bypassAltsAtnCache;\n    }\n    const deserializationOptions = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: true };\n    this.bypassAltsAtnCache = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);\n    return this.bypassAltsAtnCache;\n  }\n  /**\n   * Gets the number of syntax errors reported during parsing. This value is\n   * incremented each time {@link notifyErrorListeners} is called.\n   */\n  get numberOfSyntaxErrors() {\n    return this.syntaxErrors;\n  }\n  get inputStream() {\n    return this.#inputStream;\n  }\n  set inputStream(input) {\n    this.tokenStream = input;\n  }\n  get tokenStream() {\n    return this.#inputStream;\n  }\n  /** Set the token stream and reset the parser. */\n  set tokenStream(input) {\n    this.reset(false);\n    this.#inputStream = input;\n  }\n  /**\n   * Match needs to return the current input symbol, which gets put\n   * into the label for the associated token ref; e.g., x=ID.\n   */\n  getCurrentToken() {\n    return this.inputStream.LT(1);\n  }\n  notifyErrorListeners(msg, offendingToken, err) {\n    offendingToken = offendingToken ?? null;\n    err = err ?? null;\n    if (offendingToken === null) {\n      offendingToken = this.getCurrentToken();\n    }\n    this.syntaxErrors += 1;\n    const line = offendingToken.line;\n    const column = offendingToken.column;\n    this.errorListenerDispatch.syntaxError(this, offendingToken, line, column, msg, err);\n  }\n  /**\n   * Consume and return the {@link getCurrentToken current symbol}.\n   *\n   * E.g., given the following input with `A` being the current\n   * lookahead symbol, this function moves the cursor to `B` and returns\n   * `A`.\n   *\n   * ```\n   * A B\n   * ^\n   * ```\n   *\n   * If the parser is not in error recovery mode, the consumed symbol is added\n   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n   * If the parser *is* in error recovery mode, the consumed symbol is\n   * added to the parse tree using\n   * {@link ParserRuleContext//addErrorNode(Token)}, and\n   * {@link ParseTreeListener//visitErrorNode} is called on any parse\n   * listeners.\n   */\n  consume() {\n    const o = this.getCurrentToken();\n    if (o.type !== Token.EOF) {\n      this.tokenStream.consume();\n    }\n    const hasListener = this.parseListeners !== null && this.parseListeners.length > 0;\n    if (this.buildParseTrees || hasListener) {\n      let node;\n      if (this.errorHandler.inErrorRecoveryMode(this)) {\n        node = this.context.addErrorNode(this.createErrorNode(this.context, o));\n      } else {\n        node = this.context.addTokenNode(o);\n      }\n      if (hasListener) {\n        this.parseListeners.forEach((listener) => {\n          if (node instanceof ErrorNode) {\n            listener.visitErrorNode(node);\n          } else {\n            listener.visitTerminal(node);\n          }\n        });\n      }\n    }\n    return o;\n  }\n  addContextToParseTree() {\n    if (this.context?.parent) {\n      this.context.parent.addChild(this.context);\n    }\n  }\n  /**\n   * Always called by generated parsers upon entry to a rule. Access field\n   * {@link context} get the current context.\n   */\n  enterRule(localctx, state, _ruleIndex) {\n    this.state = state;\n    this.context = localctx;\n    this.context.start = this.inputStream.LT(1);\n    if (this.buildParseTrees) {\n      this.addContextToParseTree();\n    }\n    this.triggerEnterRuleEvent();\n  }\n  exitRule() {\n    if (this.matchedEOF) {\n      this.context.stop = this.inputStream.LT(1);\n    } else {\n      this.context.stop = this.inputStream.LT(-1);\n    }\n    this.triggerExitRuleEvent();\n    this.state = this.context.invokingState;\n    this.context = this.context.parent;\n  }\n  enterOuterAlt(localctx, altNum) {\n    localctx.setAltNumber(altNum);\n    if (this.buildParseTrees && this.context !== localctx) {\n      if (this.context?.parent) {\n        this.context.parent.removeLastChild();\n        this.context.parent.addChild(localctx);\n      }\n    }\n    this.context = localctx;\n  }\n  /**\n   * Get the precedence level for the top-most precedence rule.\n   *\n   * @returns The precedence level for the top-most precedence rule, or -1 if\n   * the parser context is not nested within a precedence rule.\n   */\n  getPrecedence() {\n    if (this.precedenceStack.length === 0) {\n      return -1;\n    }\n    return this.precedenceStack[this.precedenceStack.length - 1];\n  }\n  enterRecursionRule(localctx, state, ruleIndex, precedence) {\n    this.state = state;\n    this.precedenceStack.push(precedence);\n    this.context = localctx;\n    this.context.start = this.inputStream.LT(1);\n    this.triggerEnterRuleEvent();\n  }\n  /** Like {@link enterRule} but for recursive rules. */\n  pushNewRecursionContext(localctx, state, _ruleIndex) {\n    const previous = this.context;\n    previous.parent = localctx;\n    previous.invokingState = state;\n    previous.stop = this.inputStream.LT(-1);\n    this.context = localctx;\n    this.context.start = previous.start;\n    if (this.buildParseTrees) {\n      this.context.addChild(previous);\n    }\n    this.triggerEnterRuleEvent();\n  }\n  unrollRecursionContexts(parent) {\n    this.precedenceStack.pop();\n    this.context.stop = this.inputStream.LT(-1);\n    const retCtx = this.context;\n    const parseListeners = this.getParseListeners();\n    if (parseListeners !== null && parseListeners.length > 0) {\n      while (this.context !== parent) {\n        this.triggerExitRuleEvent();\n        this.context = this.context.parent;\n      }\n    } else {\n      this.context = parent;\n    }\n    retCtx.parent = parent;\n    if (this.buildParseTrees && parent !== null) {\n      parent.addChild(retCtx);\n    }\n  }\n  getInvokingContext(ruleIndex) {\n    let ctx = this.context;\n    while (ctx !== null) {\n      if (ctx.ruleIndex === ruleIndex) {\n        return ctx;\n      }\n      ctx = ctx.parent;\n    }\n    return null;\n  }\n  precpred(_localctx, precedence) {\n    return precedence >= this.precedenceStack[this.precedenceStack.length - 1];\n  }\n  /**\n   * Checks whether or not `symbol` can follow the current state in the\n   * ATN. The behavior of this method is equivalent to the following, but is\n   * implemented such that the complete context-sensitive follow set does not\n   * need to be explicitly constructed.\n   *\n   * ```\n   * return getExpectedTokens().contains(symbol);\n   * ```\n   *\n   * @param symbol the symbol type to check\n   * @returns `true` if `symbol` can follow the current state in\n   * the ATN, otherwise `false`.\n   */\n  isExpectedToken(symbol) {\n    const atn = this.interpreter.atn;\n    let ctx = this.context;\n    const s = atn.states[this.state];\n    let following = atn.nextTokens(s);\n    if (following.contains(symbol)) {\n      return true;\n    }\n    if (!following.contains(Token.EPSILON)) {\n      return false;\n    }\n    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n      const invokingState = atn.states[ctx.invokingState];\n      const rt = invokingState.transitions[0];\n      following = atn.nextTokens(rt.followState);\n      if (following.contains(symbol)) {\n        return true;\n      }\n      ctx = ctx.parent;\n    }\n    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Computes the set of input symbols which could follow the current parser\n   * state and context, as given by {@link getState} and {@link getContext},\n   * respectively.\n   *\n   * {@link ATN.getExpectedTokens ATN.getExpectedTokens(int, RuleContext)}\n   */\n  getExpectedTokens() {\n    return this.interpreter.atn.getExpectedTokens(this.state, this.context);\n  }\n  getExpectedTokensWithinCurrentRule() {\n    const atn = this.interpreter.atn;\n    const s = atn.states[this.state];\n    return atn.nextTokens(s);\n  }\n  /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */\n  getRuleIndex(ruleName) {\n    return this.getRuleIndexMap().get(ruleName) ?? -1;\n  }\n  /**\n   * @returns an array of string of the rule names in your parser instance\n   * leading up to a call to the current rule. You could override if\n   * you want more details such as the file/line info of where\n   * in the ATN a rule is invoked.\n   *\n   * this is very useful for error messages.\n   */\n  getRuleInvocationStack(p) {\n    p = p ?? null;\n    if (p === null) {\n      p = this.context;\n    }\n    const stack = [];\n    while (p !== null) {\n      const ruleIndex = p.ruleIndex;\n      if (ruleIndex < 0) {\n        stack.push(\"n/a\");\n      } else {\n        stack.push(this.ruleNames[ruleIndex]);\n      }\n      p = p.parent;\n    }\n    return stack;\n  }\n  /**\n   * For debugging and other purposes.\n   *\n   * TODO: this differs from the Java version. Change it.\n   */\n  getDFAStrings() {\n    return this.interpreter.decisionToDFA.toString();\n  }\n  /** For debugging and other purposes. */\n  dumpDFA() {\n    let seenOne = false;\n    for (const dfa of this.interpreter.decisionToDFA) {\n      if (dfa.length > 0) {\n        if (seenOne) {\n          console.log();\n        }\n        if (this.printer) {\n          this.printer.println(\"Decision \" + dfa.decision + \":\");\n          this.printer.print(dfa.toString(this.vocabulary));\n        }\n        seenOne = true;\n      }\n    }\n  }\n  getSourceName() {\n    return this.inputStream.getSourceName();\n  }\n  getParseInfo() {\n    const interp = this.interpreter;\n    if (interp instanceof ProfilingATNSimulator) {\n      return new ParseInfo(interp);\n    }\n    return void 0;\n  }\n  setProfile(profile) {\n    const interp = this.interpreter;\n    const saveMode = interp.predictionMode;\n    if (profile) {\n      if (!(interp instanceof ProfilingATNSimulator)) {\n        this.interpreter = new ProfilingATNSimulator(this);\n      }\n    } else if (interp instanceof ProfilingATNSimulator) {\n      const sharedContextCache = interp.sharedContextCache;\n      if (sharedContextCache) {\n        const sim = new ParserATNSimulator(this, this.atn, interp.decisionToDFA, sharedContextCache);\n        this.interpreter = sim;\n      }\n    }\n    this.interpreter.predictionMode = saveMode;\n  }\n  /**\n   * During a parse is sometimes useful to listen in on the rule entry and exit\n   * events as well as token matches. this is for quick and dirty debugging.\n   */\n  setTrace(trace) {\n    if (!trace) {\n      this.removeParseListener(this.tracer);\n      this.tracer = null;\n    } else {\n      if (this.tracer !== null) {\n        this.removeParseListener(this.tracer);\n      }\n      this.tracer = new TraceListener(this);\n      this.addParseListener(this.tracer);\n    }\n  }\n  createTerminalNode(parent, t) {\n    return new TerminalNode(t);\n  }\n  createErrorNode(parent, t) {\n    return new ErrorNode(t);\n  }\n};\n\n// src/ParserInterpreter.ts\nvar ParserInterpreter = class extends Parser {\n  static {\n    __name(this, \"ParserInterpreter\");\n  }\n  rootContext;\n  overrideDecisionRoot = null;\n  parentContextStack = [];\n  overrideDecisionAlt = -1;\n  overrideDecisionReached = false;\n  decisionToDFA;\n  sharedContextCache = new PredictionContextCache();\n  pushRecursionContextStates;\n  #overrideDecision = -1;\n  #overrideDecisionInputIndex = -1;\n  #grammarFileName;\n  #atn;\n  #ruleNames;\n  #vocabulary;\n  constructor(grammarFileName, vocabulary, ruleNames, atn, input) {\n    super(input);\n    this.#grammarFileName = grammarFileName;\n    this.#atn = atn;\n    this.#ruleNames = ruleNames.slice(0);\n    this.#vocabulary = vocabulary;\n    this.pushRecursionContextStates = new BitSet();\n    for (const state of atn.states) {\n      if (state instanceof StarLoopEntryState && state.precedenceRuleDecision) {\n        this.pushRecursionContextStates.set(state.stateNumber);\n      }\n    }\n    this.decisionToDFA = atn.decisionToState.map((ds, i) => {\n      return new DFA(ds, i);\n    });\n    this.interpreter = new ParserATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);\n  }\n  reset() {\n    super.reset();\n    this.overrideDecisionReached = false;\n    this.overrideDecisionRoot = null;\n  }\n  get atn() {\n    return this.#atn;\n  }\n  get vocabulary() {\n    return this.#vocabulary;\n  }\n  get ruleNames() {\n    return this.#ruleNames;\n  }\n  get grammarFileName() {\n    return this.#grammarFileName;\n  }\n  get atnState() {\n    return this.#atn.states[this.state];\n  }\n  parse(startRuleIndex) {\n    const startRuleStartState = this.#atn.ruleToStartState[startRuleIndex];\n    this.rootContext = this.createInterpreterRuleContext(null, ATNState.INVALID_STATE_NUMBER, startRuleIndex);\n    if (startRuleStartState.isLeftRecursiveRule) {\n      this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n    } else {\n      this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);\n    }\n    while (true) {\n      const p = this.atnState;\n      switch (p.constructor.stateType) {\n        case ATNState.RULE_STOP: {\n          if (this.context?.isEmpty()) {\n            if (startRuleStartState.isLeftRecursiveRule) {\n              const result = this.context;\n              const parentContext = this.parentContextStack.pop();\n              this.unrollRecursionContexts(parentContext[0]);\n              return result;\n            } else {\n              this.exitRule();\n              return this.rootContext;\n            }\n          }\n          this.visitRuleStopState(p);\n          break;\n        }\n        default: {\n          try {\n            this.visitState(p);\n          } catch (e) {\n            if (e instanceof RecognitionException) {\n              this.state = this.#atn.ruleToStopState[p.ruleIndex].stateNumber;\n              this.errorHandler.reportError(this, e);\n              this.recover(e);\n            } else {\n              throw e;\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n  addDecisionOverride(decision, tokenIndex, forcedAlt) {\n    this.#overrideDecision = decision;\n    this.#overrideDecisionInputIndex = tokenIndex;\n    this.overrideDecisionAlt = forcedAlt;\n  }\n  get overrideDecision() {\n    return this.#overrideDecision;\n  }\n  get overrideDecisionInputIndex() {\n    return this.#overrideDecisionInputIndex;\n  }\n  enterRecursionRule(localctx, state, ruleIndex, precedence) {\n    this.parentContextStack.push([this.context, localctx.invokingState]);\n    super.enterRecursionRule(localctx, state, ruleIndex, precedence);\n  }\n  get serializedATN() {\n    throw new Error(\"The ParserInterpreter does not support the serializedATN property.\");\n  }\n  visitState(p) {\n    let predictedAlt = 1;\n    if (p instanceof DecisionState) {\n      predictedAlt = this.visitDecisionState(p);\n    }\n    const transition = p.transitions[predictedAlt - 1];\n    switch (transition.transitionType) {\n      case Transition.EPSILON:\n        if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target.constructor.stateType === ATNState.LOOP_END)) {\n          const parentContext = this.parentContextStack[this.parentContextStack.length - 1];\n          const localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this.context.ruleIndex);\n          this.pushNewRecursionContext(\n            localctx,\n            this.#atn.ruleToStartState[p.ruleIndex].stateNumber,\n            this.context.ruleIndex\n          );\n        }\n        break;\n      case Transition.ATOM:\n        this.match(transition.label.minElement);\n        break;\n      case Transition.RANGE:\n      case Transition.SET:\n      case Transition.NOT_SET:\n        if (!transition.matches(this.inputStream.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {\n          this.recoverInline();\n        }\n        this.matchWildcard();\n        break;\n      case Transition.WILDCARD:\n        this.matchWildcard();\n        break;\n      case Transition.RULE:\n        const ruleStartState = transition.target;\n        const ruleIndex = ruleStartState.ruleIndex;\n        const newContext = this.createInterpreterRuleContext(this.context, p.stateNumber, ruleIndex);\n        if (ruleStartState.isLeftRecursiveRule) {\n          this.enterRecursionRule(\n            newContext,\n            ruleStartState.stateNumber,\n            ruleIndex,\n            transition.precedence\n          );\n        } else {\n          this.enterRule(newContext, transition.target.stateNumber, ruleIndex);\n        }\n        break;\n      case Transition.PREDICATE:\n        const predicateTransition = transition;\n        if (!this.sempred(this.context, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\n          throw new FailedPredicateException(this);\n        }\n        break;\n      case Transition.ACTION:\n        const actionTransition = transition;\n        this.action(this.context, actionTransition.ruleIndex, actionTransition.actionIndex);\n        break;\n      case Transition.PRECEDENCE:\n        if (!this.precpred(this.context, transition.precedence)) {\n          const precedence = transition.precedence;\n          throw new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\n        }\n        break;\n      default:\n        throw new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n    }\n    this.state = transition.target.stateNumber;\n  }\n  visitDecisionState(p) {\n    let predictedAlt = 1;\n    if (p.transitions.length > 1) {\n      this.errorHandler.sync(this);\n      const decision = p.decision;\n      if (decision === this.#overrideDecision && this.inputStream.index === this.#overrideDecisionInputIndex && !this.overrideDecisionReached) {\n        predictedAlt = this.overrideDecisionAlt;\n        this.overrideDecisionReached = true;\n      } else {\n        predictedAlt = this.interpreter.adaptivePredict(this.inputStream, decision, this.context);\n      }\n    }\n    return predictedAlt;\n  }\n  createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n    return new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\n  }\n  visitRuleStopState(p) {\n    const ruleStartState = this.#atn.ruleToStartState[p.ruleIndex];\n    if (ruleStartState.isLeftRecursiveRule) {\n      const [parentContext, state] = this.parentContextStack.pop();\n      this.unrollRecursionContexts(parentContext);\n      this.state = state;\n    } else {\n      this.exitRule();\n    }\n    const ruleTransition = this.#atn.states[this.state].transitions[0];\n    this.state = ruleTransition.followState.stateNumber;\n  }\n  recover(e) {\n    const i = this.inputStream.index;\n    this.errorHandler.recover(this, e);\n    if (this.inputStream.index === i) {\n      const tok = e.offendingToken;\n      if (!tok) {\n        throw new Error(\"Expected exception to have an offending token\");\n      }\n      const source = tok.tokenSource;\n      const stream = source?.inputStream ?? null;\n      const sourcePair = [source, stream];\n      if (e instanceof InputMismatchException) {\n        const expectedTokens = e.getExpectedTokens();\n        if (!expectedTokens) {\n          throw new Error(\"Expected the exception to provide expected tokens\");\n        }\n        let expectedTokenType = Token.INVALID_TYPE;\n        if (expectedTokens.length !== 0) {\n          expectedTokenType = expectedTokens.minElement;\n        }\n        const errToken = this.getTokenFactory().create(\n          sourcePair,\n          expectedTokenType,\n          tok.text,\n          Token.DEFAULT_CHANNEL,\n          -1,\n          -1,\n          tok.line,\n          tok.column\n        );\n        this.context.addErrorNode(this.createErrorNode(this.context, errToken));\n      } else {\n        const errToken = this.getTokenFactory().create(\n          sourcePair,\n          Token.INVALID_TYPE,\n          tok.text,\n          Token.DEFAULT_CHANNEL,\n          -1,\n          -1,\n          tok.line,\n          tok.column\n        );\n        this.context.addErrorNode(this.createErrorNode(this.context, errToken));\n      }\n    }\n  }\n  recoverInline() {\n    return this.errorHandler.recoverInline(this);\n  }\n};\n\n// src/misc/MultiMap.ts\nvar MultiMap = class extends Map {\n  static {\n    __name(this, \"MultiMap\");\n  }\n  map(key, value) {\n    let elementsForKey = this.get(key);\n    if (!elementsForKey) {\n      elementsForKey = new Array();\n      this.set(key, elementsForKey);\n    }\n    elementsForKey.push(value);\n  }\n  getPairs() {\n    const pairs = new Array();\n    for (const key of this.keys()) {\n      const keys = this.get(key) ?? [];\n      for (const value of keys) {\n        pairs.push([key, value]);\n      }\n    }\n    return pairs;\n  }\n  toString() {\n    const entries = [];\n    this.forEach((value, key) => {\n      entries.push(`${key}=[${value.join(\", \")}]`);\n    });\n    return `{${entries.join(\", \")}}`;\n  }\n};\n\n// src/tree/pattern/CannotInvokeStartRuleError.ts\nvar CannotInvokeStartRuleError = class extends Error {\n  static {\n    __name(this, \"CannotInvokeStartRuleError\");\n  }\n  constructor(e) {\n    super();\n    this.cause = e;\n  }\n};\n\n// src/tree/pattern/RuleTagToken.ts\nvar RuleTagToken = class {\n  static {\n    __name(this, \"RuleTagToken\");\n  }\n  /** The name of the label associated with the rule tag. */\n  label;\n  /** The name of the parser rule associated with this rule tag. */\n  ruleName;\n  /**\n   * The token type for the current token. This is the token type assigned to\n   * the bypass alternative for the rule during ATN deserialization.\n   */\n  bypassTokenType;\n  constructor(ruleName, bypassTokenType, label) {\n    this.ruleName = ruleName;\n    this.bypassTokenType = bypassTokenType;\n    this.label = label;\n  }\n  /**\n   * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.\n   */\n  get channel() {\n    return Token.DEFAULT_CHANNEL;\n  }\n  /**\n   * This method returns the rule tag formatted with `<` and `>`\n   * delimiters.\n   */\n  get text() {\n    if (this.label !== void 0) {\n      return \"<\" + this.label + \":\" + this.ruleName + \">\";\n    }\n    return \"<\" + this.ruleName + \">\";\n  }\n  /**\n   * Rule tag tokens have types assigned according to the rule bypass\n   * transitions created during ATN deserialization.\n   */\n  get type() {\n    return this.bypassTokenType;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns 0.\n   */\n  get line() {\n    return 0;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */\n  get column() {\n    return -1;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */\n  get tokenIndex() {\n    return -1;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */\n  get start() {\n    return -1;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns -1.\n   */\n  get stop() {\n    return -1;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns `null`.\n   */\n  get tokenSource() {\n    return null;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} always returns `null`.\n   */\n  get inputStream() {\n    return null;\n  }\n  /**\n   * The implementation for {@link RuleTagToken} returns a string of the form\n   * `ruleName:bypassTokenType`.\n   */\n  toString() {\n    return this.ruleName + \":\" + this.bypassTokenType;\n  }\n};\n\n// src/tree/pattern/StartRuleDoesNotConsumeFullPatternError.ts\nvar StartRuleDoesNotConsumeFullPatternError = class extends Error {\n  static {\n    __name(this, \"StartRuleDoesNotConsumeFullPatternError\");\n  }\n};\n\n// src/tree/pattern/TagChunk.ts\nvar TagChunk = class extends Chunk {\n  static {\n    __name(this, \"TagChunk\");\n  }\n  tag;\n  label;\n  constructor(...args) {\n    let label;\n    let tag;\n    if (args.length === 1) {\n      tag = args[0];\n    } else {\n      label = args[0];\n      tag = args[1];\n    }\n    super();\n    if (!tag) {\n      throw new Error(\"tag cannot be null or empty\");\n    }\n    this.label = label;\n    this.tag = tag;\n  }\n  /**\n   * @returns a text representation of the tag chunk. Labeled tags\n   * are returned in the form `label:tag`, and unlabeled tags are\n   * returned as just the tag name.\n   */\n  toString() {\n    if (this.label !== void 0) {\n      return this.label + \":\" + this.tag;\n    }\n    return this.tag;\n  }\n};\n\n// src/tree/pattern/TextChunk.ts\nvar TextChunk = class extends Chunk {\n  static {\n    __name(this, \"TextChunk\");\n  }\n  text;\n  /**\n   * Constructs a new instance of {@link TextChunk} with the specified text.\n   *\n   * @param text The text of this chunk.\n   */\n  constructor(text) {\n    super();\n    this.text = text;\n  }\n  /**\n   * @returns the result of {@link #getText()} in single quotes.\n   */\n  toString() {\n    return \"'\" + this.text + \"'\";\n  }\n};\n\n// src/tree/pattern/TokenTagToken.ts\nvar TokenTagToken = class extends CommonToken {\n  static {\n    __name(this, \"TokenTagToken\");\n  }\n  tokenName;\n  /**\n   * The name of the label associated with the rule tag, or undefined if this is an unlabeled rule tag.\n   */\n  label;\n  constructor(tokenName, type, label) {\n    super({ type, source: CommonToken.EMPTY_SOURCE });\n    this.tokenName = tokenName;\n    this.label = label;\n  }\n  /**\n   *\n   * @returns the token tag formatted with `<` and `>` delimiters.\n   */\n  get text() {\n    if (this.label !== void 0) {\n      return \"<\" + this.label + \":\" + this.tokenName + \">\";\n    }\n    return \"<\" + this.tokenName + \">\";\n  }\n  /**\n   * @returns a string of the form `tokenName:type`.\n   */\n  toString() {\n    return this.tokenName + \":\" + this.type;\n  }\n};\n\n// src/tree/pattern/ParseTreePatternMatcher.ts\nvar ParseTreePatternMatcher = class {\n  static {\n    __name(this, \"ParseTreePatternMatcher\");\n  }\n  start = \"<\";\n  stop = \">\";\n  escape = \"\\\\\";\n  // e.g., \\< and \\> must escape BOTH!\n  /**\n   * This is the backing field for {@link #getLexer()}.\n   */\n  lexer;\n  /**\n   * This is the backing field for {@link #getParser()}.\n   */\n  parser;\n  /**\n   * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and\n   * {@link Parser} object. The lexer input stream is altered for tokenizing\n   * the tree patterns. The parser is used as a convenient mechanism to get\n   * the grammar name, plus token, rule names.\n   */\n  constructor(lexer, parser) {\n    this.lexer = lexer;\n    this.parser = parser;\n  }\n  /**\n   * Set the delimiters used for marking rule and token tags within concrete\n   * syntax used by the tree pattern parser.\n   *\n   * @param start The start delimiter.\n   * @param stop The stop delimiter.\n   * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.\n   *\n   * @throws Error if `start` is `null` or empty.\n   * @throws Error if `stop` is `null` or empty.\n   */\n  setDelimiters(start, stop, escapeLeft) {\n    if (start === null || start.length === 0) {\n      throw new Error(\"start cannot be null or empty\");\n    }\n    if (stop === null || stop.length === 0) {\n      throw new Error(\"stop cannot be null or empty\");\n    }\n    this.start = start;\n    this.stop = stop;\n    this.escape = escapeLeft;\n  }\n  matches(...args) {\n    switch (args.length) {\n      case 2: {\n        const [tree, pattern] = args;\n        const labels = new MultiMap();\n        const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);\n        return mismatchedNode === null;\n      }\n      case 3: {\n        const [tree, pattern, patternRuleIndex] = args;\n        const p = this.compile(pattern, patternRuleIndex);\n        return this.matches(tree, p);\n      }\n      default: {\n        throw new Error(\"Invalid number of arguments\");\n      }\n    }\n  }\n  match(...args) {\n    switch (args.length) {\n      case 2: {\n        const [tree, pattern] = args;\n        const labels = new MultiMap();\n        const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);\n        return new ParseTreeMatch(tree, pattern, labels, mismatchedNode);\n      }\n      case 3: {\n        const [tree, pattern, patternRuleIndex] = args;\n        const p = this.compile(pattern, patternRuleIndex);\n        return this.match(tree, p);\n      }\n      default: {\n        throw new Error(\"Invalid number of arguments\");\n      }\n    }\n  }\n  /**\n   * For repeated use of a tree pattern, compile it to a\n   * {@link ParseTreePattern} using this method.\n   */\n  compile(pattern, patternRuleIndex) {\n    const tokenList = this.tokenize(pattern);\n    const tokenSrc = new ListTokenSource(tokenList);\n    const tokens = new CommonTokenStream(tokenSrc);\n    const parserInterp = new ParserInterpreter(\n      this.parser.grammarFileName,\n      this.parser.vocabulary,\n      this.parser.ruleNames,\n      this.parser.getATNWithBypassAlts(),\n      tokens\n    );\n    parserInterp.removeErrorListeners();\n    let tree = null;\n    try {\n      parserInterp.errorHandler = new BailErrorStrategy();\n      tree = parserInterp.parse(patternRuleIndex);\n    } catch (error) {\n      if (error instanceof ParseCancellationException) {\n        throw error.cause;\n      } else if (error instanceof RecognitionException) {\n        throw error;\n      } else if (error instanceof Error) {\n        throw new CannotInvokeStartRuleError(error);\n      } else {\n        throw error;\n      }\n    }\n    if (tokens.LA(1) !== Token.EOF) {\n      throw new StartRuleDoesNotConsumeFullPatternError();\n    }\n    return new ParseTreePattern(this, pattern, patternRuleIndex, tree);\n  }\n  /**\n   * Used to convert the tree pattern string into a series of tokens. The\n   * input stream is reset.\n   */\n  getLexer() {\n    return this.lexer;\n  }\n  /**\n   * Used to collect to the grammar file name, token names, rule names for\n   * used to parse the pattern into a parse tree.\n   */\n  getParser() {\n    return this.parser;\n  }\n  // ---- SUPPORT CODE ----\n  tokenize(pattern) {\n    const chunks = this.split(pattern);\n    const tokens = new Array();\n    for (const chunk of chunks) {\n      if (chunk instanceof TagChunk) {\n        const tagChunk = chunk;\n        const char = tagChunk.tag[0];\n        if (char === char.toUpperCase()) {\n          const ttype = this.parser.getTokenType(tagChunk.tag);\n          if (ttype === Token.INVALID_TYPE) {\n            throw new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\n          }\n          const t = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);\n          tokens.push(t);\n        } else {\n          if (char === char.toLowerCase()) {\n            const ruleIndex = this.parser.getRuleIndex(tagChunk.tag);\n            if (ruleIndex === -1) {\n              throw new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\n            }\n            const ruleImaginaryTokenType = this.parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\n            tokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\n          } else {\n            throw new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\n          }\n        }\n      } else {\n        const textChunk = chunk;\n        const input = CharStream.fromString(textChunk.text);\n        this.lexer.inputStream = input;\n        let t = this.lexer.nextToken();\n        while (t.type !== Token.EOF) {\n          tokens.push(t);\n          t = this.lexer.nextToken();\n        }\n      }\n    }\n    return tokens;\n  }\n  /**\n   * Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}.\n   */\n  split(pattern) {\n    let p = 0;\n    const n2 = pattern.length;\n    const chunks = new Array();\n    const starts = new Array();\n    const stops = new Array();\n    while (p < n2) {\n      if (p === pattern.indexOf(this.escape + this.start, p)) {\n        p += this.escape.length + this.start.length;\n      } else {\n        if (p === pattern.indexOf(this.escape + this.stop, p)) {\n          p += this.escape.length + this.stop.length;\n        } else {\n          if (p === pattern.indexOf(this.start, p)) {\n            starts.push(p);\n            p += this.start.length;\n          } else {\n            if (p === pattern.indexOf(this.stop, p)) {\n              stops.push(p);\n              p += this.stop.length;\n            } else {\n              p++;\n            }\n          }\n        }\n      }\n    }\n    if (starts.length > stops.length) {\n      throw new Error(\"unterminated tag in pattern: \" + pattern);\n    }\n    if (starts.length < stops.length) {\n      throw new Error(\"missing start tag in pattern: \" + pattern);\n    }\n    const tagCount = starts.length;\n    for (let i = 0; i < tagCount; i++) {\n      if (starts[i] >= stops[i]) {\n        throw new Error(\"tag delimiters out of order in pattern: \" + pattern);\n      }\n    }\n    if (tagCount === 0) {\n      const text = pattern.substring(0, n2);\n      chunks.push(new TextChunk(text));\n    }\n    if (tagCount > 0 && starts[0] > 0) {\n      const text = pattern.substring(0, starts[0]);\n      chunks.push(new TextChunk(text));\n    }\n    for (let i = 0; i < tagCount; i++) {\n      const tag = pattern.substring(starts[i] + this.start.length, stops[i]);\n      let ruleOrToken = tag;\n      let label;\n      const colon = tag.indexOf(\":\");\n      if (colon >= 0) {\n        label = tag.substring(0, colon);\n        ruleOrToken = tag.substring(colon + 1, tag.length);\n      }\n      chunks.push(new TagChunk(label, ruleOrToken));\n      if (i + 1 < tagCount) {\n        const text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\n        chunks.push(new TextChunk(text));\n      }\n    }\n    if (tagCount > 0) {\n      const afterLastTag = stops[tagCount - 1] + this.stop.length;\n      if (afterLastTag < n2) {\n        const text = pattern.substring(afterLastTag, n2);\n        chunks.push(new TextChunk(text));\n      }\n    }\n    for (let i = 0; i < chunks.length; i++) {\n      const c = chunks[i];\n      if (c instanceof TextChunk) {\n        const tc = c;\n        const unescaped = tc.text.replaceAll(this.escape, \"\");\n        if (unescaped.length < tc.text.length) {\n          chunks[i] = new TextChunk(unescaped);\n        }\n      }\n    }\n    return chunks;\n  }\n  /**\n   * Recursively walk `tree` against `patternTree`, filling\n   * `match.`{@link ParseTreeMatch#labels labels}.\n   *\n   * @returns the first node encountered in `tree` which does not match\n   * a corresponding node in `patternTree`, or `null` if the match\n   * was successful. The specific node returned depends on the matching\n   * algorithm used by the implementation, and may be overridden.\n   */\n  matchImpl(tree, patternTree, labels) {\n    if (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {\n      const t1 = tree;\n      const t2 = patternTree;\n      let mismatchedNode;\n      if (t1.getSymbol().type === t2.getSymbol().type) {\n        if (t2.getSymbol() instanceof TokenTagToken) {\n          const tokenTagToken = t2.getSymbol();\n          labels.map(tokenTagToken.tokenName, tree);\n          if (tokenTagToken.label !== void 0) {\n            labels.map(tokenTagToken.label, tree);\n          }\n        } else {\n          if (t1.getText() === t2.getText()) {\n          } else {\n            if (!mismatchedNode) {\n              mismatchedNode = t1;\n            }\n          }\n        }\n      } else {\n        if (!mismatchedNode) {\n          mismatchedNode = t1;\n        }\n      }\n      return mismatchedNode;\n    }\n    if (tree instanceof ParserRuleContext && patternTree instanceof ParserRuleContext) {\n      let mismatchedNode;\n      const ruleTagToken = this.getRuleTagToken(patternTree);\n      if (ruleTagToken) {\n        if (tree.ruleIndex === patternTree.ruleIndex) {\n          labels.map(ruleTagToken.ruleName, tree);\n          if (ruleTagToken.label) {\n            labels.map(ruleTagToken.label, tree);\n          }\n        } else {\n          if (!mismatchedNode) {\n            mismatchedNode = tree;\n          }\n        }\n        return mismatchedNode;\n      }\n      if (tree.getChildCount() !== patternTree.getChildCount()) {\n        if (!mismatchedNode) {\n          mismatchedNode = tree;\n        }\n        return mismatchedNode;\n      }\n      const n2 = tree.getChildCount();\n      for (let i = 0; i < n2; i++) {\n        const childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\n        if (childMatch) {\n          return childMatch;\n        }\n      }\n      return mismatchedNode;\n    }\n    return tree;\n  }\n  /**\n   * Is `t` `(expr <expr>)` subtree?\n   */\n  getRuleTagToken(t) {\n    if (t instanceof ParserRuleContext) {\n      if (t.getChildCount() === 1 && t.getChild(0) instanceof TerminalNode) {\n        const c = t.getChild(0);\n        if (c.getSymbol() instanceof RuleTagToken) {\n          return c.getSymbol();\n        }\n      }\n    }\n    return void 0;\n  }\n};\n\n// src/DiagnosticErrorListener.ts\nvar DiagnosticErrorListener = class extends BaseErrorListener {\n  static {\n    __name(this, \"DiagnosticErrorListener\");\n  }\n  /**\n   * When `true`, only exactly known ambiguities are reported.\n   */\n  exactOnly;\n  constructor(exactOnly) {\n    super();\n    this.exactOnly = exactOnly ?? true;\n  }\n  reportAmbiguity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) => {\n    if (this.exactOnly && !exact) {\n      return;\n    }\n    const decision = this.getDecisionDescription(recognizer, dfa);\n    const conflictingAlts = this.getConflictingAlts(ambigAlts, configs);\n    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));\n    const message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n    recognizer.notifyErrorListeners(message, null, null);\n  }, \"reportAmbiguity\");\n  reportAttemptingFullContext = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _conflictingAlts, _configs) => {\n    const decision = this.getDecisionDescription(recognizer, dfa);\n    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));\n    const message = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n    recognizer.notifyErrorListeners(message, null, null);\n  }, \"reportAttemptingFullContext\");\n  reportContextSensitivity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _prediction, _configs) => {\n    const decision = this.getDecisionDescription(recognizer, dfa);\n    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));\n    const message = `reportContextSensitivity d=${decision}, input='${text}'`;\n    recognizer.notifyErrorListeners(message, null, null);\n  }, \"reportContextSensitivity\");\n  getDecisionDescription = /* @__PURE__ */ __name((recognizer, dfa) => {\n    const decision = dfa.decision;\n    const ruleIndex = dfa.atnStartState.ruleIndex;\n    const ruleNames = recognizer.ruleNames;\n    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n      return decision.toString();\n    }\n    const ruleName = ruleNames[ruleIndex];\n    if (ruleName.length === 0) {\n      return decision.toString();\n    }\n    return `${decision} (${ruleName})`;\n  }, \"getDecisionDescription\");\n  /**\n   * Computes the set of conflicting or ambiguous alternatives from a\n   * configuration set, if that information was not already provided by the\n   * parser.\n   *\n   * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n   * reported by the parser.\n   * @param configs The conflicting or ambiguous configuration set.\n   * @returns Returns `reportedAlts` if it is not `null`, otherwise\n   * returns the set of alternatives represented in `configs`.\n   */\n  getConflictingAlts = /* @__PURE__ */ __name((reportedAlts, configs) => {\n    if (reportedAlts) {\n      return reportedAlts;\n    }\n    const result = new BitSet();\n    for (let i = 0; i < configs.configs.length; i++) {\n      result.set(configs.configs[i].alt);\n    }\n    return result;\n  }, \"getConflictingAlts\");\n};\n\n// src/LexerInterpreter.ts\nvar LexerInterpreter = class extends Lexer {\n  static {\n    __name(this, \"LexerInterpreter\");\n  }\n  decisionToDFA;\n  sharedContextCache = new PredictionContextCache();\n  #grammarFileName;\n  #atn;\n  #ruleNames;\n  #channelNames;\n  #modeNames;\n  #vocabulary;\n  constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {\n    super(input);\n    if (atn.grammarType !== ATN.LEXER) {\n      throw new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\n    }\n    this.#grammarFileName = grammarFileName;\n    this.#atn = atn;\n    this.#ruleNames = ruleNames.slice(0);\n    this.#channelNames = channelNames.slice(0);\n    this.#modeNames = modeNames.slice(0);\n    this.#vocabulary = vocabulary;\n    this.decisionToDFA = atn.decisionToState.map((ds, i) => {\n      return new DFA(ds, i);\n    });\n    this.interpreter = new LexerATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);\n  }\n  get atn() {\n    return this.#atn;\n  }\n  get grammarFileName() {\n    return this.#grammarFileName;\n  }\n  get ruleNames() {\n    return this.#ruleNames;\n  }\n  get channelNames() {\n    return this.#channelNames;\n  }\n  get modeNames() {\n    return this.#modeNames;\n  }\n  get vocabulary() {\n    return this.#vocabulary;\n  }\n  get serializedATN() {\n    throw new Error(\"The LexerInterpreter does not support the serializedATN property.\");\n  }\n};\n\n// src/RuntimeMetaData.ts\nvar RuntimeMetaData = class _RuntimeMetaData {\n  static {\n    __name(this, \"RuntimeMetaData\");\n  }\n  /**\n   * A compile-time constant containing the current version of the ANTLR 4\n   * runtime library.\n   *\n   * This compile-time constant value allows generated parsers and other\n   * libraries to include a literal reference to the version of the ANTLR 4\n   * runtime library the code was compiled against. At each release, we\n   * change this value.\n   *\n   * Version numbers are assumed to have the form\n   *\n   * major.minor.patch.revision-suffix,\n   *\n   * with the individual components defined as follows.\n   *\n   * - major is a required non-negative integer, and is equal to `4` for ANTLR 4.\n   * - minor is a required non-negative integer.\n   * - patch is an optional non-negative integer. When patch is omitted, the `.` (dot) appearing before it is\n   *   also omitted.\n   * - revision is an optional non-negative integer, and may only be included when patch is also included.\n   *   When revision is omitted, the `.` (dot) appearing before it is also omitted.\n   * - suffix is an optional string. When suffix is omitted, the `-` (hyphen-minus) appearing before it is also\n   *   omitted.\n   */\n  static VERSION = \"4.13.1\";\n  /**\n   * Gets the currently executing version of the ANTLR 4 runtime library.\n   *\n   * This method provides runtime access to the {@link VERSION} field, as\n   * opposed to directly referencing the field as a compile-time constant.\n   *\n   * @returns The currently executing version of the ANTLR 4 library\n   */\n  static getRuntimeVersion() {\n    return _RuntimeMetaData.VERSION;\n  }\n  /**\n   * This method provides the ability to detect mismatches between the version\n   * of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a\n   * parser was compiled against, and the version of the ANTLR runtime which\n   * is currently executing.\n   *\n   * The version check is designed to detect the following two specific\n   * scenarios.\n   *\n   * - The ANTLR Tool version used for code generation does not match the\n   * currently executing runtime version.\n   * - The ANTLR Runtime version referenced at the time a parser was\n   * compiled does not match the currently executing runtime version.\n   *\n   *\n   * Starting with ANTLR 4.3, the code generator emits a call to this method\n   * using two constants in each generated lexer and parser: a hard-coded\n   * constant indicating the version of the tool used to generate the parser\n   * and a reference to the compile-time constant {@link VERSION}. At\n   * runtime, this method is called during the initialization of the generated\n   * parser to detect mismatched versions, and notify the registered listeners\n   * prior to creating instances of the parser.\n   *\n   *\n   * This method does not perform any detection or filtering of semantic\n   * changes between tool and runtime versions. It simply checks for a\n   * version match and emits an error to stderr if a difference\n   * is detected.\n   *\n   *\n   * Note that some breaking changes between releases could result in other\n   * types of runtime exceptions, such as a {@link LinkageError}, prior to\n   * calling this method. In these cases, the underlying version mismatch will\n   * not be reported here. This method is primarily intended to\n   * notify users of potential semantic changes between releases that do not\n   * result in binary compatibility problems which would be detected by the\n   * class loader. As with semantic changes, changes that break binary\n   * compatibility between releases are mentioned in the release notes\n   * accompanying the affected release.\n   *\n   *\n   * **Additional note for target developers:** The version check\n   * implemented by this class is designed to address specific compatibility\n   * concerns that may arise during the execution of Java applications. Other\n   * targets should consider the implementation of this method in the context\n   * of that target's known execution environment, which may or may not\n   * resemble the design provided for the Java target.\n   *\n   * @param generatingToolVersion The version of the tool used to generate a parser.\n   * This value may be null when called from user code that was not generated\n   * by, and does not reference, the ANTLR 4 Tool itself.\n   * @param compileTimeVersion The version of the runtime the parser was\n   * compiled against. This should always be passed using a direct reference\n   * to {@link VERSION}.\n   */\n  static checkVersion(generatingToolVersion, compileTimeVersion) {\n    const runtimeVersion = _RuntimeMetaData.VERSION;\n    let runtimeConflictsWithGeneratingTool = false;\n    let runtimeConflictsWithCompileTimeTool = false;\n    runtimeConflictsWithGeneratingTool = runtimeVersion !== generatingToolVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(generatingToolVersion);\n    runtimeConflictsWithCompileTimeTool = runtimeVersion !== compileTimeVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(compileTimeVersion);\n    if (runtimeConflictsWithGeneratingTool) {\n      console.error(`ANTLR Tool version ${generatingToolVersion} used for code generation does not match the current runtime version ${runtimeVersion}`);\n    }\n    if (runtimeConflictsWithCompileTimeTool) {\n      console.error(`ANTLR Runtime version ${compileTimeVersion} used for parser compilation does not match the current runtime version ${runtimeVersion}`);\n    }\n  }\n  /**\n   * Gets the major and minor version numbers from a version string. For\n   * details about the syntax of the input `version`.\n   * E.g., from x.y.z return x.y.\n   *\n   * @param version The complete version string.\n   * @returns A string of the form *major*.*minor* containing\n   * only the major and minor components of the version string.\n   */\n  static getMajorMinorVersion(version) {\n    const firstDot = version.indexOf(\".\");\n    const secondDot = firstDot >= 0 ? version.indexOf(\".\", firstDot + 1) : -1;\n    const firstDash = version.indexOf(\"-\");\n    let referenceLength = version.length;\n    if (secondDot >= 0) {\n      referenceLength = Math.min(referenceLength, secondDot);\n    }\n    if (firstDash >= 0) {\n      referenceLength = Math.min(referenceLength, firstDash);\n    }\n    return version.substring(0, referenceLength);\n  }\n};\n\n// src/TokenStreamRewriter.ts\nvar TokenStreamRewriter = class _TokenStreamRewriter {\n  static {\n    __name(this, \"TokenStreamRewriter\");\n  }\n  static DEFAULT_PROGRAM_NAME = \"default\";\n  static PROGRAM_INIT_SIZE = 100;\n  static MIN_TOKEN_INDEX = 0;\n  /** Our source stream */\n  tokens;\n  /**\n   * You may have multiple, named streams of rewrite operations.\n   *  I'm calling these things \"programs.\"\n   *  Maps String (name) -> rewrite (List)\n   */\n  programs = /* @__PURE__ */ new Map();\n  /** Map String (program name) -> Integer index */\n  lastRewriteTokenIndexes;\n  /**\n   * @param tokens The token stream to modify\n   */\n  constructor(tokens) {\n    this.tokens = tokens;\n  }\n  getTokenStream() {\n    return this.tokens;\n  }\n  /**\n   * Insert the supplied text after the specified token (or token index)\n   */\n  insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    let index;\n    if (typeof tokenOrIndex === \"number\") {\n      index = tokenOrIndex;\n    } else {\n      index = tokenOrIndex.tokenIndex;\n    }\n    const rewrites = this.getProgram(programName);\n    const op = new InsertAfterOp(this.tokens, index, rewrites.length, text);\n    rewrites.push(op);\n  }\n  /**\n   * Insert the supplied text before the specified token (or token index)\n   */\n  insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    let index;\n    if (typeof tokenOrIndex === \"number\") {\n      index = tokenOrIndex;\n    } else {\n      index = tokenOrIndex.tokenIndex;\n    }\n    const rewrites = this.getProgram(programName);\n    const op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);\n    rewrites.push(op);\n  }\n  /**\n   * Replace the specified token with the supplied text\n   */\n  replaceSingle(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    this.replace(tokenOrIndex, tokenOrIndex, text, programName);\n  }\n  /**\n   * Replace the specified range of tokens with the supplied text.\n   */\n  replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    if (typeof from !== \"number\") {\n      from = from.tokenIndex;\n    }\n    if (typeof to !== \"number\") {\n      to = to.tokenIndex;\n    }\n    if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {\n      throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n    }\n    const rewrites = this.getProgram(programName);\n    const op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);\n    rewrites.push(op);\n  }\n  /**\n   * Delete the specified range of tokens\n   */\n  delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    if (to == null) {\n      to = from;\n    }\n    this.replace(from, to, null, programName);\n  }\n  getProgram(name) {\n    let is = this.programs.get(name);\n    if (is == null) {\n      is = this.initializeProgram(name);\n    }\n    return is;\n  }\n  initializeProgram(name) {\n    const is = [];\n    this.programs.set(name, is);\n    return is;\n  }\n  /**\n   * @returns the text from the original tokens altered per the instructions given to this rewriter\n   */\n  getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n    let interval;\n    if (intervalOrProgram instanceof Interval) {\n      interval = intervalOrProgram;\n    } else {\n      interval = new Interval(0, this.tokens.size - 1);\n    }\n    if (typeof intervalOrProgram === \"string\") {\n      programName = intervalOrProgram;\n    }\n    const rewrites = this.programs.get(programName);\n    let start = interval.start;\n    let stop = interval.stop;\n    if (stop > this.tokens.size - 1) {\n      stop = this.tokens.size - 1;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (rewrites == null || rewrites.length === 0) {\n      return this.tokens.getTextFromInterval(new Interval(start, stop));\n    }\n    const buf = [];\n    const indexToOp = this.reduceToSingleOperationPerIndex(rewrites);\n    let i = start;\n    while (i <= stop && i < this.tokens.size) {\n      const op = indexToOp.get(i);\n      indexToOp.delete(i);\n      const t = this.tokens.get(i);\n      if (op == null) {\n        if (t.type !== Token.EOF) {\n          buf.push(String(t.text));\n        }\n        i++;\n      } else {\n        i = op.execute(buf);\n      }\n    }\n    if (stop === this.tokens.size - 1) {\n      for (const op of indexToOp.values()) {\n        if (op && op.index >= this.tokens.size - 1) {\n          buf.push(String(op.text));\n        }\n      }\n    }\n    return buf.join(\"\");\n  }\n  /**\n   * @returns a map from token index to operation\n   */\n  reduceToSingleOperationPerIndex(rewrites) {\n    for (let i = 0; i < rewrites.length; i++) {\n      const op = rewrites[i];\n      if (op == null) {\n        continue;\n      }\n      if (!(op instanceof ReplaceOp)) {\n        continue;\n      }\n      const rop = op;\n      const inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n      for (const iop of inserts) {\n        if (iop.index === rop.index) {\n          rewrites[iop.instructionIndex] = null;\n          rop.text = String(iop.text) + (rop.text != null ? rop.text.toString() : \"\");\n        } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n          rewrites[iop.instructionIndex] = null;\n        }\n      }\n      const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n      for (const prevRop of prevReplaces) {\n        if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n          rewrites[prevRop.instructionIndex] = null;\n          continue;\n        }\n        const disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n        if (prevRop.text == null && rop.text == null && !disjoint) {\n          rewrites[prevRop.instructionIndex] = null;\n          rop.index = Math.min(prevRop.index, rop.index);\n          rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n        } else if (!disjoint) {\n          throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n        }\n      }\n    }\n    for (let i = 0; i < rewrites.length; i++) {\n      const op = rewrites[i];\n      if (op == null) {\n        continue;\n      }\n      if (!(op instanceof InsertBeforeOp)) {\n        continue;\n      }\n      const iop = op;\n      const prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n      for (const prevIop of prevInserts) {\n        if (prevIop.index === iop.index) {\n          if (prevIop instanceof InsertAfterOp) {\n            iop.text = this.catOpText(prevIop.text, iop.text);\n            rewrites[prevIop.instructionIndex] = null;\n          } else if (prevIop instanceof InsertBeforeOp) {\n            iop.text = this.catOpText(iop.text, prevIop.text);\n            rewrites[prevIop.instructionIndex] = null;\n          }\n        }\n      }\n      const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n      for (const rop of prevReplaces) {\n        if (iop.index === rop.index) {\n          rop.text = this.catOpText(iop.text, rop.text);\n          rewrites[i] = null;\n          continue;\n        }\n        if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n          throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n        }\n      }\n    }\n    const m2 = /* @__PURE__ */ new Map();\n    for (const op of rewrites) {\n      if (op == null) {\n        continue;\n      }\n      if (m2.get(op.index) != null) {\n        throw new Error(\"should only be one op per index\");\n      }\n      m2.set(op.index, op);\n    }\n    return m2;\n  }\n  catOpText(a, b) {\n    let x = \"\";\n    let y = \"\";\n    if (a != null) {\n      x = a.toString();\n    }\n    if (b != null) {\n      y = b.toString();\n    }\n    return x + y;\n  }\n  /**\n   * Get all operations before an index of a particular kind\n   */\n  getKindOfOps(rewrites, kind, before) {\n    return rewrites.slice(0, before).filter((op) => {\n      return op && op instanceof kind;\n    });\n  }\n};\nvar RewriteOperation = class {\n  static {\n    __name(this, \"RewriteOperation\");\n  }\n  /** What index into rewrites List are we? */\n  instructionIndex;\n  /** Token buffer index. */\n  index;\n  text;\n  tokens;\n  constructor(tokens, index, instructionIndex, text) {\n    this.tokens = tokens;\n    this.instructionIndex = instructionIndex;\n    this.index = index;\n    this.text = text === void 0 ? \"\" : text;\n  }\n  execute(_buf) {\n    return this.index;\n  }\n  toString() {\n    return \"<RewriteOperation@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n  }\n};\nvar InsertBeforeOp = class extends RewriteOperation {\n  static {\n    __name(this, \"InsertBeforeOp\");\n  }\n  constructor(tokens, index, instructionIndex, text) {\n    super(tokens, index, instructionIndex, text);\n  }\n  /**\n   * @returns the index of the next token to operate on\n   */\n  execute(buf) {\n    if (this.text) {\n      buf.push(this.text.toString());\n    }\n    if (this.tokens.get(this.index).type !== Token.EOF) {\n      buf.push(String(this.tokens.get(this.index).text));\n    }\n    return this.index + 1;\n  }\n  toString() {\n    return \"<InsertBeforeOp@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n  }\n};\nvar InsertAfterOp = class extends InsertBeforeOp {\n  static {\n    __name(this, \"InsertAfterOp\");\n  }\n  constructor(tokens, index, instructionIndex, text) {\n    super(tokens, index + 1, instructionIndex, text);\n  }\n  toString() {\n    return \"<InsertAfterOp@\" + this.tokens.get(this.index) + ':\"' + this.text + '\">';\n  }\n};\nvar ReplaceOp = class extends RewriteOperation {\n  static {\n    __name(this, \"ReplaceOp\");\n  }\n  lastIndex;\n  constructor(tokens, from, to, instructionIndex, text) {\n    super(tokens, from, instructionIndex, text);\n    this.lastIndex = to;\n  }\n  /**\n   * @returns the index of the next token to operate on\n   */\n  execute(buf) {\n    if (this.text) {\n      buf.push(this.text.toString());\n    }\n    return this.lastIndex + 1;\n  }\n  toString() {\n    if (this.text == null) {\n      return \"<DeleteOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + \">\";\n    }\n    return \"<ReplaceOp@\" + this.tokens.get(this.index) + \"..\" + this.tokens.get(this.lastIndex) + ':\"' + this.text + '\">';\n  }\n};\n\n// src/UnbufferedTokenStream.ts\nvar UnbufferedTokenStream = class {\n  static {\n    __name(this, \"UnbufferedTokenStream\");\n  }\n  tokenSource;\n  /**\n   * A moving window buffer of the data being scanned. While there's a marker,\n   * we keep adding to buffer. Otherwise, {@link #consume consume()} resets so\n   * we start filling at index 0 again.\n   */\n  tokens;\n  /**\n   * The number of tokens currently in {@link #tokens tokens}.\n   *\n   * This is not the buffer capacity, that's `tokens.length`.\n   */\n  n;\n  /**\n   * 0..n-1 index into {@link #tokens tokens} of next token.\n   *\n   * The `LT(1)` token is `tokens[p]`. If `p == n`, we are\n   * out of buffered tokens.\n   */\n  p = 0;\n  /**\n   * Count up with {@link #mark mark()} and down with\n   * {@link #release release()}. When we `release()` the last mark,\n   * `numMarkers` reaches 0 and we reset the buffer. Copy\n   * `tokens[p]..tokens[n-1]` to `tokens[0]..tokens[(n-1)-p]`.\n   */\n  numMarkers = 0;\n  /**\n   * This is the `LT(-1)` token for the current position.\n   */\n  lastToken;\n  /**\n   * When `numMarkers > 0`, this is the `LT(-1)` token for the\n   * first token in {@link #tokens}. Otherwise, this is `null`.\n   */\n  lastTokenBufferStart;\n  /**\n   * Absolute token index. It's the index of the token about to be read via\n   * `LT(1)`. Goes from 0 to the number of tokens in the entire stream,\n   * although the stream size is unknown before the end is reached.\n   *\n   * This value is used to set the token indexes if the stream provides tokens\n   * that implement {@link WritableToken}.\n   */\n  currentTokenIndex = 0;\n  constructor(tokenSource, bufferSize) {\n    this.tokenSource = tokenSource;\n    bufferSize = bufferSize ?? 256;\n    this.tokens = new Array(bufferSize);\n    this.n = 0;\n    this.fill(1);\n  }\n  get(i) {\n    const bufferStartIndex = this.getBufferStartIndex();\n    if (i < bufferStartIndex || i >= bufferStartIndex + this.n) {\n      throw new Error(\"get(\" + i + \") outside buffer: \" + bufferStartIndex + \"..\" + (bufferStartIndex + this.n));\n    }\n    return this.tokens[i - bufferStartIndex];\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  LT(i) {\n    if (i === -1) {\n      return this.lastToken;\n    }\n    this.sync(i);\n    const index = this.p + i - 1;\n    if (index < 0) {\n      throw new Error(\"LT(\" + i + \") gives negative index\");\n    }\n    if (index >= this.n) {\n      return this.tokens[this.n - 1];\n    }\n    return this.tokens[index];\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  LA(i) {\n    return this.LT(i).type;\n  }\n  getText() {\n    return \"\";\n  }\n  getTextFromContext(ctx) {\n    return this.getTextFromInterval(ctx.getSourceInterval());\n  }\n  getTextFromInterval(interval) {\n    const bufferStartIndex = this.getBufferStartIndex();\n    const bufferStopIndex = bufferStartIndex + this.tokens.length - 1;\n    const start = interval.start;\n    const stop = interval.stop;\n    if (start < bufferStartIndex || stop > bufferStopIndex) {\n      throw new Error(\"interval \" + interval + \" not in token buffer window: \" + bufferStartIndex + \"..\" + bufferStopIndex);\n    }\n    const a = start - bufferStartIndex;\n    const b = stop - bufferStartIndex;\n    let result = \"\";\n    for (let i = a; i <= b; i++) {\n      const t = this.tokens[i];\n      result += t.text;\n    }\n    return result;\n  }\n  getTextFromRange(start, stop) {\n    return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));\n  }\n  consume() {\n    if (this.LA(1) === Token.EOF) {\n      throw new Error(\"cannot consume EOF\");\n    }\n    this.lastToken = this.tokens[this.p];\n    if (this.p === this.n - 1 && this.numMarkers === 0) {\n      this.n = 0;\n      this.p = -1;\n      this.lastTokenBufferStart = this.lastToken;\n    }\n    this.p++;\n    this.currentTokenIndex++;\n    this.sync(1);\n  }\n  /**\n   * Return a marker that we can release later.\n   *\n   * The specific marker value used for this class allows for some level of\n   * protection against misuse where `seek()` is called on a mark or\n   * `release()` is called in the wrong order.\n   */\n  mark() {\n    if (this.numMarkers === 0) {\n      this.lastTokenBufferStart = this.lastToken;\n    }\n    const mark = -this.numMarkers - 1;\n    this.numMarkers++;\n    return mark;\n  }\n  release(marker) {\n    const expectedMark = -this.numMarkers;\n    if (marker !== expectedMark) {\n      throw new Error(\"release() called with an invalid marker.\");\n    }\n    this.numMarkers--;\n    if (this.numMarkers === 0) {\n      if (this.p > 0) {\n        this.tokens.copyWithin(0, this.p, this.n);\n        this.n = this.n - this.p;\n        this.p = 0;\n      }\n      this.lastTokenBufferStart = this.lastToken;\n    }\n  }\n  get index() {\n    return this.currentTokenIndex;\n  }\n  seek(index) {\n    if (index === this.currentTokenIndex) {\n      return;\n    }\n    if (index > this.currentTokenIndex) {\n      this.sync(index - this.currentTokenIndex);\n      index = Math.min(index, this.getBufferStartIndex() + this.n - 1);\n    }\n    const bufferStartIndex = this.getBufferStartIndex();\n    const i = index - bufferStartIndex;\n    if (i < 0) {\n      throw new Error(\"cannot seek to negative index \" + index);\n    } else {\n      if (i >= this.n) {\n        throw new Error(\"seek to index outside buffer: \" + index + \" not in \" + bufferStartIndex + \"..\" + (bufferStartIndex + this.n));\n      }\n    }\n    this.p = i;\n    this.currentTokenIndex = index;\n    if (this.p === 0) {\n      this.lastToken = this.lastTokenBufferStart;\n    } else {\n      this.lastToken = this.tokens[this.p - 1];\n    }\n  }\n  get size() {\n    throw new Error(\"Unbuffered stream cannot know its size\");\n  }\n  getSourceName() {\n    return this.tokenSource.sourceName;\n  }\n  setLine(line) {\n    this.tokenSource.line = line;\n  }\n  setColumn(column) {\n    this.tokenSource.column = column;\n  }\n  /**\n   * Make sure we have 'need' elements from current position {@link #p p}. Last valid\n   * `p` index is `tokens.length-1`.  `p+need-1` is the tokens index 'need' elements\n   * ahead.  If we need 1 element, `(p+1-1)==p` must be less than `tokens.length`.\n   */\n  sync(want) {\n    const need = this.p + want - 1 - this.n + 1;\n    if (need > 0) {\n      this.fill(need);\n    }\n  }\n  /**\n   * Add `n` elements to the buffer. Returns the number of tokens\n   * actually added to the buffer. If the return value is less than `n`,\n   * then EOF was reached before `n` tokens could be added.\n   */\n  fill(n2) {\n    for (let i = 0; i < n2; i++) {\n      if (this.n > 0 && this.tokens[this.n - 1].type === Token.EOF) {\n        return i;\n      }\n      const t = this.tokenSource.nextToken();\n      this.add(t);\n    }\n    return n2;\n  }\n  add(t) {\n    if (this.n >= this.tokens.length) {\n      this.tokens.length = this.tokens.length * 2;\n    }\n    if (isWritableToken(t)) {\n      t.setTokenIndex(this.getBufferStartIndex() + this.n);\n    }\n    this.tokens[this.n++] = t;\n  }\n  getBufferStartIndex() {\n    return this.currentTokenIndex - this.p;\n  }\n};\nexport {\n  ATN,\n  ATNConfig,\n  ATNConfigSet,\n  ATNDeserializer,\n  ATNSerializer,\n  ATNSimulator,\n  ATNState,\n  AbstractParseTreeVisitor,\n  AbstractPredicateTransition,\n  ActionTransition,\n  ArrayPredictionContext,\n  AtomTransition,\n  BailErrorStrategy,\n  BaseErrorListener,\n  BasicBlockStartState,\n  BasicState,\n  BitSet,\n  BlockEndState,\n  BlockStartState,\n  BufferedTokenStream,\n  CannotInvokeStartRuleError,\n  CharStream,\n  CharStreamImpl,\n  Chunk,\n  CodePointTransitions,\n  CommonToken,\n  CommonTokenFactory,\n  CommonTokenStream,\n  ConsoleErrorListener,\n  DFA,\n  DFASerializer,\n  DFAState,\n  DecisionInfo,\n  DecisionState,\n  DefaultErrorStrategy,\n  DiagnosticErrorListener,\n  DoubleDict,\n  EmptyPredictionContext,\n  EpsilonTransition,\n  ErrorNode,\n  FailedPredicateException,\n  HashMap,\n  HashSet,\n  InputMismatchException,\n  IntStream,\n  InterpreterDataReader,\n  InterpreterRuleContext,\n  Interval,\n  IntervalSet,\n  LL1Analyzer,\n  Lexer,\n  LexerATNConfig,\n  LexerATNSimulator,\n  LexerActionExecutor,\n  LexerActionType,\n  LexerChannelAction,\n  LexerCustomAction,\n  LexerDFASerializer,\n  LexerIndexedCustomAction,\n  LexerInterpreter,\n  LexerModeAction,\n  LexerMoreAction,\n  LexerNoViableAltException,\n  LexerPopModeAction,\n  LexerPushModeAction,\n  LexerSkipAction,\n  LexerTypeAction,\n  ListTokenSource,\n  LoopEndState,\n  MurmurHash,\n  NoViableAltException,\n  NotSetTransition,\n  OrderedATNConfigSet,\n  OrderedHashMap,\n  OrderedHashSet,\n  ParseCancellationException,\n  ParseInfo,\n  ParseTreeMatch,\n  ParseTreePattern,\n  ParseTreePatternMatcher,\n  ParseTreeWalker,\n  Parser,\n  ParserATNSimulator,\n  ParserInterpreter,\n  ParserRuleContext,\n  PlusBlockStartState,\n  PlusLoopbackState,\n  PrecedencePredicateTransition,\n  PredPrediction,\n  PredicateTransition,\n  PredictionContext,\n  PredictionContextCache,\n  PredictionMode,\n  ProfilingATNSimulator,\n  ProxyErrorListener,\n  RangeTransition,\n  RecognitionException,\n  Recognizer,\n  RuleStartState,\n  RuleStopState,\n  RuleTagToken,\n  RuleTransition,\n  RuntimeMetaData,\n  SemanticContext,\n  SetTransition,\n  SingletonPredictionContext,\n  StarBlockStartState,\n  StarLoopEntryState,\n  StarLoopbackState,\n  StartRuleDoesNotConsumeFullPatternError,\n  TagChunk,\n  TerminalNode,\n  TextChunk,\n  Token,\n  TokenStreamRewriter,\n  TokenTagToken,\n  TokensStartState,\n  TraceListener,\n  Transition,\n  Trees,\n  UnbufferedTokenStream,\n  Vocabulary,\n  WildcardTransition,\n  XPath,\n  XPathElement,\n  XPathLexer,\n  XPathLexerErrorListener,\n  XPathRuleAnywhereElement,\n  XPathRuleElement,\n  XPathTokenAnywhereElement,\n  XPathTokenElement,\n  XPathWildcardAnywhereElement,\n  XPathWildcardElement,\n  arrayToString,\n  combineCommonParents,\n  createSingletonPredictionContext,\n  equalArrays,\n  equalNumberArrays,\n  escapeWhitespace,\n  getCachedPredictionContext,\n  isComparable,\n  isToken,\n  isWritableToken,\n  merge,\n  mergeRoot,\n  mergeSingletons,\n  predictionContextFromRuleContext\n};\n","// Generated from c:/Users/minip/source/repos/ahk2-antlr4-demo/src/grammar/MainGrammar.g4 by ANTLR 4.13.1\r\n\r\nimport * as antlr from \"antlr4ng\";\r\nimport { Token } from \"antlr4ng\";\r\n\r\n\r\nexport class MainGrammarLexer extends antlr.Lexer {\r\n    public static readonly AND = 1;\r\n    public static readonly OR = 2;\r\n    public static readonly NOT = 3;\r\n    public static readonly EQ = 4;\r\n    public static readonly COMMA = 5;\r\n    public static readonly SEMI = 6;\r\n    public static readonly LPAREN = 7;\r\n    public static readonly RPAREN = 8;\r\n    public static readonly LCURLY = 9;\r\n    public static readonly RCURLY = 10;\r\n    public static readonly INT = 11;\r\n    public static readonly ID = 12;\r\n    public static readonly WS = 13;\r\n\r\n    public static readonly channelNames = [\r\n        \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\"\r\n    ];\r\n\r\n    public static readonly literalNames = [\r\n        null, \"'and'\", \"'or'\", \"'not'\", \"'='\", \"','\", \"';'\", \"'('\", \"')'\", \r\n        \"'{'\", \"'}'\"\r\n    ];\r\n\r\n    public static readonly symbolicNames = [\r\n        null, \"AND\", \"OR\", \"NOT\", \"EQ\", \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \r\n        \"LCURLY\", \"RCURLY\", \"INT\", \"ID\", \"WS\"\r\n    ];\r\n\r\n    public static readonly modeNames = [\r\n        \"DEFAULT_MODE\",\r\n    ];\r\n\r\n    public static readonly ruleNames = [\r\n        \"AND\", \"OR\", \"NOT\", \"EQ\", \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \"LCURLY\", \r\n        \"RCURLY\", \"INT\", \"ID\", \"WS\",\r\n    ];\r\n\r\n\r\n    public constructor(input: antlr.CharStream) {\r\n        super(input);\r\n        this.interpreter = new antlr.LexerATNSimulator(this, MainGrammarLexer._ATN, MainGrammarLexer.decisionsToDFA, new antlr.PredictionContextCache());\r\n    }\r\n\r\n    public get grammarFileName(): string { return \"MainGrammar.g4\"; }\r\n\r\n    public get literalNames(): (string | null)[] { return MainGrammarLexer.literalNames; }\r\n    public get symbolicNames(): (string | null)[] { return MainGrammarLexer.symbolicNames; }\r\n    public get ruleNames(): string[] { return MainGrammarLexer.ruleNames; }\r\n\r\n    public get serializedATN(): number[] { return MainGrammarLexer._serializedATN; }\r\n\r\n    public get channelNames(): string[] { return MainGrammarLexer.channelNames; }\r\n\r\n    public get modeNames(): string[] { return MainGrammarLexer.modeNames; }\r\n\r\n    public static readonly _serializedATN: number[] = [\r\n        4,0,13,71,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,\r\n        6,7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,1,0,\r\n        1,0,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,\r\n        1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,1,10,4,10,54,8,10,11,10,12,10,55,\r\n        1,11,1,11,5,11,60,8,11,10,11,12,11,63,9,11,1,12,4,12,66,8,12,11,\r\n        12,12,12,67,1,12,1,12,0,0,13,1,1,3,2,5,3,7,4,9,5,11,6,13,7,15,8,\r\n        17,9,19,10,21,11,23,12,25,13,1,0,4,1,0,48,57,3,0,65,90,95,95,97,\r\n        122,4,0,48,57,65,90,95,95,97,122,3,0,9,10,12,13,32,32,73,0,1,1,0,\r\n        0,0,0,3,1,0,0,0,0,5,1,0,0,0,0,7,1,0,0,0,0,9,1,0,0,0,0,11,1,0,0,0,\r\n        0,13,1,0,0,0,0,15,1,0,0,0,0,17,1,0,0,0,0,19,1,0,0,0,0,21,1,0,0,0,\r\n        0,23,1,0,0,0,0,25,1,0,0,0,1,27,1,0,0,0,3,31,1,0,0,0,5,34,1,0,0,0,\r\n        7,38,1,0,0,0,9,40,1,0,0,0,11,42,1,0,0,0,13,44,1,0,0,0,15,46,1,0,\r\n        0,0,17,48,1,0,0,0,19,50,1,0,0,0,21,53,1,0,0,0,23,57,1,0,0,0,25,65,\r\n        1,0,0,0,27,28,5,97,0,0,28,29,5,110,0,0,29,30,5,100,0,0,30,2,1,0,\r\n        0,0,31,32,5,111,0,0,32,33,5,114,0,0,33,4,1,0,0,0,34,35,5,110,0,0,\r\n        35,36,5,111,0,0,36,37,5,116,0,0,37,6,1,0,0,0,38,39,5,61,0,0,39,8,\r\n        1,0,0,0,40,41,5,44,0,0,41,10,1,0,0,0,42,43,5,59,0,0,43,12,1,0,0,\r\n        0,44,45,5,40,0,0,45,14,1,0,0,0,46,47,5,41,0,0,47,16,1,0,0,0,48,49,\r\n        5,123,0,0,49,18,1,0,0,0,50,51,5,125,0,0,51,20,1,0,0,0,52,54,7,0,\r\n        0,0,53,52,1,0,0,0,54,55,1,0,0,0,55,53,1,0,0,0,55,56,1,0,0,0,56,22,\r\n        1,0,0,0,57,61,7,1,0,0,58,60,7,2,0,0,59,58,1,0,0,0,60,63,1,0,0,0,\r\n        61,59,1,0,0,0,61,62,1,0,0,0,62,24,1,0,0,0,63,61,1,0,0,0,64,66,7,\r\n        3,0,0,65,64,1,0,0,0,66,67,1,0,0,0,67,65,1,0,0,0,67,68,1,0,0,0,68,\r\n        69,1,0,0,0,69,70,6,12,0,0,70,26,1,0,0,0,4,0,55,61,67,1,6,0,0\r\n    ];\r\n\r\n    private static __ATN: antlr.ATN;\r\n    public static get _ATN(): antlr.ATN {\r\n        if (!MainGrammarLexer.__ATN) {\r\n            MainGrammarLexer.__ATN = new antlr.ATNDeserializer().deserialize(MainGrammarLexer._serializedATN);\r\n        }\r\n\r\n        return MainGrammarLexer.__ATN;\r\n    }\r\n\r\n\r\n    private static readonly vocabulary = new antlr.Vocabulary(MainGrammarLexer.literalNames, MainGrammarLexer.symbolicNames, []);\r\n\r\n    public override get vocabulary(): antlr.Vocabulary {\r\n        return MainGrammarLexer.vocabulary;\r\n    }\r\n\r\n    private static readonly decisionsToDFA = MainGrammarLexer._ATN.decisionToState.map( (ds: antlr.DecisionState, index: number) => new antlr.DFA(ds, index) );\r\n}","// Generated from c:/Users/minip/source/repos/ahk2-antlr4-demo/src/grammar/MainGrammar.g4 by ANTLR 4.13.1\r\n\r\nimport * as antlr from \"antlr4ng\";\r\nimport { Token } from \"antlr4ng\";\r\n\r\nimport { MainGrammarListener } from \"./MainGrammarListener.js\";\r\nimport { MainGrammarVisitor } from \"./MainGrammarVisitor.js\";\r\n\r\n// for running tests with parameters, TODO: discuss strategy for typed parameters in CI\r\n// eslint-disable-next-line no-unused-vars\r\ntype int = number;\r\n\r\n\r\nexport class MainGrammarParser extends antlr.Parser {\r\n    public static readonly AND = 1;\r\n    public static readonly OR = 2;\r\n    public static readonly NOT = 3;\r\n    public static readonly EQ = 4;\r\n    public static readonly COMMA = 5;\r\n    public static readonly SEMI = 6;\r\n    public static readonly LPAREN = 7;\r\n    public static readonly RPAREN = 8;\r\n    public static readonly LCURLY = 9;\r\n    public static readonly RCURLY = 10;\r\n    public static readonly INT = 11;\r\n    public static readonly ID = 12;\r\n    public static readonly WS = 13;\r\n    public static readonly RULE_program = 0;\r\n    public static readonly RULE_stat = 1;\r\n    public static readonly RULE_def = 2;\r\n    public static readonly RULE_expr = 3;\r\n    public static readonly RULE_func = 4;\r\n\r\n    public static readonly literalNames = [\r\n        null, \"'and'\", \"'or'\", \"'not'\", \"'='\", \"','\", \"';'\", \"'('\", \"')'\", \r\n        \"'{'\", \"'}'\"\r\n    ];\r\n\r\n    public static readonly symbolicNames = [\r\n        null, \"AND\", \"OR\", \"NOT\", \"EQ\", \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \r\n        \"LCURLY\", \"RCURLY\", \"INT\", \"ID\", \"WS\"\r\n    ];\r\n    public static readonly ruleNames = [\r\n        \"program\", \"stat\", \"def\", \"expr\", \"func\",\r\n    ];\r\n\r\n    public get grammarFileName(): string { return \"MainGrammar.g4\"; }\r\n    public get literalNames(): (string | null)[] { return MainGrammarParser.literalNames; }\r\n    public get symbolicNames(): (string | null)[] { return MainGrammarParser.symbolicNames; }\r\n    public get ruleNames(): string[] { return MainGrammarParser.ruleNames; }\r\n    public get serializedATN(): number[] { return MainGrammarParser._serializedATN; }\r\n\r\n    protected createFailedPredicateException(predicate?: string, message?: string): antlr.FailedPredicateException {\r\n        return new antlr.FailedPredicateException(this, predicate, message);\r\n    }\r\n\r\n    public constructor(input: antlr.TokenStream) {\r\n        super(input);\r\n        this.interpreter = new antlr.ParserATNSimulator(this, MainGrammarParser._ATN, MainGrammarParser.decisionsToDFA, new antlr.PredictionContextCache());\r\n    }\r\n    public program(): ProgramContext {\r\n        let localContext = new ProgramContext(this.context, this.state);\r\n        this.enterRule(localContext, 0, MainGrammarParser.RULE_program);\r\n        try {\r\n            this.state = 16;\r\n            this.errorHandler.sync(this);\r\n            switch (this.interpreter.adaptivePredict(this.tokenStream, 0, this.context) ) {\r\n            case 1:\r\n                this.enterOuterAlt(localContext, 1);\r\n                {\r\n                this.state = 10;\r\n                this.stat();\r\n                this.state = 11;\r\n                this.match(MainGrammarParser.EOF);\r\n                }\r\n                break;\r\n            case 2:\r\n                this.enterOuterAlt(localContext, 2);\r\n                {\r\n                this.state = 13;\r\n                this.def();\r\n                this.state = 14;\r\n                this.match(MainGrammarParser.EOF);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        catch (re) {\r\n            if (re instanceof antlr.RecognitionException) {\r\n                this.errorHandler.reportError(this, re);\r\n                this.errorHandler.recover(this, re);\r\n            } else {\r\n                throw re;\r\n            }\r\n        }\r\n        finally {\r\n            this.exitRule();\r\n        }\r\n        return localContext;\r\n    }\r\n    public stat(): StatContext {\r\n        let localContext = new StatContext(this.context, this.state);\r\n        this.enterRule(localContext, 2, MainGrammarParser.RULE_stat);\r\n        try {\r\n            this.state = 26;\r\n            this.errorHandler.sync(this);\r\n            switch (this.interpreter.adaptivePredict(this.tokenStream, 1, this.context) ) {\r\n            case 1:\r\n                this.enterOuterAlt(localContext, 1);\r\n                {\r\n                this.state = 18;\r\n                this.match(MainGrammarParser.ID);\r\n                this.state = 19;\r\n                this.match(MainGrammarParser.EQ);\r\n                this.state = 20;\r\n                this.expr(0);\r\n                this.state = 21;\r\n                this.match(MainGrammarParser.SEMI);\r\n                }\r\n                break;\r\n            case 2:\r\n                this.enterOuterAlt(localContext, 2);\r\n                {\r\n                this.state = 23;\r\n                this.expr(0);\r\n                this.state = 24;\r\n                this.match(MainGrammarParser.SEMI);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        catch (re) {\r\n            if (re instanceof antlr.RecognitionException) {\r\n                this.errorHandler.reportError(this, re);\r\n                this.errorHandler.recover(this, re);\r\n            } else {\r\n                throw re;\r\n            }\r\n        }\r\n        finally {\r\n            this.exitRule();\r\n        }\r\n        return localContext;\r\n    }\r\n    public def(): DefContext {\r\n        let localContext = new DefContext(this.context, this.state);\r\n        this.enterRule(localContext, 4, MainGrammarParser.RULE_def);\r\n        let _la: number;\r\n        try {\r\n            this.enterOuterAlt(localContext, 1);\r\n            {\r\n            this.state = 28;\r\n            this.match(MainGrammarParser.ID);\r\n            this.state = 29;\r\n            this.match(MainGrammarParser.LPAREN);\r\n            this.state = 30;\r\n            this.match(MainGrammarParser.ID);\r\n            this.state = 35;\r\n            this.errorHandler.sync(this);\r\n            _la = this.tokenStream.LA(1);\r\n            while (_la === 5) {\r\n                {\r\n                {\r\n                this.state = 31;\r\n                this.match(MainGrammarParser.COMMA);\r\n                this.state = 32;\r\n                this.match(MainGrammarParser.ID);\r\n                }\r\n                }\r\n                this.state = 37;\r\n                this.errorHandler.sync(this);\r\n                _la = this.tokenStream.LA(1);\r\n            }\r\n            this.state = 38;\r\n            this.match(MainGrammarParser.RPAREN);\r\n            this.state = 39;\r\n            this.match(MainGrammarParser.LCURLY);\r\n            this.state = 43;\r\n            this.errorHandler.sync(this);\r\n            _la = this.tokenStream.LA(1);\r\n            while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 6152) !== 0)) {\r\n                {\r\n                {\r\n                this.state = 40;\r\n                this.stat();\r\n                }\r\n                }\r\n                this.state = 45;\r\n                this.errorHandler.sync(this);\r\n                _la = this.tokenStream.LA(1);\r\n            }\r\n            this.state = 46;\r\n            this.match(MainGrammarParser.RCURLY);\r\n            }\r\n        }\r\n        catch (re) {\r\n            if (re instanceof antlr.RecognitionException) {\r\n                this.errorHandler.reportError(this, re);\r\n                this.errorHandler.recover(this, re);\r\n            } else {\r\n                throw re;\r\n            }\r\n        }\r\n        finally {\r\n            this.exitRule();\r\n        }\r\n        return localContext;\r\n    }\r\n\r\n    public expr(): ExprContext;\r\n    public expr(_p: number): ExprContext;\r\n    public expr(_p?: number): ExprContext {\r\n        if (_p === undefined) {\r\n            _p = 0;\r\n        }\r\n\r\n        let parentContext = this.context;\r\n        let parentState = this.state;\r\n        let localContext = new ExprContext(this.context, parentState);\r\n        let previousContext = localContext;\r\n        let _startState = 6;\r\n        this.enterRecursionRule(localContext, 6, MainGrammarParser.RULE_expr, _p);\r\n        try {\r\n            let alternative: number;\r\n            this.enterOuterAlt(localContext, 1);\r\n            {\r\n            this.state = 54;\r\n            this.errorHandler.sync(this);\r\n            switch (this.interpreter.adaptivePredict(this.tokenStream, 4, this.context) ) {\r\n            case 1:\r\n                {\r\n                this.state = 49;\r\n                this.match(MainGrammarParser.ID);\r\n                }\r\n                break;\r\n            case 2:\r\n                {\r\n                this.state = 50;\r\n                this.match(MainGrammarParser.INT);\r\n                }\r\n                break;\r\n            case 3:\r\n                {\r\n                this.state = 51;\r\n                this.func();\r\n                }\r\n                break;\r\n            case 4:\r\n                {\r\n                this.state = 52;\r\n                this.match(MainGrammarParser.NOT);\r\n                this.state = 53;\r\n                this.expr(3);\r\n                }\r\n                break;\r\n            }\r\n            this.context!.stop = this.tokenStream.LT(-1);\r\n            this.state = 64;\r\n            this.errorHandler.sync(this);\r\n            alternative = this.interpreter.adaptivePredict(this.tokenStream, 6, this.context);\r\n            while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {\r\n                if (alternative === 1) {\r\n                    if (this.parseListeners != null) {\r\n                        this.triggerExitRuleEvent();\r\n                    }\r\n                    previousContext = localContext;\r\n                    {\r\n                    this.state = 62;\r\n                    this.errorHandler.sync(this);\r\n                    switch (this.interpreter.adaptivePredict(this.tokenStream, 5, this.context) ) {\r\n                    case 1:\r\n                        {\r\n                        localContext = new ExprContext(parentContext, parentState);\r\n                        this.pushNewRecursionContext(localContext, _startState, MainGrammarParser.RULE_expr);\r\n                        this.state = 56;\r\n                        if (!(this.precpred(this.context, 2))) {\r\n                            throw this.createFailedPredicateException(\"this.precpred(this.context, 2)\");\r\n                        }\r\n                        this.state = 57;\r\n                        this.match(MainGrammarParser.AND);\r\n                        this.state = 58;\r\n                        this.expr(3);\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        {\r\n                        localContext = new ExprContext(parentContext, parentState);\r\n                        this.pushNewRecursionContext(localContext, _startState, MainGrammarParser.RULE_expr);\r\n                        this.state = 59;\r\n                        if (!(this.precpred(this.context, 1))) {\r\n                            throw this.createFailedPredicateException(\"this.precpred(this.context, 1)\");\r\n                        }\r\n                        this.state = 60;\r\n                        this.match(MainGrammarParser.OR);\r\n                        this.state = 61;\r\n                        this.expr(2);\r\n                        }\r\n                        break;\r\n                    }\r\n                    }\r\n                }\r\n                this.state = 66;\r\n                this.errorHandler.sync(this);\r\n                alternative = this.interpreter.adaptivePredict(this.tokenStream, 6, this.context);\r\n            }\r\n            }\r\n        }\r\n        catch (re) {\r\n            if (re instanceof antlr.RecognitionException) {\r\n                this.errorHandler.reportError(this, re);\r\n                this.errorHandler.recover(this, re);\r\n            } else {\r\n                throw re;\r\n            }\r\n        }\r\n        finally {\r\n            this.unrollRecursionContexts(parentContext);\r\n        }\r\n        return localContext;\r\n    }\r\n    public func(): FuncContext {\r\n        let localContext = new FuncContext(this.context, this.state);\r\n        this.enterRule(localContext, 8, MainGrammarParser.RULE_func);\r\n        let _la: number;\r\n        try {\r\n            this.enterOuterAlt(localContext, 1);\r\n            {\r\n            this.state = 67;\r\n            this.match(MainGrammarParser.ID);\r\n            this.state = 68;\r\n            this.match(MainGrammarParser.LPAREN);\r\n            this.state = 69;\r\n            this.expr(0);\r\n            this.state = 74;\r\n            this.errorHandler.sync(this);\r\n            _la = this.tokenStream.LA(1);\r\n            while (_la === 5) {\r\n                {\r\n                {\r\n                this.state = 70;\r\n                this.match(MainGrammarParser.COMMA);\r\n                this.state = 71;\r\n                this.expr(0);\r\n                }\r\n                }\r\n                this.state = 76;\r\n                this.errorHandler.sync(this);\r\n                _la = this.tokenStream.LA(1);\r\n            }\r\n            this.state = 77;\r\n            this.match(MainGrammarParser.RPAREN);\r\n            }\r\n        }\r\n        catch (re) {\r\n            if (re instanceof antlr.RecognitionException) {\r\n                this.errorHandler.reportError(this, re);\r\n                this.errorHandler.recover(this, re);\r\n            } else {\r\n                throw re;\r\n            }\r\n        }\r\n        finally {\r\n            this.exitRule();\r\n        }\r\n        return localContext;\r\n    }\r\n\r\n    public override sempred(localContext: antlr.ParserRuleContext | null, ruleIndex: number, predIndex: number): boolean {\r\n        switch (ruleIndex) {\r\n        case 3:\r\n            return this.expr_sempred(localContext as ExprContext, predIndex);\r\n        }\r\n        return true;\r\n    }\r\n    private expr_sempred(localContext: ExprContext | null, predIndex: number): boolean {\r\n        switch (predIndex) {\r\n        case 0:\r\n            return this.precpred(this.context, 2);\r\n        case 1:\r\n            return this.precpred(this.context, 1);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static readonly _serializedATN: number[] = [\r\n        4,1,13,80,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,1,0,1,0,1,0,1,\r\n        0,1,0,1,0,3,0,17,8,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,27,8,1,\r\n        1,2,1,2,1,2,1,2,1,2,5,2,34,8,2,10,2,12,2,37,9,2,1,2,1,2,1,2,5,2,\r\n        42,8,2,10,2,12,2,45,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,55,8,\r\n        3,1,3,1,3,1,3,1,3,1,3,1,3,5,3,63,8,3,10,3,12,3,66,9,3,1,4,1,4,1,\r\n        4,1,4,1,4,5,4,73,8,4,10,4,12,4,76,9,4,1,4,1,4,1,4,0,1,6,5,0,2,4,\r\n        6,8,0,0,84,0,16,1,0,0,0,2,26,1,0,0,0,4,28,1,0,0,0,6,54,1,0,0,0,8,\r\n        67,1,0,0,0,10,11,3,2,1,0,11,12,5,0,0,1,12,17,1,0,0,0,13,14,3,4,2,\r\n        0,14,15,5,0,0,1,15,17,1,0,0,0,16,10,1,0,0,0,16,13,1,0,0,0,17,1,1,\r\n        0,0,0,18,19,5,12,0,0,19,20,5,4,0,0,20,21,3,6,3,0,21,22,5,6,0,0,22,\r\n        27,1,0,0,0,23,24,3,6,3,0,24,25,5,6,0,0,25,27,1,0,0,0,26,18,1,0,0,\r\n        0,26,23,1,0,0,0,27,3,1,0,0,0,28,29,5,12,0,0,29,30,5,7,0,0,30,35,\r\n        5,12,0,0,31,32,5,5,0,0,32,34,5,12,0,0,33,31,1,0,0,0,34,37,1,0,0,\r\n        0,35,33,1,0,0,0,35,36,1,0,0,0,36,38,1,0,0,0,37,35,1,0,0,0,38,39,\r\n        5,8,0,0,39,43,5,9,0,0,40,42,3,2,1,0,41,40,1,0,0,0,42,45,1,0,0,0,\r\n        43,41,1,0,0,0,43,44,1,0,0,0,44,46,1,0,0,0,45,43,1,0,0,0,46,47,5,\r\n        10,0,0,47,5,1,0,0,0,48,49,6,3,-1,0,49,55,5,12,0,0,50,55,5,11,0,0,\r\n        51,55,3,8,4,0,52,53,5,3,0,0,53,55,3,6,3,3,54,48,1,0,0,0,54,50,1,\r\n        0,0,0,54,51,1,0,0,0,54,52,1,0,0,0,55,64,1,0,0,0,56,57,10,2,0,0,57,\r\n        58,5,1,0,0,58,63,3,6,3,3,59,60,10,1,0,0,60,61,5,2,0,0,61,63,3,6,\r\n        3,2,62,56,1,0,0,0,62,59,1,0,0,0,63,66,1,0,0,0,64,62,1,0,0,0,64,65,\r\n        1,0,0,0,65,7,1,0,0,0,66,64,1,0,0,0,67,68,5,12,0,0,68,69,5,7,0,0,\r\n        69,74,3,6,3,0,70,71,5,5,0,0,71,73,3,6,3,0,72,70,1,0,0,0,73,76,1,\r\n        0,0,0,74,72,1,0,0,0,74,75,1,0,0,0,75,77,1,0,0,0,76,74,1,0,0,0,77,\r\n        78,5,8,0,0,78,9,1,0,0,0,8,16,26,35,43,54,62,64,74\r\n    ];\r\n\r\n    private static __ATN: antlr.ATN;\r\n    public static get _ATN(): antlr.ATN {\r\n        if (!MainGrammarParser.__ATN) {\r\n            MainGrammarParser.__ATN = new antlr.ATNDeserializer().deserialize(MainGrammarParser._serializedATN);\r\n        }\r\n\r\n        return MainGrammarParser.__ATN;\r\n    }\r\n\r\n\r\n    private static readonly vocabulary = new antlr.Vocabulary(MainGrammarParser.literalNames, MainGrammarParser.symbolicNames, []);\r\n\r\n    public override get vocabulary(): antlr.Vocabulary {\r\n        return MainGrammarParser.vocabulary;\r\n    }\r\n\r\n    private static readonly decisionsToDFA = MainGrammarParser._ATN.decisionToState.map( (ds: antlr.DecisionState, index: number) => new antlr.DFA(ds, index) );\r\n}\r\n\r\nexport class ProgramContext extends antlr.ParserRuleContext {\r\n    public constructor(parent: antlr.ParserRuleContext | null, invokingState: number) {\r\n        super(parent, invokingState);\r\n    }\r\n    public stat(): StatContext | null {\r\n        return this.getRuleContext(0, StatContext);\r\n    }\r\n    public EOF(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.EOF, 0)!;\r\n    }\r\n    public def(): DefContext | null {\r\n        return this.getRuleContext(0, DefContext);\r\n    }\r\n    public override get ruleIndex(): number {\r\n        return MainGrammarParser.RULE_program;\r\n    }\r\n    public override enterRule(listener: MainGrammarListener): void {\r\n        if(listener.enterProgram) {\r\n             listener.enterProgram(this);\r\n        }\r\n    }\r\n    public override exitRule(listener: MainGrammarListener): void {\r\n        if(listener.exitProgram) {\r\n             listener.exitProgram(this);\r\n        }\r\n    }\r\n    public override accept<Result>(visitor: MainGrammarVisitor<Result>): Result | null {\r\n        if (visitor.visitProgram) {\r\n            return visitor.visitProgram(this);\r\n        } else {\r\n            return visitor.visitChildren(this);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class StatContext extends antlr.ParserRuleContext {\r\n    public constructor(parent: antlr.ParserRuleContext | null, invokingState: number) {\r\n        super(parent, invokingState);\r\n    }\r\n    public ID(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.ID, 0);\r\n    }\r\n    public EQ(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.EQ, 0);\r\n    }\r\n    public expr(): ExprContext {\r\n        return this.getRuleContext(0, ExprContext)!;\r\n    }\r\n    public SEMI(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.SEMI, 0)!;\r\n    }\r\n    public override get ruleIndex(): number {\r\n        return MainGrammarParser.RULE_stat;\r\n    }\r\n    public override enterRule(listener: MainGrammarListener): void {\r\n        if(listener.enterStat) {\r\n             listener.enterStat(this);\r\n        }\r\n    }\r\n    public override exitRule(listener: MainGrammarListener): void {\r\n        if(listener.exitStat) {\r\n             listener.exitStat(this);\r\n        }\r\n    }\r\n    public override accept<Result>(visitor: MainGrammarVisitor<Result>): Result | null {\r\n        if (visitor.visitStat) {\r\n            return visitor.visitStat(this);\r\n        } else {\r\n            return visitor.visitChildren(this);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class DefContext extends antlr.ParserRuleContext {\r\n    public constructor(parent: antlr.ParserRuleContext | null, invokingState: number) {\r\n        super(parent, invokingState);\r\n    }\r\n    public ID(): antlr.TerminalNode[];\r\n    public ID(i: number): antlr.TerminalNode | null;\r\n    public ID(i?: number): antlr.TerminalNode | null | antlr.TerminalNode[] {\r\n    \tif (i === undefined) {\r\n    \t\treturn this.getTokens(MainGrammarParser.ID);\r\n    \t} else {\r\n    \t\treturn this.getToken(MainGrammarParser.ID, i);\r\n    \t}\r\n    }\r\n    public LPAREN(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.LPAREN, 0)!;\r\n    }\r\n    public RPAREN(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.RPAREN, 0)!;\r\n    }\r\n    public LCURLY(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.LCURLY, 0)!;\r\n    }\r\n    public RCURLY(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.RCURLY, 0)!;\r\n    }\r\n    public COMMA(): antlr.TerminalNode[];\r\n    public COMMA(i: number): antlr.TerminalNode | null;\r\n    public COMMA(i?: number): antlr.TerminalNode | null | antlr.TerminalNode[] {\r\n    \tif (i === undefined) {\r\n    \t\treturn this.getTokens(MainGrammarParser.COMMA);\r\n    \t} else {\r\n    \t\treturn this.getToken(MainGrammarParser.COMMA, i);\r\n    \t}\r\n    }\r\n    public stat(): StatContext[];\r\n    public stat(i: number): StatContext | null;\r\n    public stat(i?: number): StatContext[] | StatContext | null {\r\n        if (i === undefined) {\r\n            return this.getRuleContexts(StatContext);\r\n        }\r\n\r\n        return this.getRuleContext(i, StatContext);\r\n    }\r\n    public override get ruleIndex(): number {\r\n        return MainGrammarParser.RULE_def;\r\n    }\r\n    public override enterRule(listener: MainGrammarListener): void {\r\n        if(listener.enterDef) {\r\n             listener.enterDef(this);\r\n        }\r\n    }\r\n    public override exitRule(listener: MainGrammarListener): void {\r\n        if(listener.exitDef) {\r\n             listener.exitDef(this);\r\n        }\r\n    }\r\n    public override accept<Result>(visitor: MainGrammarVisitor<Result>): Result | null {\r\n        if (visitor.visitDef) {\r\n            return visitor.visitDef(this);\r\n        } else {\r\n            return visitor.visitChildren(this);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class ExprContext extends antlr.ParserRuleContext {\r\n    public constructor(parent: antlr.ParserRuleContext | null, invokingState: number) {\r\n        super(parent, invokingState);\r\n    }\r\n    public ID(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.ID, 0);\r\n    }\r\n    public INT(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.INT, 0);\r\n    }\r\n    public func(): FuncContext | null {\r\n        return this.getRuleContext(0, FuncContext);\r\n    }\r\n    public NOT(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.NOT, 0);\r\n    }\r\n    public expr(): ExprContext[];\r\n    public expr(i: number): ExprContext | null;\r\n    public expr(i?: number): ExprContext[] | ExprContext | null {\r\n        if (i === undefined) {\r\n            return this.getRuleContexts(ExprContext);\r\n        }\r\n\r\n        return this.getRuleContext(i, ExprContext);\r\n    }\r\n    public AND(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.AND, 0);\r\n    }\r\n    public OR(): antlr.TerminalNode | null {\r\n        return this.getToken(MainGrammarParser.OR, 0);\r\n    }\r\n    public override get ruleIndex(): number {\r\n        return MainGrammarParser.RULE_expr;\r\n    }\r\n    public override enterRule(listener: MainGrammarListener): void {\r\n        if(listener.enterExpr) {\r\n             listener.enterExpr(this);\r\n        }\r\n    }\r\n    public override exitRule(listener: MainGrammarListener): void {\r\n        if(listener.exitExpr) {\r\n             listener.exitExpr(this);\r\n        }\r\n    }\r\n    public override accept<Result>(visitor: MainGrammarVisitor<Result>): Result | null {\r\n        if (visitor.visitExpr) {\r\n            return visitor.visitExpr(this);\r\n        } else {\r\n            return visitor.visitChildren(this);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class FuncContext extends antlr.ParserRuleContext {\r\n    public constructor(parent: antlr.ParserRuleContext | null, invokingState: number) {\r\n        super(parent, invokingState);\r\n    }\r\n    public ID(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.ID, 0)!;\r\n    }\r\n    public LPAREN(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.LPAREN, 0)!;\r\n    }\r\n    public expr(): ExprContext[];\r\n    public expr(i: number): ExprContext | null;\r\n    public expr(i?: number): ExprContext[] | ExprContext | null {\r\n        if (i === undefined) {\r\n            return this.getRuleContexts(ExprContext);\r\n        }\r\n\r\n        return this.getRuleContext(i, ExprContext);\r\n    }\r\n    public RPAREN(): antlr.TerminalNode {\r\n        return this.getToken(MainGrammarParser.RPAREN, 0)!;\r\n    }\r\n    public COMMA(): antlr.TerminalNode[];\r\n    public COMMA(i: number): antlr.TerminalNode | null;\r\n    public COMMA(i?: number): antlr.TerminalNode | null | antlr.TerminalNode[] {\r\n    \tif (i === undefined) {\r\n    \t\treturn this.getTokens(MainGrammarParser.COMMA);\r\n    \t} else {\r\n    \t\treturn this.getToken(MainGrammarParser.COMMA, i);\r\n    \t}\r\n    }\r\n    public override get ruleIndex(): number {\r\n        return MainGrammarParser.RULE_func;\r\n    }\r\n    public override enterRule(listener: MainGrammarListener): void {\r\n        if(listener.enterFunc) {\r\n             listener.enterFunc(this);\r\n        }\r\n    }\r\n    public override exitRule(listener: MainGrammarListener): void {\r\n        if(listener.exitFunc) {\r\n             listener.exitFunc(this);\r\n        }\r\n    }\r\n    public override accept<Result>(visitor: MainGrammarVisitor<Result>): Result | null {\r\n        if (visitor.visitFunc) {\r\n            return visitor.visitFunc(this);\r\n        } else {\r\n            return visitor.visitChildren(this);\r\n        }\r\n    }\r\n}\r\n"],"names":["IntStream2","Token2","$c1efbdb2cbf46748$export$194a8984a055b1cc","$c1efbdb2cbf46748$export$50792b0e93539fde","$c1efbdb2cbf46748$export$6d92bd5817d5392b","$c1efbdb2cbf46748$export$7bbbaf2220a3f180","$c1efbdb2cbf46748$var$__defProp","Object","defineProperty","$c1efbdb2cbf46748$var$__name","target","value","configurable","EOF","UNKNOWN_SOURCE_NAME","INVALID_TYPE","EPSILON","MIN_USER_TOKEN_TYPE","DEFAULT_CHANNEL","HIDDEN_CHANNEL","MIN_USER_CHANNEL_VALUE","$c1efbdb2cbf46748$export$7c699a821ea811bc","candidate","token","tokenSource","channel","$c1efbdb2cbf46748$export$33dc8f3f7b9e35df","data","Uint32Array","map","Symbol","iterator","length","currentIndex","currentWord","words","next","t","bitCount","done","clear","index","resize","or","set","minCount","Math","min","k","c","get","RangeError","slot","result","w","i","values","Array","pos","nextSetBit","fromIndex","toString","join","count","fill","v","$c1efbdb2cbf46748$export$27c628f6789aefe9","_MurmurHash","defaultSeed","initialize","seed","updateFromComparable","hash","update","hashCode","imul","finish","entryCount","$c1efbdb2cbf46748$var$ObjectEqualityComparator","_ObjectEqualityComparator","instance","obj","equals","a","b","$c1efbdb2cbf46748$var$DefaultEqualityComparator","_DefaultEqualityComparator","$c1efbdb2cbf46748$export$9d0bf21c11057332","_HashSet","defaultLoadFactor","initialCapacity","comparator","buckets","threshold","itemCount","comparatorOrSet","slice","bucket","createBuckets","floor","getOrAdd","o","expand","getBucket","existing","push","e","remove","splice","size","containsAll","add","contains","containsFast","toArray","collection","addAll","changed","buf","first","toTableString","old","newCapacity","newTable","newBucket","isEmpty","capacity","$c1efbdb2cbf46748$export$e659c2681d58d45b","_Interval","INVALID_INTERVAL","INTERVAL_POOL_MAX_VALUE","cache","start","stop","cachedHashCode","of","startsBeforeDisjoint","other","startsBeforeNonDisjoint","startsAfter","startsAfterDisjoint","startsAfterNonDisjoint","disjoint","adjacent","properlyContains","union","max","intersection","differenceNotProperlyContained","diff","$c1efbdb2cbf46748$export$6fe78fc0b86aec88","_Vocabulary","EMPTY_NAMES","EMPTY_VOCABULARY","maxTokenType","literalNames","symbolicNames","displayNames","fromTokenNames","tokenNames","tokenName","firstChar","codePointAt","getMaxTokenType","getLiteralName","tokenType","getSymbolicName","getDisplayName","displayName","literalName","symbolicName","getLiteralNames","getSymbolicNames","getDisplayNames","$c1efbdb2cbf46748$export$9aa814bfdfb30f8f","_IntervalSet","intervals","isArray","el","addOne","addSet","s","addRange","sets","minElement","maxElement","addInterval","l","h","addition","bigger","sub","forEach","toAdd","complementWithVocabulary","vocabulary","subtract","complement","and","myIntervals","theirIntervals","mySize","theirSize","j","mine","theirs","resultI","rightI","beforeCurrent","afterCurrent","resultInterval","rightInterval","n2","r","m2","interval","removeRange","toRemove","removeOne","x","replace","elementsAreChar","String","fromCodePoint","toStringWithVocabulary","elementName","i2","toStringWithRuleNames","ruleNames","$c1efbdb2cbf46748$var$valueToString","$c1efbdb2cbf46748$export$4323cc4280d5be7","$c1efbdb2cbf46748$export$dc63f52ecf814bf8","left","right","$c1efbdb2cbf46748$export$edfd5757e80058f3","$c1efbdb2cbf46748$export$221fb4e78e2caf9d","escapeSpaces","$c1efbdb2cbf46748$export$946e3ad1112f0fcb","_SemanticContext","andContext","NONE","$c1efbdb2cbf46748$var$AND","operands","orContext","$c1efbdb2cbf46748$var$OR","filterPrecedencePredicates","context","PrecedencePredicate","evalPrecedence","_parser","_parserCallStack","_AND","precedencePredicates","reduced","p","precedence","operand","evaluate","parser","parserCallStack","differs","evaluated","_OR","sort","a2","b2","compareTo","SemanticContext2","Predicate","ruleIndex","predIndex","isCtxDependent","outerContext","localctx","sempred","precpred","$c1efbdb2cbf46748$export$b371505ec63d1c9b","_ATNConfig","state","alt","reachesIntoOuterContext","precedenceFilterSuppressed","semanticContext","duplicate","createWithContext","createWithConfig","config","createWithSemanticContext","stateNumber","_recog","showAlt","$c1efbdb2cbf46748$export$21a6260de0fddd55","_ATNState","INVALID_STATE_NUMBER","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","LOOP_END","stateType","epsilonOnlyTransitions","nextTokenWithinRule","transitions","addTransitionAtIndex","transition","isEpsilon","addTransition","setTransition","removeTransition","$c1efbdb2cbf46748$export$95ea21db2ed34266","_PredictionContext","EMPTY_RETURN_STATE","traceATNSimulator","calculateEmptyHashCode","calculateHashCodeSingle","parent","returnState","calculateHashCodeList","parents","returnStates","hasEmptyPath","getReturnState","$c1efbdb2cbf46748$export$d50bfe6c4685d25b","_SingletonPredictionContext","getParent","_index","up","$c1efbdb2cbf46748$export$179fd11580abda9d","_EmptyPredictionContext","$c1efbdb2cbf46748$export$be58926105124dd4","INVALID","RANGE","RULE","PREDICATE","ATOM","ACTION","SET","NOT_SET","WILDCARD","PRECEDENCE","label","$c1efbdb2cbf46748$export$10de5c396f79e800","transitionType","matches","symbol","_minVocabSymbol","_maxVocabSymbol","$c1efbdb2cbf46748$export$a0e4d5a57a08628e","minVocabSymbol","maxVocabSymbol","$c1efbdb2cbf46748$var$MapKeyEqualityComparator","keyComparator","key","$c1efbdb2cbf46748$export$60ef0b43d585640a","_HashMap","backingStore","keyComparer","containsKey","element","setIfAbsent","keys","$c1efbdb2cbf46748$export$f6a002739fa43001","getChild","_i","getSymbol","getPayload","getSourceInterval","tokenIndex","getChildCount","accept","visitor","visitTerminal","getText","text","type","toStringTree","$c1efbdb2cbf46748$export$d3ee467d32253151","visitErrorNode","$c1efbdb2cbf46748$export$c9b1d0b06becfda3","_CommonToken","EMPTY_SOURCE","source","line","column","details","fromToken","inputStream","fromType","fromSource","input","clone","recognizer","channelStr","typeString","getTextFromRange","setText","setType","ttype","setLine","setCharPositionInLine","setChannel","setTokenIndex","$c1efbdb2cbf46748$export$18233453f5804371","_Trees","tree","recog","getNodeText","res","concat","$c1efbdb2cbf46748$export$1198dca6f94b6253","altNumber","ruleContext","getAltNumber","payload","getChildren","list","getAncestors","ancestors","isAncestorOf","u","findAllTokenNodes","findAllNodes","findAllRuleNodes","findTokens","nodes","doFindAllNodes","descendants","getRootOfSubtreeEnclosingRegion","startTokenIndex","stopTokenIndex","child","stripChildrenOutOfRange","root","startIndex","stopIndex","range","abbrev","children","_ParserRuleContext","empty","invokingState","invokingStateNumber","copyFrom","ctx","enterRule","_listener","exitRule","addChild","removeLastChild","pop","addTokenNode","node","addErrorNode","errorNode","getToken","getTokens","tokens","getRuleContext","ctxType","getRuleContexts","contexts","depth","$c1efbdb2cbf46748$export$ffe90c5f202db011","INVALID_ALT_NUMBER","setAltNumber","_altNumber","visitChildren","args","ri","$c1efbdb2cbf46748$export$642800593f263945","_ArrayPredictionContext","entries","$c1efbdb2cbf46748$export$85d7977d7e5c4cc2","$c1efbdb2cbf46748$export$c1f97ac8322a726f","atn","states","followState","$c1efbdb2cbf46748$export$8019946e4b88a3a0","contextCache","visited","updated","$c1efbdb2cbf46748$export$4950aa0f605343fb","rootIsWildcard","mergeCache","$c1efbdb2cbf46748$export$1de9f6442a66a6e2","$c1efbdb2cbf46748$var$mergeArrays","previous","mergedReturnStates","mergedParents","aParent","bParent","bothDollars","axAx","aNew","merged","console","log","$c1efbdb2cbf46748$export$3fb1d9247427cd84","uniqueParents","q","rootMerge","$c1efbdb2cbf46748$export$734cb39f208f4435","spc","singleParent","payloads2","apc","payloads","$c1efbdb2cbf46748$export$434fb93edf9df743","_LL1Analyzer","hitPredicate","getDecisionLookahead","look","lookBusy","doLook","stopState","lookContext","calledRuleStack","seeThruPreds","addEOF","removed","newContext","LEXER","PARSER","grammarType","decisionToState","ruleToStartState","ruleToStopState","modeNameToStartState","Map","ruleToTokenType","lexerActions","modeToStartState","analyzer","nextTokens","atnState","addState","removeState","defineDecisionState","decision","getDecisionState","getNumberOfDecisions","getExpectedTokens","Error","following","expected","rt","$c1efbdb2cbf46748$var$KeyTypeEqualityComparer","_KeyTypeEqualityComparer","$c1efbdb2cbf46748$export$3e159d9d82bfca90","configLookup","configs","uniqueAlt","hasSemanticContext","dipsIntoOuterContext","fullCtx","readOnly","conflictingAlts","firstStopState","fullCtxOrOldSet","elements","getAlts","alts","getPredicates","preds","getStates","optimizeConfigs","interpreter","getCachedContext","coll","computeHashCode","item","setReadonly","$c1efbdb2cbf46748$export$a24717045da89386","$c1efbdb2cbf46748$export$546c00a8fe1b4d1a","nonGreedy","$c1efbdb2cbf46748$export$47d3f79353fa3139","endState","$c1efbdb2cbf46748$export$ef7d128af4cd29f","startState","$c1efbdb2cbf46748$export$8ff967d5b8bcca40","loopBackState","$c1efbdb2cbf46748$export$d69d85a987fddbef","isLeftRecursiveRule","$c1efbdb2cbf46748$export$ba787240acf6572c","$c1efbdb2cbf46748$export$c7815420e454fdf8","$c1efbdb2cbf46748$export$5f5ea071b7e146fe","$c1efbdb2cbf46748$export$29739011cda0b11b","$c1efbdb2cbf46748$export$d8a6440f35eed376","precedenceRuleDecision","$c1efbdb2cbf46748$export$4b53728d66f9971c","$c1efbdb2cbf46748$export$9162e345fad804f4","$c1efbdb2cbf46748$export$6c4b09c827e3821","$c1efbdb2cbf46748$export$749c9accb19d603f","labelValue","$c1efbdb2cbf46748$export$5a1cda5a00fd126","ruleStart","_symbol","$c1efbdb2cbf46748$export$87d1473c8b7b4627","fromCharCode","$c1efbdb2cbf46748$export$56d58b5b6c0e2f81","actionIndex","$c1efbdb2cbf46748$export$a59e0290d2db6277","outermostPrecedenceReturn","$c1efbdb2cbf46748$export$6c899f6a62150677","$c1efbdb2cbf46748$export$9c060788e1247c64","$c1efbdb2cbf46748$export$5cb5e35f9f7e22cb","getPredicate","$c1efbdb2cbf46748$export$60837bdbee1d005a","$c1efbdb2cbf46748$export$842feb98d9f55ed6","_LexerSkipAction","actionType","isPositionDependent","execute","lexer","skip","$c1efbdb2cbf46748$export$71cca5a94cb644c7","_LexerChannelAction","$c1efbdb2cbf46748$export$25fe59d2129b8548","_LexerCustomAction","action","$c1efbdb2cbf46748$export$c4effa542afc3183","_LexerMoreAction","more","$c1efbdb2cbf46748$export$f63d91da13fce1b8","_LexerTypeAction","$c1efbdb2cbf46748$export$216fde1331e53997","_LexerPushModeAction","mode","pushMode","$c1efbdb2cbf46748$export$229e5f08dbd6272f","_LexerPopModeAction","popMode","$c1efbdb2cbf46748$export$cdb18c047c6321c6","_LexerModeAction","$c1efbdb2cbf46748$export$8d551c119323a3a7","_ATNDeserializer","SERIALIZED_VERSION","stateTypeMapper","lexerActionFactoryMapper","data1","data2","deserializationOptions","actionFactories","options","verifyATN","generateRuleBypassTransitions","deserialize","checkVersion","readATN","readStates","readRules","readModes","readSets","readEdges","readDecisions","readLexerActions","markPrecedenceDecisions","version","loopBackStateNumbers","endStateNumbers","stateCount","stateFactory","loopBackStateNumber","endStateNumber","pair","numNonGreedyStates","numPrecedenceStates","ruleCount","modeCount","intervalSet","containsEof","i1","trans","edgeCount","src","trg","arg1","arg2","arg3","edgeFactory","srcState","decisionCount","decState","lexerActionFactory","generateRuleBypassTransition","idx","bypassStart","bypassStop","excludeTransition","stateIsEndStateFor","matchState","maybeLoopEndState","checkCondition","condition","message","ctor","factory","$c1efbdb2cbf46748$export$6fcf45964b87cc59","_OrderedHashMap","_ATNSerializer","nonGreedyStates","precedenceStates","getSerialized","serialize","serializeSets","addPreamble","addEdges","addNonGreedyStates","addPrecedenceStates","addRuleStatesAndLexerTokenTypes","addModeStartStates","setIndices","addSets","addDecisionStartStates","addLexerActions","decStartState","edgeType","st","ppt","pt","at","setIndex","modeStartState","ruleStartState","$c1efbdb2cbf46748$export$61470cd35b9c4833","_DFAState","edges","isAcceptState","prediction","lexerActionExecutor","requiresFullContext","predicates","fromState","fromConfigs","getAltSet","Set","$c1efbdb2cbf46748$export$b12c0eaae78de602","ERROR","sharedContextCache","_CodePointTransitions","createWithCodePoint","codePoint","createWithCodePointRange","codePointFrom","codePointTo","$c1efbdb2cbf46748$export$7dca65db55187a88","invocations","timeInPrediction","sllTotalLook","sllMinLook","sllMaxLook","sllMaxLookEvent","llTotalLook","llMinLook","llMaxLook","llMaxLookEvent","contextSensitivities","errors","ambiguities","predicateEvals","sllATNTransitions","sllDFATransitions","llFallback","llATNTransitions","llDFATransitions","$c1efbdb2cbf46748$export$2c28ca15a370dd3e","_LexerATNConfig","passedThroughNonGreedyDecision","checkNonGreedyDecision","createWithExecutor","$c1efbdb2cbf46748$export$2746258315f6b7a5","syntaxError","offendingSymbol","msg","reportAmbiguity","dfa","exact","ambigAlts","reportAttemptingFullContext","reportContextSensitivity","$c1efbdb2cbf46748$export$f571db487d32849d","_ConsoleErrorListener","charPositionInLine","_e","error","$c1efbdb2cbf46748$export$ee73ae08947f8850","delegates","d","$c1efbdb2cbf46748$export$d051b53981c4a264","_Recognizer","tokenTypeMapCache","ruleIndexMapCache","listeners","toolVersion","runtimeVersion","addErrorListener","listener","removeErrorListeners","removeErrorListener","getErrorListeners","getTokenTypeMap","getRuleIndexMap","ruleName","getTokenType","getErrorHeader","offendingToken","errorListenerDispatch","_localctx","_ruleIndex","_actionIndex","_precedence","getParseInfo","$c1efbdb2cbf46748$export$37f5fb6f74ae1f7","_CommonTokenFactory","DEFAULT","copyText","create","$c1efbdb2cbf46748$export$c1c401305ad687ac","_RecognitionException","offendingState","params","captureStackTrace","$c1efbdb2cbf46748$export$b0273c9bf9a740df","deadEndConfigs","$c1efbdb2cbf46748$export$6168dc8908a6c652","_Lexer","DEFAULT_MODE","MORE","SKIP","DEFAULT_TOKEN_CHANNEL","HIDDEN","minDFAEdge","maxDFAEdge","minCodePoint","maxCodePoint","tokenStartCharIndex","currentTokenColumn","currentTokenStartLine","hitEOF","reset","seekBack","seek","nextToken","tokenStartMarker","mark","emitEOF","continueOuter","match","notifyListeners","recover","LA","emit","release","$c1efbdb2cbf46748$export$e2b3d84d700fff0a","debug","modeStack","emitToken","getCharIndex","eof","getAllTokens","getErrorDisplay","getErrorDisplayForChar","charCodeAt","getCharErrorDisplay","re","consume","tokenFactory","sourceName","getSourceName","$c1efbdb2cbf46748$export$58907c774c5f6b76","s0","getStateString","getEdgeLabel","name","baseStateStr","$c1efbdb2cbf46748$export$99ec819fcd61fb61","$c1efbdb2cbf46748$export$d210bcfe90c75f0","atnStartState","isPrecedenceDfa","precedenceDfa","getPrecedenceStartState","setPrecedenceStartState","o1","o2","getState","getStateForConfigs","has","serializer","toLexerString","$c1efbdb2cbf46748$export$4db024666b607969","_LexerIndexedCustomAction","offset","$c1efbdb2cbf46748$export$291583ae58f6a758","_LexerActionExecutor","append","lexerAction","fixOffsetBeforeMatch","updatedLexerActions","requiresSeek","every","$c1efbdb2cbf46748$export$d5d979e8d34e65c7","_OrderedHashSet","oldSize","$c1efbdb2cbf46748$export$21ea10f62e292dcc","_LexerATNSimulator","decisionToDFA","prevAccept","lexerATNConfigFactory","matchATN","execATN","clearDFA","getDFA","curChar","getTokenName","tt","oldMode","s0Closure","computeStartState","suppressEdge","addDFAState","predict","captureSimState","getExistingTargetState","computeTargetState","failOrAccept","reach","getReachableConfigSet","addDFAEdge","dfaState","closure","skipAlt","cfg","currentAltReachedAcceptState","getReachableTarget","treatEofAsEpsilon","charPos","initialContext","speculative","getEpsilonTarget","setupATNFactoryLookup","evaluatePredicate","simple","savedColumn","savedLine","marker","from","tk","to","proposed","firstConfigWithRuleStopState","$c1efbdb2cbf46748$export$3d86ef9f5652e0c2","atnSimulator","getDecisionInfo","getLLDecisions","decisions","fallBack","getTotalTimeInPrediction","getTotalSLLLookaheadOps","getTotalLLLookaheadOps","getTotalSLLATNLookaheadOps","getTotalLLATNLookaheadOps","getTotalATNLookaheadOps","getDFASize","$c1efbdb2cbf46748$export$24170894ee7a3e61","startToken","getCurrentToken","$c1efbdb2cbf46748$export$5c60622321c5364e","cacheMap","$c1efbdb2cbf46748$var$SubsetEqualityComparer","_SubsetEqualityComparer","$c1efbdb2cbf46748$export$a8734b9e3c538260","_PredictionMode","SLL","LL","LL_EXACT_AMBIG_DETECTION","hasSLLConflictTerminatingPrediction","allConfigsInRuleStopStates","dup","altSets","getConflictingAltSubsets","hasConflictingAltSet","hasStateAssociatedWithOneAlt","hasConfigInRuleStopState","resolvesToJustOneViableAlt","getSingleViableAlt","allSubsetsConflict","hasNonConflictingAltSet","allSubsetsEqual","getUniqueAlt","all","configToAlts","getStateToAltMap","counts","some","minAlt","$c1efbdb2cbf46748$export$7baac15c7bd92e00","_ParserATNSimulator","debugAdd","debugClosure","dfaDebug","retryDebug","predictionMode","predictionState","adaptivePredict","getLookaheadName","LT","getPrecedence","s0_closure","applyPrecedenceFilter","previousState","nextState","noViableAlt","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule","conflictIndex","evalSemanticContext","execATNWithFullContext","previousD","computeReachSet","D","predictedAlt","altSubSets","getConflictingAlts","predicateDFAState","getRuleName","dumpDeadEndConfigs","neg","decisionState","altCount","altsToCollectPredsFrom","getConflictingAltsOrUniqueAlt","altToPred","getPredsForAmbigAlts","getPredicatePredictions","foundExactAmbig","intermediate","skippedStopStates","closureBusy","removeAllConfigsNotInRuleStopState","lookToEndOfRule","endOfRuleState","statesFromAlt1","configSet","updatedContext","nPredAlts","pred","pairs","containsPredicate","splitConfigs","splitAccordingToSemanticValidity","semValidConfigs","semInvalidConfigs","getAltThatFinishedDecisionEntryRule","indexOf","succeeded","failed","predPredictions","complete","predictions","predicateEvaluationResult","collectPredicates","closureCheckingStopState","closure_","canDropLoopEntryEdgeInLeftRecursiveRule","continueCollecting","newDepth","numCtxs","blockEndStateNum","decisionStartState","blockEndState","returnStateNumber","returnStateTarget","inContext","ruleTransition","precedenceTransition","predTransition","getRuleInvocationStack","currentPosition","predSucceeds","newSemCtx","newState","tokenStream","getTextFromInterval","$c1efbdb2cbf46748$export$5afaa830ff2e40ab","$c1efbdb2cbf46748$export$82d303abae5db5e0","numDecisions","currentDecision","currentState","conflictingAltResolvedBySLL","sllStopIndex","llStopIndex","performance","now","sllLook","llLook","existingTargetState","reachConfigs","getCurrentState","PredPrediction2","$c1efbdb2cbf46748$export$6b89c498ba520494","cause","parseInterpreterData","channels","modes","lines","split","serializedATN","startsWith","Number","substring","trim","endsWith","deserializer","visit","defaultResult","shouldVisitNextChild","childResult","aggregateResult","_node","_currentResult","aggregate","nextResult","_ParseTreeWalker","walk","enterEveryRule","exitEveryRule","CharStream2","fromString","str","$c1efbdb2cbf46748$export$e7f59ed6635e55ad","codePoints","char","_marker","stringFromRange","$c1efbdb2cbf46748$export$fc9236fcd9399ac6","$c1efbdb2cbf46748$export$574d442acf9221a4","fetchedEOF","lazyInit","adjustSeekIndex","sync","fetched","fetch","types","subset","LB","setup","setTokenSource","nextTokenOnChannel","previousTokenOnChannel","getHiddenTokensToRight","nextOnChannel","filterForChannel","getHiddenTokensToLeft","prevOnChannel","hidden","getTextFromContext","setColumn","$c1efbdb2cbf46748$export$3b6c0b5bd4a5b0b9","getNumberOfOnChannelTokens","$c1efbdb2cbf46748$export$5b42d76e23d5259b","_XPathLexer","TOKEN_REF","RULE_REF","ANYWHERE","ROOT","BANG","ID","STRING","channelNames","modeNames","_ATN","decisionsToDFA","grammarFileName","_serializedATN","localContext","ID_action","charAt","toUpperCase","__ATN","ds","$c1efbdb2cbf46748$export$73e018a229fb3ec2","_recognizer","_offendingSymbol","_line","_charPositionInLine","_msg","$c1efbdb2cbf46748$export$1c34f17cc753a4b3","invert","nodeName","$c1efbdb2cbf46748$export$799f9af540cf584c","$c1efbdb2cbf46748$export$98cb6373280e2e5e","$c1efbdb2cbf46748$export$f55fe643209e0e5","$c1efbdb2cbf46748$export$836948de4f287b87","$c1efbdb2cbf46748$export$c74723909eb3fe20","$c1efbdb2cbf46748$export$5aad3c96ca5049d2","$c1efbdb2cbf46748$export$7a9cd09469f0bdd4","kids","_XPath","NOT","path","findAll","xpath","loop","anywhere","pathElement","getXPathElement","dummyRoot","work","matching","wordToken","word","getRuleIndex","$c1efbdb2cbf46748$export$5a0870a55ad02f1a","$c1efbdb2cbf46748$export$81a18305c772520b","pattern","labels","mismatchedNode","parseTrees","getAll","getLabels","getMismatchedNode","getPattern","getTree","$c1efbdb2cbf46748$export$4644540f3a71357c","patternRuleIndex","patternTree","matcher","subtrees","getParser","getMatcher","getPatternRuleIndex","getPatternTree","$c1efbdb2cbf46748$export$d9ee09ac275d2b50","$c1efbdb2cbf46748$export$30ec716fb19257aa","predicateIndex","predicate","$c1efbdb2cbf46748$var$formatMessage","$c1efbdb2cbf46748$export$adb4ae595794600e","errorRecoveryMode","lastErrorIndex","lastErrorStates","nextTokensContext","nextTokenState","endErrorCondition","beginErrorCondition","inErrorRecoveryMode","reportMatch","reportError","reportNoViableAlternative","reportInputMismatch","reportFailedPredicate","notifyErrorListeners","followSet","getErrorRecoverySet","consumeUntil","la","singleTokenDeletion","reportUnwantedToken","expecting","whatFollowsLoopIterationOrRule","escapeWSAndQuote","getTokenErrorDisplay","reportMissingToken","recoverInline","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","expectingAtLL2","nextTokenType","tokenText","currentSymbol","expectedTokenType","current","lookBack","getTokenFactory","recoverSet","follow","$c1efbdb2cbf46748$export$cabbde8fee9a839f","$c1efbdb2cbf46748$export$e0b3f8bf1c84aaf0","eofToken","lastToken","lastNewLine","lastIndexOf","previousStop","$c1efbdb2cbf46748$export$c0116ce21f634f83","$c1efbdb2cbf46748$export$4f4d5f744a81e34d","$c1efbdb2cbf46748$export$7acfa6ed01010e37","printer","buildParseTrees","errorHandler","precedenceStack","parseListeners","syntaxErrors","matchedEOF","tracer","bypassAltsAtnCache","rewindInputStream","setTrace","createErrorNode","matchWildcard","getParseListeners","addParseListener","removeParseListener","removeParseListeners","triggerEnterRuleEvent","triggerExitRuleEvent","reverse","setTokenFactory","compileParseTreePattern","$c1efbdb2cbf46748$export$d74d529f6cce9c80","compile","getATNWithBypassAlts","serializedAtn","numberOfSyntaxErrors","err","hasListener","addContextToParseTree","enterOuterAlt","altNum","enterRecursionRule","pushNewRecursionContext","unrollRecursionContexts","retCtx","getInvokingContext","isExpectedToken","getExpectedTokensWithinCurrentRule","stack","getDFAStrings","dumpDFA","seenOne","println","print","interp","setProfile","profile","saveMode","sim","trace","createTerminalNode","$c1efbdb2cbf46748$export$a5c3073794ecd4fa","rootContext","overrideDecisionRoot","parentContextStack","overrideDecisionAlt","overrideDecisionReached","pushRecursionContextStates","parse","startRuleIndex","startRuleStartState","createInterpreterRuleContext","parentContext","visitRuleStopState","visitState","addDecisionOverride","forcedAlt","overrideDecision","overrideDecisionInputIndex","visitDecisionState","predicateTransition","actionTransition","tok","stream","sourcePair","expectedTokens","errToken","$c1efbdb2cbf46748$var$MultiMap","elementsForKey","getPairs","$c1efbdb2cbf46748$export$344d2676d4b1c4b8","$c1efbdb2cbf46748$export$5306700912446622","bypassTokenType","$c1efbdb2cbf46748$export$5c9cf7350b941248","$c1efbdb2cbf46748$export$ca0041efa08e2ccb","tag","$c1efbdb2cbf46748$export$f51fbcdb08f0da87","$c1efbdb2cbf46748$export$e379f163e8412270","escape","setDelimiters","escapeLeft","matchImpl","tokenize","parserInterp","getLexer","chunks","chunk","tagChunk","toLowerCase","ruleImaginaryTokenType","textChunk","starts","stops","tagCount","ruleOrToken","colon","afterLastTag","unescaped","tc","replaceAll","t1","t2","tokenTagToken","ruleTagToken","getRuleTagToken","childMatch","exactOnly","getDecisionDescription","_conflictingAlts","_configs","_prediction","reportedAlts","_RuntimeMetaData","VERSION","getRuntimeVersion","generatingToolVersion","compileTimeVersion","runtimeConflictsWithGeneratingTool","runtimeConflictsWithCompileTimeTool","getMajorMinorVersion","firstDot","secondDot","firstDash","referenceLength","_TokenStreamRewriter","DEFAULT_PROGRAM_NAME","PROGRAM_INIT_SIZE","MIN_TOKEN_INDEX","programs","lastRewriteTokenIndexes","getTokenStream","insertAfter","tokenOrIndex","programName","rewrites","getProgram","op","$c1efbdb2cbf46748$var$InsertAfterOp","insertBefore","$c1efbdb2cbf46748$var$InsertBeforeOp","replaceSingle","$c1efbdb2cbf46748$var$ReplaceOp","delete","is","initializeProgram","intervalOrProgram","indexToOp","reduceToSingleOperationPerIndex","iop","getKindOfOps","rop","instructionIndex","lastIndex","prevRop","prevIop","catOpText","y","kind","before","filter","$c1efbdb2cbf46748$var$RewriteOperation","_buf","n","numMarkers","lastTokenBufferStart","currentTokenIndex","bufferSize","bufferStartIndex","getBufferStartIndex","bufferStopIndex","copyWithin","want","need","$abcf7a628702571d$export$93e3b1450253a6f7","AND","OR","EQ","COMMA","SEMI","LPAREN","RPAREN","LCURLY","RCURLY","INT","WS","$2e334593fe001b5e$export$800110701abe823","RULE_program","RULE_stat","RULE_def","RULE_expr","RULE_func","createFailedPredicateException","program","$2e334593fe001b5e$export$eb6fef7b613a504d","stat","def","$2e334593fe001b5e$export$375382d24fd8693f","expr","_la","$2e334593fe001b5e$export$5183956a3a58a148","_p","undefined","parentState","$2e334593fe001b5e$export$286a3f51a71cff58","alternative","func","$2e334593fe001b5e$export$6db68263558e628","expr_sempred","enterProgram","exitProgram","visitProgram","enterStat","exitStat","visitStat","enterDef","exitDef","visitDef","enterExpr","exitExpr","visitExpr","enterFunc","exitFunc","visitFunc","$b4e14b6b8da86996$var$inputEl","document","getElementById","$b4e14b6b8da86996$var$outputEl","$b4e14b6b8da86996$var$btn","addEventListener","textContent"],"version":3,"file":"ahk2-antlr4-demo.6a4e3c52.js.map"}